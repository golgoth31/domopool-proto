// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: domopool.proto

package domopool_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RelayStates int32

const (
	auto  RelayStates = 0
	start RelayStates = 1
	stop  RelayStates = 2
)

var RelayStates_name = map[int32]string{
	0: "auto",
	1: "start",
	2: "stop",
}

var RelayStates_value = map[string]int32{
	"auto":  0,
	"start": 1,
	"stop":  2,
}

func (RelayStates) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{0}
}

type RelayNames int32

const (
	filter RelayNames = 0
	ch     RelayNames = 1
	ph     RelayNames = 2
	light  RelayNames = 3
)

var RelayNames_name = map[int32]string{
	0: "filter",
	1: "ch",
	2: "ph",
	3: "light",
}

var RelayNames_value = map[string]int32{
	"filter": 0,
	"ch":     1,
	"ph":     2,
	"light":  3,
}

func (RelayNames) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{1}
}

type NTP struct {
	DayLight uint32 `protobuf:"varint,1,opt,name=day_light,json=dayLight,proto3" json:"day_light,omitempty"`
	Server   string `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
	Timezone uint32 `protobuf:"varint,3,opt,name=timezone,proto3" json:"timezone,omitempty"`
}

func (m *NTP) Reset()      { *m = NTP{} }
func (*NTP) ProtoMessage() {}
func (*NTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{0}
}
func (m *NTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTP.Merge(m, src)
}
func (m *NTP) XXX_Size() int {
	return m.Size()
}
func (m *NTP) XXX_DiscardUnknown() {
	xxx_messageInfo_NTP.DiscardUnknown(m)
}

var xxx_messageInfo_NTP proto.InternalMessageInfo

func (m *NTP) GetDayLight() uint32 {
	if m != nil {
		return m.DayLight
	}
	return 0
}

func (m *NTP) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *NTP) GetTimezone() uint32 {
	if m != nil {
		return m.Timezone
	}
	return 0
}

type Mqtt struct {
	Enabled bool   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Server  string `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
}

func (m *Mqtt) Reset()      { *m = Mqtt{} }
func (*Mqtt) ProtoMessage() {}
func (*Mqtt) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{1}
}
func (m *Mqtt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mqtt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mqtt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mqtt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mqtt.Merge(m, src)
}
func (m *Mqtt) XXX_Size() int {
	return m.Size()
}
func (m *Mqtt) XXX_DiscardUnknown() {
	xxx_messageInfo_Mqtt.DiscardUnknown(m)
}

var xxx_messageInfo_Mqtt proto.InternalMessageInfo

func (m *Mqtt) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Mqtt) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

type Network struct {
	Dhcp      bool   `protobuf:"varint,1,opt,name=dhcp,proto3" json:"dhcp,omitempty"`
	Ip        string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Netmask   string `protobuf:"bytes,3,opt,name=netmask,proto3" json:"netmask,omitempty"`
	Gateway   string `protobuf:"bytes,4,opt,name=gateway,proto3" json:"gateway,omitempty"`
	Dns       string `protobuf:"bytes,5,opt,name=dns,proto3" json:"dns,omitempty"`
	AllowPost bool   `protobuf:"varint,6,opt,name=allow_post,json=allowPost,proto3" json:"allow_post,omitempty"`
	Mqtt      *Mqtt  `protobuf:"bytes,7,opt,name=mqtt,proto3" json:"mqtt,omitempty"`
	Ntp       *NTP   `protobuf:"bytes,8,opt,name=ntp,proto3" json:"ntp,omitempty"`
}

func (m *Network) Reset()      { *m = Network{} }
func (*Network) ProtoMessage() {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{2}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func (m *Network) GetDhcp() bool {
	if m != nil {
		return m.Dhcp
	}
	return false
}

func (m *Network) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Network) GetNetmask() string {
	if m != nil {
		return m.Netmask
	}
	return ""
}

func (m *Network) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *Network) GetDns() string {
	if m != nil {
		return m.Dns
	}
	return ""
}

func (m *Network) GetAllowPost() bool {
	if m != nil {
		return m.AllowPost
	}
	return false
}

func (m *Network) GetMqtt() *Mqtt {
	if m != nil {
		return m.Mqtt
	}
	return nil
}

func (m *Network) GetNtp() *NTP {
	if m != nil {
		return m.Ntp
	}
	return nil
}

type Temp struct {
	Enabled bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Init    bool     `protobuf:"varint,2,opt,name=init,proto3" json:"init,omitempty"`
	Addr    []uint32 `protobuf:"varint,8,rep,packed,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Temp) Reset()      { *m = Temp{} }
func (*Temp) ProtoMessage() {}
func (*Temp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{3}
}
func (m *Temp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Temp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Temp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Temp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Temp.Merge(m, src)
}
func (m *Temp) XXX_Size() int {
	return m.Size()
}
func (m *Temp) XXX_DiscardUnknown() {
	xxx_messageInfo_Temp.DiscardUnknown(m)
}

var xxx_messageInfo_Temp proto.InternalMessageInfo

func (m *Temp) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Temp) GetInit() bool {
	if m != nil {
		return m.Init
	}
	return false
}

func (m *Temp) GetAddr() []uint32 {
	if m != nil {
		return m.Addr
	}
	return nil
}

type Limits struct {
	WpMin float32 `protobuf:"fixed32,1,opt,name=wp_min,json=wpMin,proto3" json:"wp_min,omitempty"`
	WpMax float32 `protobuf:"fixed32,2,opt,name=wp_max,json=wpMax,proto3" json:"wp_max,omitempty"`
	PhMin float32 `protobuf:"fixed32,3,opt,name=ph_min,json=phMin,proto3" json:"ph_min,omitempty"`
	PhMax float32 `protobuf:"fixed32,4,opt,name=ph_max,json=phMax,proto3" json:"ph_max,omitempty"`
	ChMin float32 `protobuf:"fixed32,5,opt,name=ch_min,json=chMin,proto3" json:"ch_min,omitempty"`
	ChMax float32 `protobuf:"fixed32,6,opt,name=ch_max,json=chMax,proto3" json:"ch_max,omitempty"`
	// number of hour to wait when temp is above 15 to activate ch
	WaitBeforeCh uint32 `protobuf:"varint,7,opt,name=wait_before_ch,json=waitBeforeCh,proto3" json:"wait_before_ch,omitempty"`
	// temp threshold to activate ch
	ChTempThreshold float32 `protobuf:"fixed32,8,opt,name=ch_temp_threshold,json=chTempThreshold,proto3" json:"ch_temp_threshold,omitempty"`
	// temp threshold to reset ch wait time
	ChTempWaitReset float32 `protobuf:"fixed32,9,opt,name=ch_temp_wait_reset,json=chTempWaitReset,proto3" json:"ch_temp_wait_reset,omitempty"`
	Wp_0Derive      float32 `protobuf:"fixed32,10,opt,name=wp_0_derive,json=wp0Derive,proto3" json:"wp_0_derive,omitempty"`
	TwMin           float32 `protobuf:"fixed32,11,opt,name=tw_min,json=twMin,proto3" json:"tw_min,omitempty"`
	TwMax           float32 `protobuf:"fixed32,12,opt,name=tw_max,json=twMax,proto3" json:"tw_max,omitempty"`
	TambMin         float32 `protobuf:"fixed32,13,opt,name=tamb_min,json=tambMin,proto3" json:"tamb_min,omitempty"`
}

func (m *Limits) Reset()      { *m = Limits{} }
func (*Limits) ProtoMessage() {}
func (*Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{4}
}
func (m *Limits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limits.Merge(m, src)
}
func (m *Limits) XXX_Size() int {
	return m.Size()
}
func (m *Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_Limits proto.InternalMessageInfo

func (m *Limits) GetWpMin() float32 {
	if m != nil {
		return m.WpMin
	}
	return 0
}

func (m *Limits) GetWpMax() float32 {
	if m != nil {
		return m.WpMax
	}
	return 0
}

func (m *Limits) GetPhMin() float32 {
	if m != nil {
		return m.PhMin
	}
	return 0
}

func (m *Limits) GetPhMax() float32 {
	if m != nil {
		return m.PhMax
	}
	return 0
}

func (m *Limits) GetChMin() float32 {
	if m != nil {
		return m.ChMin
	}
	return 0
}

func (m *Limits) GetChMax() float32 {
	if m != nil {
		return m.ChMax
	}
	return 0
}

func (m *Limits) GetWaitBeforeCh() uint32 {
	if m != nil {
		return m.WaitBeforeCh
	}
	return 0
}

func (m *Limits) GetChTempThreshold() float32 {
	if m != nil {
		return m.ChTempThreshold
	}
	return 0
}

func (m *Limits) GetChTempWaitReset() float32 {
	if m != nil {
		return m.ChTempWaitReset
	}
	return 0
}

func (m *Limits) GetWp_0Derive() float32 {
	if m != nil {
		return m.Wp_0Derive
	}
	return 0
}

func (m *Limits) GetTwMin() float32 {
	if m != nil {
		return m.TwMin
	}
	return 0
}

func (m *Limits) GetTwMax() float32 {
	if m != nil {
		return m.TwMax
	}
	return 0
}

func (m *Limits) GetTambMin() float32 {
	if m != nil {
		return m.TambMin
	}
	return 0
}

type AnalogSensor struct {
	Enabled           bool    `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	AdcPin            uint32  `protobuf:"varint,3,opt,name=adc_pin,json=adcPin,proto3" json:"adc_pin,omitempty"`
	Threshold         float32 `protobuf:"fixed32,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	ThresholdAccuracy uint32  `protobuf:"varint,4,opt,name=threshold_accuracy,json=thresholdAccuracy,proto3" json:"threshold_accuracy,omitempty"`
	Vmin              float32 `protobuf:"fixed32,5,opt,name=vmin,proto3" json:"vmin,omitempty"`
	Vmax              float32 `protobuf:"fixed32,6,opt,name=vmax,proto3" json:"vmax,omitempty"`
	PrecisionFactor   uint32  `protobuf:"varint,7,opt,name=precision_factor,json=precisionFactor,proto3" json:"precision_factor,omitempty"`
	AutoCal           bool    `protobuf:"varint,8,opt,name=auto_cal,json=autoCal,proto3" json:"auto_cal,omitempty"`
}

func (m *AnalogSensor) Reset()      { *m = AnalogSensor{} }
func (*AnalogSensor) ProtoMessage() {}
func (*AnalogSensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{5}
}
func (m *AnalogSensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalogSensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalogSensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalogSensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalogSensor.Merge(m, src)
}
func (m *AnalogSensor) XXX_Size() int {
	return m.Size()
}
func (m *AnalogSensor) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalogSensor.DiscardUnknown(m)
}

var xxx_messageInfo_AnalogSensor proto.InternalMessageInfo

func (m *AnalogSensor) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AnalogSensor) GetAdcPin() uint32 {
	if m != nil {
		return m.AdcPin
	}
	return 0
}

func (m *AnalogSensor) GetThreshold() float32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *AnalogSensor) GetThresholdAccuracy() uint32 {
	if m != nil {
		return m.ThresholdAccuracy
	}
	return 0
}

func (m *AnalogSensor) GetVmin() float32 {
	if m != nil {
		return m.Vmin
	}
	return 0
}

func (m *AnalogSensor) GetVmax() float32 {
	if m != nil {
		return m.Vmax
	}
	return 0
}

func (m *AnalogSensor) GetPrecisionFactor() uint32 {
	if m != nil {
		return m.PrecisionFactor
	}
	return 0
}

func (m *AnalogSensor) GetAutoCal() bool {
	if m != nil {
		return m.AutoCal
	}
	return false
}

type Sensors struct {
	Twin              *Temp         `protobuf:"bytes,1,opt,name=twin,proto3" json:"twin,omitempty"`
	Twout             *Temp         `protobuf:"bytes,2,opt,name=twout,proto3" json:"twout,omitempty"`
	Tamb              *Temp         `protobuf:"bytes,3,opt,name=tamb,proto3" json:"tamb,omitempty"`
	WaitForConversion bool          `protobuf:"varint,4,opt,name=wait_for_conversion,json=waitForConversion,proto3" json:"wait_for_conversion,omitempty"`
	TempResolution    uint32        `protobuf:"varint,5,opt,name=temp_resolution,json=tempResolution,proto3" json:"temp_resolution,omitempty"`
	PrecisionFactor   uint32        `protobuf:"varint,6,opt,name=precision_factor,json=precisionFactor,proto3" json:"precision_factor,omitempty"`
	Ph                *AnalogSensor `protobuf:"bytes,7,opt,name=ph,proto3" json:"ph,omitempty"`
	Ch                *AnalogSensor `protobuf:"bytes,8,opt,name=ch,proto3" json:"ch,omitempty"`
	Wp                *AnalogSensor `protobuf:"bytes,9,opt,name=wp,proto3" json:"wp,omitempty"`
	AdcMode           uint32        `protobuf:"varint,10,opt,name=adc_mode,json=adcMode,proto3" json:"adc_mode,omitempty"`
	AdcDatarate       uint32        `protobuf:"varint,11,opt,name=adc_datarate,json=adcDatarate,proto3" json:"adc_datarate,omitempty"`
	AdcGain           uint32        `protobuf:"varint,12,opt,name=adc_gain,json=adcGain,proto3" json:"adc_gain,omitempty"`
}

func (m *Sensors) Reset()      { *m = Sensors{} }
func (*Sensors) ProtoMessage() {}
func (*Sensors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{6}
}
func (m *Sensors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sensors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sensors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sensors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sensors.Merge(m, src)
}
func (m *Sensors) XXX_Size() int {
	return m.Size()
}
func (m *Sensors) XXX_DiscardUnknown() {
	xxx_messageInfo_Sensors.DiscardUnknown(m)
}

var xxx_messageInfo_Sensors proto.InternalMessageInfo

func (m *Sensors) GetTwin() *Temp {
	if m != nil {
		return m.Twin
	}
	return nil
}

func (m *Sensors) GetTwout() *Temp {
	if m != nil {
		return m.Twout
	}
	return nil
}

func (m *Sensors) GetTamb() *Temp {
	if m != nil {
		return m.Tamb
	}
	return nil
}

func (m *Sensors) GetWaitForConversion() bool {
	if m != nil {
		return m.WaitForConversion
	}
	return false
}

func (m *Sensors) GetTempResolution() uint32 {
	if m != nil {
		return m.TempResolution
	}
	return 0
}

func (m *Sensors) GetPrecisionFactor() uint32 {
	if m != nil {
		return m.PrecisionFactor
	}
	return 0
}

func (m *Sensors) GetPh() *AnalogSensor {
	if m != nil {
		return m.Ph
	}
	return nil
}

func (m *Sensors) GetCh() *AnalogSensor {
	if m != nil {
		return m.Ch
	}
	return nil
}

func (m *Sensors) GetWp() *AnalogSensor {
	if m != nil {
		return m.Wp
	}
	return nil
}

func (m *Sensors) GetAdcMode() uint32 {
	if m != nil {
		return m.AdcMode
	}
	return 0
}

func (m *Sensors) GetAdcDatarate() uint32 {
	if m != nil {
		return m.AdcDatarate
	}
	return 0
}

func (m *Sensors) GetAdcGain() uint32 {
	if m != nil {
		return m.AdcGain
	}
	return 0
}

type Global struct {
	LcdBacklightDuration uint32  `protobuf:"varint,1,opt,name=lcd_backlight_duration,json=lcdBacklightDuration,proto3" json:"lcd_backlight_duration,omitempty"`
	AckDuration          uint32  `protobuf:"varint,2,opt,name=ack_duration,json=ackDuration,proto3" json:"ack_duration,omitempty"`
	AckTone              float64 `protobuf:"fixed64,3,opt,name=ack_tone,json=ackTone,proto3" json:"ack_tone,omitempty"`
	SerialOut            bool    `protobuf:"varint,4,opt,name=serial_out,json=serialOut,proto3" json:"serial_out,omitempty"`
	DisplayStartup       bool    `protobuf:"varint,5,opt,name=display_startup,json=displayStartup,proto3" json:"display_startup,omitempty"`
	ForceLight           bool    `protobuf:"varint,6,opt,name=force_light,json=forceLight,proto3" json:"force_light,omitempty"`
	WdtDuration          uint32  `protobuf:"varint,7,opt,name=wdt_duration,json=wdtDuration,proto3" json:"wdt_duration,omitempty"`
}

func (m *Global) Reset()      { *m = Global{} }
func (*Global) ProtoMessage() {}
func (*Global) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{7}
}
func (m *Global) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Global) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Global.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Global) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Global.Merge(m, src)
}
func (m *Global) XXX_Size() int {
	return m.Size()
}
func (m *Global) XXX_DiscardUnknown() {
	xxx_messageInfo_Global.DiscardUnknown(m)
}

var xxx_messageInfo_Global proto.InternalMessageInfo

func (m *Global) GetLcdBacklightDuration() uint32 {
	if m != nil {
		return m.LcdBacklightDuration
	}
	return 0
}

func (m *Global) GetAckDuration() uint32 {
	if m != nil {
		return m.AckDuration
	}
	return 0
}

func (m *Global) GetAckTone() float64 {
	if m != nil {
		return m.AckTone
	}
	return 0
}

func (m *Global) GetSerialOut() bool {
	if m != nil {
		return m.SerialOut
	}
	return false
}

func (m *Global) GetDisplayStartup() bool {
	if m != nil {
		return m.DisplayStartup
	}
	return false
}

func (m *Global) GetForceLight() bool {
	if m != nil {
		return m.ForceLight
	}
	return false
}

func (m *Global) GetWdtDuration() uint32 {
	if m != nil {
		return m.WdtDuration
	}
	return 0
}

type Pump struct {
	ForceFilter    bool   `protobuf:"varint,1,opt,name=force_filter,json=forceFilter,proto3" json:"force_filter,omitempty"`
	ForcePh        bool   `protobuf:"varint,2,opt,name=force_ph,json=forcePh,proto3" json:"force_ph,omitempty"`
	ForceCh        bool   `protobuf:"varint,3,opt,name=force_ch,json=forceCh,proto3" json:"force_ch,omitempty"`
	Automatic      bool   `protobuf:"varint,4,opt,name=automatic,proto3" json:"automatic,omitempty"`
	ForceCheck     bool   `protobuf:"varint,5,opt,name=force_check,json=forceCheck,proto3" json:"force_check,omitempty"`
	ForceDuration  uint32 `protobuf:"varint,6,opt,name=force_duration,json=forceDuration,proto3" json:"force_duration,omitempty"`
	ForceStartTime uint32 `protobuf:"varint,7,opt,name=force_start_time,json=forceStartTime,proto3" json:"force_start_time,omitempty"`
}

func (m *Pump) Reset()      { *m = Pump{} }
func (*Pump) ProtoMessage() {}
func (*Pump) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{8}
}
func (m *Pump) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pump) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pump.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pump) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pump.Merge(m, src)
}
func (m *Pump) XXX_Size() int {
	return m.Size()
}
func (m *Pump) XXX_DiscardUnknown() {
	xxx_messageInfo_Pump.DiscardUnknown(m)
}

var xxx_messageInfo_Pump proto.InternalMessageInfo

func (m *Pump) GetForceFilter() bool {
	if m != nil {
		return m.ForceFilter
	}
	return false
}

func (m *Pump) GetForcePh() bool {
	if m != nil {
		return m.ForcePh
	}
	return false
}

func (m *Pump) GetForceCh() bool {
	if m != nil {
		return m.ForceCh
	}
	return false
}

func (m *Pump) GetAutomatic() bool {
	if m != nil {
		return m.Automatic
	}
	return false
}

func (m *Pump) GetForceCheck() bool {
	if m != nil {
		return m.ForceCheck
	}
	return false
}

func (m *Pump) GetForceDuration() uint32 {
	if m != nil {
		return m.ForceDuration
	}
	return 0
}

func (m *Pump) GetForceStartTime() uint32 {
	if m != nil {
		return m.ForceStartTime
	}
	return 0
}

type Ads115Alarms struct {
	NotReady     bool `protobuf:"varint,1,opt,name=not_ready,json=notReady,proto3" json:"not_ready,omitempty"`
	NotStarted   bool `protobuf:"varint,2,opt,name=not_started,json=notStarted,proto3" json:"not_started,omitempty"`
	NotConnected bool `protobuf:"varint,3,opt,name=not_connected,json=notConnected,proto3" json:"not_connected,omitempty"`
}

func (m *Ads115Alarms) Reset()      { *m = Ads115Alarms{} }
func (*Ads115Alarms) ProtoMessage() {}
func (*Ads115Alarms) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{9}
}
func (m *Ads115Alarms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ads115Alarms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ads115Alarms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ads115Alarms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ads115Alarms.Merge(m, src)
}
func (m *Ads115Alarms) XXX_Size() int {
	return m.Size()
}
func (m *Ads115Alarms) XXX_DiscardUnknown() {
	xxx_messageInfo_Ads115Alarms.DiscardUnknown(m)
}

var xxx_messageInfo_Ads115Alarms proto.InternalMessageInfo

func (m *Ads115Alarms) GetNotReady() bool {
	if m != nil {
		return m.NotReady
	}
	return false
}

func (m *Ads115Alarms) GetNotStarted() bool {
	if m != nil {
		return m.NotStarted
	}
	return false
}

func (m *Ads115Alarms) GetNotConnected() bool {
	if m != nil {
		return m.NotConnected
	}
	return false
}

type MqttAlarms struct {
	Metrics bool `protobuf:"varint,1,opt,name=metrics,proto3" json:"metrics,omitempty"`
	States  bool `protobuf:"varint,2,opt,name=states,proto3" json:"states,omitempty"`
	Alarms  bool `protobuf:"varint,3,opt,name=alarms,proto3" json:"alarms,omitempty"`
	Temps   bool `protobuf:"varint,4,opt,name=temps,proto3" json:"temps,omitempty"`
}

func (m *MqttAlarms) Reset()      { *m = MqttAlarms{} }
func (*MqttAlarms) ProtoMessage() {}
func (*MqttAlarms) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{10}
}
func (m *MqttAlarms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MqttAlarms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MqttAlarms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MqttAlarms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MqttAlarms.Merge(m, src)
}
func (m *MqttAlarms) XXX_Size() int {
	return m.Size()
}
func (m *MqttAlarms) XXX_DiscardUnknown() {
	xxx_messageInfo_MqttAlarms.DiscardUnknown(m)
}

var xxx_messageInfo_MqttAlarms proto.InternalMessageInfo

func (m *MqttAlarms) GetMetrics() bool {
	if m != nil {
		return m.Metrics
	}
	return false
}

func (m *MqttAlarms) GetStates() bool {
	if m != nil {
		return m.States
	}
	return false
}

func (m *MqttAlarms) GetAlarms() bool {
	if m != nil {
		return m.Alarms
	}
	return false
}

func (m *MqttAlarms) GetTemps() bool {
	if m != nil {
		return m.Temps
	}
	return false
}

type Alarms struct {
	Filter    bool          `protobuf:"varint,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Ph        bool          `protobuf:"varint,2,opt,name=ph,proto3" json:"ph,omitempty"`
	Ch        bool          `protobuf:"varint,3,opt,name=ch,proto3" json:"ch,omitempty"`
	Rtc       bool          `protobuf:"varint,5,opt,name=rtc,proto3" json:"rtc,omitempty"`
	WpHigh    bool          `protobuf:"varint,6,opt,name=wp_high,json=wpHigh,proto3" json:"wp_high,omitempty"`
	WpLow     bool          `protobuf:"varint,7,opt,name=wp_low,json=wpLow,proto3" json:"wp_low,omitempty"`
	WpBroken  bool          `protobuf:"varint,8,opt,name=wp_broken,json=wpBroken,proto3" json:"wp_broken,omitempty"`
	Ads1115   *Ads115Alarms `protobuf:"bytes,9,opt,name=ads1115,proto3" json:"ads1115,omitempty"`
	TwFrost   bool          `protobuf:"varint,10,opt,name=tw_frost,json=twFrost,proto3" json:"tw_frost,omitempty"`
	TwHigh    bool          `protobuf:"varint,11,opt,name=tw_high,json=twHigh,proto3" json:"tw_high,omitempty"`
	TambFrost bool          `protobuf:"varint,12,opt,name=tamb_frost,json=tambFrost,proto3" json:"tamb_frost,omitempty"`
	Mqtt      *MqttAlarms   `protobuf:"bytes,13,opt,name=mqtt,proto3" json:"mqtt,omitempty"`
}

func (m *Alarms) Reset()      { *m = Alarms{} }
func (*Alarms) ProtoMessage() {}
func (*Alarms) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{11}
}
func (m *Alarms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alarms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alarms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alarms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alarms.Merge(m, src)
}
func (m *Alarms) XXX_Size() int {
	return m.Size()
}
func (m *Alarms) XXX_DiscardUnknown() {
	xxx_messageInfo_Alarms.DiscardUnknown(m)
}

var xxx_messageInfo_Alarms proto.InternalMessageInfo

func (m *Alarms) GetFilter() bool {
	if m != nil {
		return m.Filter
	}
	return false
}

func (m *Alarms) GetPh() bool {
	if m != nil {
		return m.Ph
	}
	return false
}

func (m *Alarms) GetCh() bool {
	if m != nil {
		return m.Ch
	}
	return false
}

func (m *Alarms) GetRtc() bool {
	if m != nil {
		return m.Rtc
	}
	return false
}

func (m *Alarms) GetWpHigh() bool {
	if m != nil {
		return m.WpHigh
	}
	return false
}

func (m *Alarms) GetWpLow() bool {
	if m != nil {
		return m.WpLow
	}
	return false
}

func (m *Alarms) GetWpBroken() bool {
	if m != nil {
		return m.WpBroken
	}
	return false
}

func (m *Alarms) GetAds1115() *Ads115Alarms {
	if m != nil {
		return m.Ads1115
	}
	return nil
}

func (m *Alarms) GetTwFrost() bool {
	if m != nil {
		return m.TwFrost
	}
	return false
}

func (m *Alarms) GetTwHigh() bool {
	if m != nil {
		return m.TwHigh
	}
	return false
}

func (m *Alarms) GetTambFrost() bool {
	if m != nil {
		return m.TambFrost
	}
	return false
}

func (m *Alarms) GetMqtt() *MqttAlarms {
	if m != nil {
		return m.Mqtt
	}
	return nil
}

type Tests struct {
	Enabled  bool    `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Twater   float32 `protobuf:"fixed32,2,opt,name=twater,proto3" json:"twater,omitempty"`
	Tamb     float32 `protobuf:"fixed32,3,opt,name=tamb,proto3" json:"tamb,omitempty"`
	Ph       float32 `protobuf:"fixed32,4,opt,name=ph,proto3" json:"ph,omitempty"`
	Pressure float32 `protobuf:"fixed32,5,opt,name=pressure,proto3" json:"pressure,omitempty"`
}

func (m *Tests) Reset()      { *m = Tests{} }
func (*Tests) ProtoMessage() {}
func (*Tests) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{12}
}
func (m *Tests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tests.Merge(m, src)
}
func (m *Tests) XXX_Size() int {
	return m.Size()
}
func (m *Tests) XXX_DiscardUnknown() {
	xxx_messageInfo_Tests.DiscardUnknown(m)
}

var xxx_messageInfo_Tests proto.InternalMessageInfo

func (m *Tests) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Tests) GetTwater() float32 {
	if m != nil {
		return m.Twater
	}
	return 0
}

func (m *Tests) GetTamb() float32 {
	if m != nil {
		return m.Tamb
	}
	return 0
}

func (m *Tests) GetPh() float32 {
	if m != nil {
		return m.Ph
	}
	return 0
}

func (m *Tests) GetPressure() float32 {
	if m != nil {
		return m.Pressure
	}
	return 0
}

type Metrics struct {
	Tamb            float32 `protobuf:"fixed32,1,opt,name=tamb,proto3" json:"tamb,omitempty"`
	Twater          float32 `protobuf:"fixed32,2,opt,name=twater,proto3" json:"twater,omitempty"`
	SavedTwater     float32 `protobuf:"fixed32,3,opt,name=saved_twater,json=savedTwater,proto3" json:"saved_twater,omitempty"`
	Ph              float32 `protobuf:"fixed32,4,opt,name=ph,proto3" json:"ph,omitempty"`
	Ch              float32 `protobuf:"fixed32,5,opt,name=ch,proto3" json:"ch,omitempty"`
	Wp              float32 `protobuf:"fixed32,6,opt,name=wp,proto3" json:"wp,omitempty"`
	WpVolt          float32 `protobuf:"fixed32,7,opt,name=wp_volt,json=wpVolt,proto3" json:"wp_volt,omitempty"`
	Over_15Duration uint32  `protobuf:"varint,8,opt,name=over_15_duration,json=over15Duration,proto3" json:"over_15_duration,omitempty"`
	Hour            uint32  `protobuf:"varint,9,opt,name=hour,proto3" json:"hour,omitempty"`
	Time            uint32  `protobuf:"varint,10,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *Metrics) Reset()      { *m = Metrics{} }
func (*Metrics) ProtoMessage() {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{13}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetTamb() float32 {
	if m != nil {
		return m.Tamb
	}
	return 0
}

func (m *Metrics) GetTwater() float32 {
	if m != nil {
		return m.Twater
	}
	return 0
}

func (m *Metrics) GetSavedTwater() float32 {
	if m != nil {
		return m.SavedTwater
	}
	return 0
}

func (m *Metrics) GetPh() float32 {
	if m != nil {
		return m.Ph
	}
	return 0
}

func (m *Metrics) GetCh() float32 {
	if m != nil {
		return m.Ch
	}
	return 0
}

func (m *Metrics) GetWp() float32 {
	if m != nil {
		return m.Wp
	}
	return 0
}

func (m *Metrics) GetWpVolt() float32 {
	if m != nil {
		return m.WpVolt
	}
	return 0
}

func (m *Metrics) GetOver_15Duration() uint32 {
	if m != nil {
		return m.Over_15Duration
	}
	return 0
}

func (m *Metrics) GetHour() uint32 {
	if m != nil {
		return m.Hour
	}
	return 0
}

func (m *Metrics) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

type States struct {
	Startup       bool `protobuf:"varint,1,opt,name=startup,proto3" json:"startup,omitempty"`
	FilterOn      bool `protobuf:"varint,2,opt,name=filter_on,json=filterOn,proto3" json:"filter_on,omitempty"`
	PhOn          bool `protobuf:"varint,3,opt,name=ph_on,json=phOn,proto3" json:"ph_on,omitempty"`
	ChOn          bool `protobuf:"varint,4,opt,name=ch_on,json=chOn,proto3" json:"ch_on,omitempty"`
	Automatic     bool `protobuf:"varint,5,opt,name=automatic,proto3" json:"automatic,omitempty"`
	NetActive     bool `protobuf:"varint,6,opt,name=net_active,json=netActive,proto3" json:"net_active,omitempty"`
	Ntp           bool `protobuf:"varint,7,opt,name=ntp,proto3" json:"ntp,omitempty"`
	Rtc           bool `protobuf:"varint,8,opt,name=rtc,proto3" json:"rtc,omitempty"`
	LightOn       bool `protobuf:"varint,9,opt,name=light_on,json=lightOn,proto3" json:"light_on,omitempty"`
	MqttConnected bool `protobuf:"varint,10,opt,name=mqtt_connected,json=mqttConnected,proto3" json:"mqtt_connected,omitempty"`
}

func (m *States) Reset()      { *m = States{} }
func (*States) ProtoMessage() {}
func (*States) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{14}
}
func (m *States) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *States) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_States.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *States) XXX_Merge(src proto.Message) {
	xxx_messageInfo_States.Merge(m, src)
}
func (m *States) XXX_Size() int {
	return m.Size()
}
func (m *States) XXX_DiscardUnknown() {
	xxx_messageInfo_States.DiscardUnknown(m)
}

var xxx_messageInfo_States proto.InternalMessageInfo

func (m *States) GetStartup() bool {
	if m != nil {
		return m.Startup
	}
	return false
}

func (m *States) GetFilterOn() bool {
	if m != nil {
		return m.FilterOn
	}
	return false
}

func (m *States) GetPhOn() bool {
	if m != nil {
		return m.PhOn
	}
	return false
}

func (m *States) GetChOn() bool {
	if m != nil {
		return m.ChOn
	}
	return false
}

func (m *States) GetAutomatic() bool {
	if m != nil {
		return m.Automatic
	}
	return false
}

func (m *States) GetNetActive() bool {
	if m != nil {
		return m.NetActive
	}
	return false
}

func (m *States) GetNtp() bool {
	if m != nil {
		return m.Ntp
	}
	return false
}

func (m *States) GetRtc() bool {
	if m != nil {
		return m.Rtc
	}
	return false
}

func (m *States) GetLightOn() bool {
	if m != nil {
		return m.LightOn
	}
	return false
}

func (m *States) GetMqttConnected() bool {
	if m != nil {
		return m.MqttConnected
	}
	return false
}

type Versions struct {
	Domopool   string `protobuf:"bytes,1,opt,name=domopool,proto3" json:"domopool,omitempty"`
	Platformio uint32 `protobuf:"varint,2,opt,name=platformio,proto3" json:"platformio,omitempty"`
	EspIdf     string `protobuf:"bytes,3,opt,name=esp_idf,json=espIdf,proto3" json:"esp_idf,omitempty"`
	Xtensa     string `protobuf:"bytes,4,opt,name=xtensa,proto3" json:"xtensa,omitempty"`
	TftEspi    string `protobuf:"bytes,6,opt,name=tft_espi,json=tftEspi,proto3" json:"tft_espi,omitempty"`
	Dallastemp string `protobuf:"bytes,7,opt,name=dallastemp,proto3" json:"dallastemp,omitempty"`
	Ads1115    string `protobuf:"bytes,8,opt,name=ads1115,proto3" json:"ads1115,omitempty"`
	Nanopb     string `protobuf:"bytes,9,opt,name=nanopb,proto3" json:"nanopb,omitempty"`
	Mqtt       string `protobuf:"bytes,10,opt,name=mqtt,proto3" json:"mqtt,omitempty"`
}

func (m *Versions) Reset()      { *m = Versions{} }
func (*Versions) ProtoMessage() {}
func (*Versions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{15}
}
func (m *Versions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Versions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Versions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Versions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Versions.Merge(m, src)
}
func (m *Versions) XXX_Size() int {
	return m.Size()
}
func (m *Versions) XXX_DiscardUnknown() {
	xxx_messageInfo_Versions.DiscardUnknown(m)
}

var xxx_messageInfo_Versions proto.InternalMessageInfo

func (m *Versions) GetDomopool() string {
	if m != nil {
		return m.Domopool
	}
	return ""
}

func (m *Versions) GetPlatformio() uint32 {
	if m != nil {
		return m.Platformio
	}
	return 0
}

func (m *Versions) GetEspIdf() string {
	if m != nil {
		return m.EspIdf
	}
	return ""
}

func (m *Versions) GetXtensa() string {
	if m != nil {
		return m.Xtensa
	}
	return ""
}

func (m *Versions) GetTftEspi() string {
	if m != nil {
		return m.TftEspi
	}
	return ""
}

func (m *Versions) GetDallastemp() string {
	if m != nil {
		return m.Dallastemp
	}
	return ""
}

func (m *Versions) GetAds1115() string {
	if m != nil {
		return m.Ads1115
	}
	return ""
}

func (m *Versions) GetNanopb() string {
	if m != nil {
		return m.Nanopb
	}
	return ""
}

func (m *Versions) GetMqtt() string {
	if m != nil {
		return m.Mqtt
	}
	return ""
}

type Infos struct {
	Compile   string    `protobuf:"bytes,1,opt,name=compile,proto3" json:"compile,omitempty"`
	BoardName string    `protobuf:"bytes,2,opt,name=board_name,json=boardName,proto3" json:"board_name,omitempty"`
	Versions  *Versions `protobuf:"bytes,3,opt,name=versions,proto3" json:"versions,omitempty"`
}

func (m *Infos) Reset()      { *m = Infos{} }
func (*Infos) ProtoMessage() {}
func (*Infos) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{16}
}
func (m *Infos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Infos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Infos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Infos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Infos.Merge(m, src)
}
func (m *Infos) XXX_Size() int {
	return m.Size()
}
func (m *Infos) XXX_DiscardUnknown() {
	xxx_messageInfo_Infos.DiscardUnknown(m)
}

var xxx_messageInfo_Infos proto.InternalMessageInfo

func (m *Infos) GetCompile() string {
	if m != nil {
		return m.Compile
	}
	return ""
}

func (m *Infos) GetBoardName() string {
	if m != nil {
		return m.BoardName
	}
	return ""
}

func (m *Infos) GetVersions() *Versions {
	if m != nil {
		return m.Versions
	}
	return nil
}

type Config struct {
	Network *Network `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Sensors *Sensors `protobuf:"bytes,2,opt,name=sensors,proto3" json:"sensors,omitempty"`
	Global  *Global  `protobuf:"bytes,3,opt,name=global,proto3" json:"global,omitempty"`
	Pump    *Pump    `protobuf:"bytes,5,opt,name=pump,proto3" json:"pump,omitempty"`
	Metrics *Metrics `protobuf:"bytes,6,opt,name=metrics,proto3" json:"metrics,omitempty"`
	States  *States  `protobuf:"bytes,7,opt,name=states,proto3" json:"states,omitempty"`
	Alarms  *Alarms  `protobuf:"bytes,8,opt,name=alarms,proto3" json:"alarms,omitempty"`
	Tests   *Tests   `protobuf:"bytes,9,opt,name=tests,proto3" json:"tests,omitempty"`
	Infos   *Infos   `protobuf:"bytes,10,opt,name=infos,proto3" json:"infos,omitempty"`
	Limits  *Limits  `protobuf:"bytes,11,opt,name=limits,proto3" json:"limits,omitempty"`
}

func (m *Config) Reset()      { *m = Config{} }
func (*Config) ProtoMessage() {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{17}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Config) GetSensors() *Sensors {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *Config) GetGlobal() *Global {
	if m != nil {
		return m.Global
	}
	return nil
}

func (m *Config) GetPump() *Pump {
	if m != nil {
		return m.Pump
	}
	return nil
}

func (m *Config) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Config) GetStates() *States {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Config) GetAlarms() *Alarms {
	if m != nil {
		return m.Alarms
	}
	return nil
}

func (m *Config) GetTests() *Tests {
	if m != nil {
		return m.Tests
	}
	return nil
}

func (m *Config) GetInfos() *Infos {
	if m != nil {
		return m.Infos
	}
	return nil
}

func (m *Config) GetLimits() *Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

type Relay struct {
	State     RelayStates `protobuf:"varint,1,opt,name=state,proto3,enum=domopool.RelayStates" json:"state,omitempty"`
	Relay     RelayNames  `protobuf:"varint,2,opt,name=relay,proto3,enum=domopool.RelayNames" json:"relay,omitempty"`
	Duration  uint32      `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	StartTime uint32      `protobuf:"varint,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
}

func (m *Relay) Reset()      { *m = Relay{} }
func (*Relay) ProtoMessage() {}
func (*Relay) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{18}
}
func (m *Relay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relay.Merge(m, src)
}
func (m *Relay) XXX_Size() int {
	return m.Size()
}
func (m *Relay) XXX_DiscardUnknown() {
	xxx_messageInfo_Relay.DiscardUnknown(m)
}

var xxx_messageInfo_Relay proto.InternalMessageInfo

func (m *Relay) GetState() RelayStates {
	if m != nil {
		return m.State
	}
	return auto
}

func (m *Relay) GetRelay() RelayNames {
	if m != nil {
		return m.Relay
	}
	return filter
}

func (m *Relay) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Relay) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func init() {
	proto.RegisterEnum("domopool.RelayStates", RelayStates_name, RelayStates_value)
	proto.RegisterEnum("domopool.RelayNames", RelayNames_name, RelayNames_value)
	proto.RegisterType((*NTP)(nil), "domopool.NTP")
	proto.RegisterType((*Mqtt)(nil), "domopool.Mqtt")
	proto.RegisterType((*Network)(nil), "domopool.Network")
	proto.RegisterType((*Temp)(nil), "domopool.Temp")
	proto.RegisterType((*Limits)(nil), "domopool.Limits")
	proto.RegisterType((*AnalogSensor)(nil), "domopool.AnalogSensor")
	proto.RegisterType((*Sensors)(nil), "domopool.Sensors")
	proto.RegisterType((*Global)(nil), "domopool.Global")
	proto.RegisterType((*Pump)(nil), "domopool.Pump")
	proto.RegisterType((*Ads115Alarms)(nil), "domopool.Ads115Alarms")
	proto.RegisterType((*MqttAlarms)(nil), "domopool.MqttAlarms")
	proto.RegisterType((*Alarms)(nil), "domopool.Alarms")
	proto.RegisterType((*Tests)(nil), "domopool.Tests")
	proto.RegisterType((*Metrics)(nil), "domopool.Metrics")
	proto.RegisterType((*States)(nil), "domopool.States")
	proto.RegisterType((*Versions)(nil), "domopool.Versions")
	proto.RegisterType((*Infos)(nil), "domopool.Infos")
	proto.RegisterType((*Config)(nil), "domopool.Config")
	proto.RegisterType((*Relay)(nil), "domopool.Relay")
}

func init() { proto.RegisterFile("domopool.proto", fileDescriptor_6d32c57b52397a6e) }

var fileDescriptor_6d32c57b52397a6e = []byte{
	// 2074 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x58, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0x9f, 0xf6, 0xf8, 0xa3, 0xfd, 0x66, 0xec, 0x38, 0xb5, 0xd9, 0xe0, 0x0d, 0xc4, 0x9b, 0x98,
	0x5d, 0x18, 0x12, 0xf2, 0x31, 0xd9, 0x8d, 0x84, 0xc4, 0x29, 0x99, 0x90, 0xdd, 0x95, 0xf2, 0x31,
	0xaa, 0x8c, 0x82, 0xc4, 0xa5, 0x55, 0xee, 0x2e, 0xbb, 0x5b, 0xd3, 0xdd, 0x55, 0xe9, 0x2e, 0x4f,
	0xcf, 0x70, 0xe2, 0xc8, 0x81, 0x03, 0xff, 0x00, 0x77, 0xf8, 0x4f, 0x38, 0x20, 0x94, 0x1b, 0x7b,
	0x24, 0x93, 0x0b, 0x37, 0x56, 0xe2, 0x82, 0x10, 0x07, 0xf4, 0x5e, 0x55, 0xb7, 0x3d, 0x43, 0x92,
	0x93, 0xeb, 0xfd, 0xde, 0xab, 0x8f, 0xf7, 0xfd, 0xda, 0x30, 0x8c, 0x54, 0xa6, 0xb4, 0x52, 0xe9,
	0x6d, 0x5d, 0x28, 0xa3, 0x98, 0x5f, 0xd3, 0x57, 0x6e, 0x2d, 0x12, 0x13, 0x2f, 0x67, 0xb7, 0x43,
	0x95, 0xdd, 0x59, 0xa8, 0x85, 0xba, 0x43, 0x02, 0xb3, 0xe5, 0x9c, 0x28, 0x22, 0x68, 0x65, 0x37,
	0x4e, 0x5f, 0xc2, 0xe6, 0xb3, 0x83, 0x7d, 0xf6, 0x7d, 0xe8, 0x47, 0xe2, 0x24, 0x48, 0x93, 0x45,
	0x6c, 0xc6, 0xde, 0x35, 0x6f, 0x67, 0xc0, 0xfd, 0x48, 0x9c, 0x3c, 0x41, 0x9a, 0x5d, 0x86, 0x6e,
	0x29, 0x8b, 0x23, 0x59, 0x8c, 0x5b, 0xd7, 0xbc, 0x9d, 0x3e, 0x77, 0x14, 0xbb, 0x02, 0xbe, 0x49,
	0x32, 0xf9, 0x6b, 0x95, 0xcb, 0xf1, 0xa6, 0xdd, 0x53, 0xd3, 0xd3, 0x9f, 0x41, 0xfb, 0xe9, 0x2b,
	0x63, 0xd8, 0x18, 0x7a, 0x32, 0x17, 0xb3, 0x54, 0x46, 0x74, 0xac, 0xcf, 0x6b, 0xf2, 0x7d, 0xa7,
	0x4e, 0xff, 0xe6, 0x41, 0xef, 0x99, 0x34, 0x95, 0x2a, 0x0e, 0x19, 0x83, 0x76, 0x14, 0x87, 0xda,
	0x6d, 0xa5, 0x35, 0x1b, 0x42, 0x2b, 0xd1, 0x6e, 0x4f, 0x2b, 0xd1, 0x78, 0x43, 0x2e, 0x4d, 0x26,
	0xca, 0x43, 0x7a, 0x44, 0x9f, 0xd7, 0x24, 0x72, 0x16, 0xc2, 0xc8, 0x4a, 0x9c, 0x8c, 0xdb, 0x96,
	0xe3, 0x48, 0x36, 0x82, 0xcd, 0x28, 0x2f, 0xc7, 0x1d, 0x42, 0x71, 0xc9, 0xae, 0x02, 0x88, 0x34,
	0x55, 0x55, 0xa0, 0x55, 0x69, 0xc6, 0x5d, 0xba, 0xaf, 0x4f, 0xc8, 0xbe, 0x2a, 0x0d, 0x9b, 0x42,
	0x3b, 0x7b, 0x65, 0xcc, 0xb8, 0x77, 0xcd, 0xdb, 0xd9, 0xba, 0x37, 0xbc, 0xdd, 0x98, 0x1f, 0x95,
	0xe4, 0xc4, 0x63, 0x9f, 0xc2, 0x66, 0x6e, 0xf4, 0xd8, 0x27, 0x91, 0xc1, 0x4a, 0xe4, 0xd9, 0xc1,
	0x3e, 0x47, 0xce, 0xf4, 0x6b, 0x68, 0x1f, 0xc8, 0x4c, 0x7f, 0xc0, 0x26, 0x0c, 0xda, 0x49, 0x9e,
	0x18, 0xd2, 0xce, 0xe7, 0xb4, 0x46, 0x4c, 0x44, 0x51, 0x31, 0xf6, 0xaf, 0x6d, 0xee, 0x0c, 0x38,
	0xad, 0xa7, 0xff, 0x69, 0x41, 0xf7, 0x49, 0x92, 0x25, 0xa6, 0x64, 0x1f, 0x43, 0xb7, 0xd2, 0x41,
	0x96, 0xe4, 0x74, 0x56, 0x8b, 0x77, 0x2a, 0xfd, 0x34, 0xc9, 0x6b, 0x58, 0x1c, 0xd3, 0x59, 0x16,
	0x16, 0xc7, 0x08, 0xeb, 0x98, 0xa4, 0x37, 0x2d, 0xac, 0x63, 0x27, 0x8d, 0xb0, 0x38, 0x26, 0x43,
	0x59, 0xd8, 0x4a, 0x87, 0x56, 0xba, 0x63, 0xe1, 0xb0, 0x96, 0x0e, 0xad, 0x74, 0xb7, 0x81, 0xc5,
	0x31, 0xfb, 0x0c, 0x86, 0x95, 0x48, 0x4c, 0x30, 0x93, 0x73, 0x55, 0xc8, 0x20, 0x8c, 0xc9, 0x5a,
	0x03, 0xbe, 0x8d, 0xe8, 0x43, 0x02, 0xf7, 0x62, 0x76, 0x03, 0x2e, 0x86, 0x71, 0x60, 0x64, 0xa6,
	0x03, 0x13, 0x17, 0xb2, 0x8c, 0x55, 0x1a, 0x91, 0xcd, 0x5a, 0xfc, 0x42, 0x18, 0xa3, 0x7d, 0x0e,
	0x6a, 0x98, 0xdd, 0x04, 0x56, 0xcb, 0xd2, 0xc9, 0x85, 0x2c, 0xa5, 0x19, 0xf7, 0xd7, 0x85, 0x7f,
	0x29, 0x12, 0xc3, 0x11, 0x66, 0x13, 0xd8, 0xaa, 0x74, 0x70, 0x37, 0x88, 0x64, 0x91, 0x1c, 0xc9,
	0x31, 0x90, 0x54, 0xbf, 0xd2, 0x77, 0x1f, 0x11, 0x80, 0xaf, 0x36, 0x15, 0x29, 0xb3, 0x65, 0x5f,
	0x6d, 0x2a, 0xa7, 0x0c, 0xc2, 0xe2, 0x78, 0xbc, 0xdd, 0xc0, 0xe2, 0x98, 0x7d, 0x02, 0xbe, 0x11,
	0xd9, 0x8c, 0xe4, 0x07, 0xc4, 0xe8, 0x21, 0xfd, 0x34, 0xc9, 0xa7, 0xff, 0xf5, 0x60, 0xfb, 0x41,
	0x2e, 0x52, 0xb5, 0x78, 0x21, 0xf3, 0x52, 0x15, 0x1f, 0xf0, 0xe7, 0xf7, 0xa0, 0x27, 0xa2, 0x30,
	0xd0, 0xce, 0xde, 0x03, 0xde, 0x15, 0x51, 0xb8, 0x9f, 0xe4, 0xec, 0x07, 0xd0, 0x5f, 0x69, 0x6f,
	0x3d, 0xb4, 0x02, 0xd8, 0x2d, 0x60, 0x0d, 0x11, 0x88, 0x30, 0x5c, 0x16, 0x22, 0xb4, 0x31, 0x3c,
	0xe0, 0x17, 0x1b, 0xce, 0x03, 0xc7, 0xc0, 0x08, 0x39, 0x5a, 0x39, 0x89, 0xd6, 0x16, 0x6b, 0x3c,
	0x44, 0x6b, 0xf6, 0x13, 0x18, 0xe9, 0x42, 0x86, 0x49, 0x99, 0xa8, 0x3c, 0x98, 0x8b, 0xd0, 0xa8,
	0xc2, 0xb9, 0xe8, 0x42, 0x83, 0x3f, 0x26, 0x18, 0xd5, 0x17, 0x4b, 0xa3, 0x82, 0x50, 0xa4, 0xe4,
	0x1c, 0x9f, 0xf7, 0x90, 0xde, 0x13, 0xe9, 0xf4, 0x2f, 0x9b, 0xd0, 0xb3, 0x8a, 0x97, 0x98, 0x16,
	0xa6, 0x72, 0xa1, 0x77, 0x26, 0x2d, 0xd0, 0x35, 0x9c, 0x78, 0xec, 0x33, 0xe8, 0x98, 0x4a, 0x2d,
	0x6d, 0x50, 0xff, 0xbf, 0x90, 0x65, 0xd2, 0x49, 0x22, 0x9b, 0x91, 0x99, 0xde, 0x75, 0x92, 0xc8,
	0x66, 0xec, 0x36, 0x7c, 0x44, 0x61, 0x30, 0x57, 0x45, 0x10, 0xaa, 0xfc, 0x48, 0x16, 0xf8, 0x62,
	0xb2, 0x8b, 0xcf, 0x2f, 0x22, 0xeb, 0xb1, 0x2a, 0xf6, 0x1a, 0x06, 0xfb, 0x31, 0x5c, 0xa0, 0xd8,
	0x29, 0x64, 0xa9, 0xd2, 0xa5, 0x41, 0xd9, 0x0e, 0xa9, 0x3b, 0x44, 0x98, 0x37, 0xe8, 0x3b, 0x0d,
	0xd3, 0x7d, 0xb7, 0x61, 0x7e, 0x04, 0x2d, 0x1d, 0xbb, 0x32, 0x70, 0x79, 0xf5, 0xca, 0xf5, 0x78,
	0xe0, 0x2d, 0x1d, 0xa3, 0x5c, 0x18, 0xbb, 0x5a, 0xf0, 0x5e, 0xb9, 0x90, 0xe4, 0x2a, 0x4d, 0x21,
	0xfd, 0x01, 0xb9, 0x4a, 0x93, 0x43, 0xa2, 0x30, 0xc8, 0x54, 0x64, 0x43, 0x7b, 0xc0, 0x31, 0xb2,
	0x9e, 0xaa, 0x48, 0xb2, 0xeb, 0xb0, 0x8d, 0xac, 0x48, 0x18, 0x51, 0x08, 0x23, 0x29, 0xbc, 0x07,
	0x7c, 0x4b, 0x44, 0xe1, 0x23, 0x07, 0xd5, 0xbb, 0x17, 0x22, 0xc9, 0x29, 0xcc, 0xed, 0xee, 0xaf,
	0x44, 0x92, 0x4f, 0x7f, 0xdb, 0x82, 0xee, 0x57, 0xa9, 0x9a, 0x89, 0x94, 0x7d, 0x09, 0x97, 0xd3,
	0x30, 0x0a, 0x66, 0x22, 0x3c, 0xa4, 0x46, 0x10, 0x44, 0xcb, 0x42, 0x90, 0xd9, 0x6c, 0x47, 0xb8,
	0x94, 0x86, 0xd1, 0xc3, 0x9a, 0xf9, 0xc8, 0xf1, 0xe8, 0xfa, 0xf0, 0x70, 0x25, 0xdb, 0x72, 0xd7,
	0x87, 0x87, 0x8d, 0x08, 0x5e, 0x1f, 0x1e, 0x06, 0xa6, 0x6e, 0x14, 0x1e, 0xef, 0x89, 0xf0, 0xf0,
	0x40, 0xe5, 0x12, 0xeb, 0x6e, 0x29, 0x8b, 0x44, 0xa4, 0x01, 0x86, 0x88, 0x75, 0x65, 0xdf, 0x22,
	0xcf, 0x97, 0x06, 0x5d, 0x18, 0x25, 0xa5, 0x4e, 0xc5, 0x49, 0x50, 0x1a, 0x51, 0x98, 0xa5, 0x26,
	0x17, 0xfa, 0x7c, 0xe8, 0xe0, 0x17, 0x16, 0x65, 0x9f, 0xc2, 0xd6, 0x5c, 0x15, 0xa1, 0x74, 0x2d,
	0xcc, 0x16, 0x70, 0x20, 0xc8, 0x36, 0xb1, 0xeb, 0xb0, 0x5d, 0x45, 0x6b, 0x2a, 0xd9, 0xc0, 0xdf,
	0xaa, 0xa2, 0x46, 0x93, 0xe9, 0x3f, 0x3d, 0x68, 0xef, 0x2f, 0x33, 0x8d, 0xb2, 0xf6, 0xb0, 0x79,
	0x92, 0x1a, 0x59, 0xb8, 0xac, 0xb6, 0x17, 0x3c, 0x26, 0x08, 0x55, 0xb2, 0x22, 0x3a, 0x76, 0xd5,
	0xba, 0x47, 0xf4, 0x7e, 0xbc, 0x62, 0x85, 0x31, 0x69, 0x5b, 0xb3, 0xf6, 0x62, 0x4c, 0x7b, 0x4c,
	0xa3, 0x4c, 0x98, 0x24, 0xac, 0x95, 0x6d, 0x80, 0x95, 0x0e, 0x61, 0x2c, 0xc3, 0x43, 0xa7, 0x28,
	0xb8, 0xbd, 0x32, 0x3c, 0x64, 0x9f, 0xc3, 0xd0, 0x0a, 0x34, 0x5a, 0xd8, 0x28, 0x1d, 0x10, 0xda,
	0x98, 0x7b, 0x07, 0x46, 0x56, 0x8c, 0x4c, 0x16, 0x60, 0x4f, 0x76, 0xea, 0xda, 0xed, 0x64, 0xb3,
	0x83, 0x24, 0x93, 0xd3, 0x57, 0xb0, 0xfd, 0x20, 0x2a, 0x77, 0x77, 0xef, 0x3f, 0x48, 0x45, 0x91,
	0x95, 0x38, 0x06, 0xe4, 0x0a, 0xeb, 0xac, 0x88, 0x4e, 0x9c, 0xd6, 0x7e, 0xae, 0x0c, 0x47, 0x1a,
	0x9f, 0x87, 0x4c, 0x3a, 0x54, 0x46, 0x4e, 0x6b, 0xc8, 0x95, 0x79, 0x61, 0x11, 0xf6, 0x43, 0x18,
	0xa0, 0x40, 0xa8, 0xf2, 0x5c, 0x86, 0x28, 0x62, 0xb5, 0xdf, 0xce, 0x95, 0xd9, 0xab, 0xb1, 0x69,
	0x0a, 0x80, 0x3d, 0xd3, 0x5d, 0x38, 0x86, 0x5e, 0x26, 0x4d, 0x91, 0x84, 0x65, 0x5d, 0x3a, 0x1d,
	0x49, 0xe3, 0x81, 0x11, 0x46, 0x96, 0xee, 0x22, 0x47, 0x21, 0x2e, 0x68, 0xaf, 0x3b, 0xdd, 0x51,
	0xec, 0x12, 0x74, 0x30, 0xab, 0x4b, 0x67, 0x56, 0x4b, 0x4c, 0xff, 0xda, 0x82, 0xae, 0xbb, 0xea,
	0x32, 0x74, 0xcf, 0xb8, 0xd3, 0x51, 0x38, 0x4f, 0x34, 0x3e, 0xc4, 0xcc, 0x1d, 0x52, 0xe6, 0xda,
	0xc3, 0x31, 0x43, 0x47, 0xb0, 0x59, 0x98, 0xd0, 0x79, 0x03, 0x97, 0x58, 0xd5, 0x2b, 0x1d, 0xc4,
	0xc9, 0x22, 0x76, 0x71, 0xd6, 0xad, 0xf4, 0xd7, 0xc9, 0x22, 0x76, 0x4d, 0x37, 0x55, 0x15, 0x99,
	0xdb, 0xc7, 0xa6, 0xfb, 0x44, 0x55, 0x68, 0xd5, 0x4a, 0x07, 0xb3, 0x42, 0x1d, 0xca, 0xdc, 0x55,
	0x53, 0xbf, 0xd2, 0x0f, 0x89, 0x66, 0x77, 0xb1, 0x45, 0x94, 0xbb, 0xbb, 0xbb, 0xf7, 0xdf, 0x51,
	0x05, 0xd6, 0x7c, 0xc3, 0x6b, 0x31, 0x6a, 0x4d, 0x55, 0x30, 0x2f, 0x70, 0x50, 0x01, 0x6b, 0x34,
	0x53, 0x3d, 0x46, 0x12, 0x5f, 0x66, 0x2a, 0xfb, 0xb2, 0x2d, 0xfb, 0x32, 0x53, 0xd1, 0xcb, 0xae,
	0x02, 0x50, 0x3b, 0xb3, 0xbb, 0xb6, 0x6d, 0xe4, 0x21, 0x62, 0xf7, 0xed, 0xb8, 0xf1, 0x66, 0x40,
	0x2f, 0xb8, 0x74, 0x76, 0xbc, 0x71, 0xf7, 0x93, 0xc4, 0xf4, 0x04, 0x3a, 0x07, 0xb2, 0x34, 0xe5,
	0x87, 0x07, 0x3b, 0x53, 0x09, 0xe3, 0x06, 0xbb, 0x16, 0x77, 0x14, 0xb6, 0xa4, 0xa6, 0xc4, 0xb7,
	0x5c, 0x49, 0xb7, 0xc6, 0xb7, 0x43, 0x07, 0x1a, 0xff, 0x0a, 0xf8, 0xba, 0x90, 0x65, 0xb9, 0x2c,
	0xa4, 0x6b, 0x67, 0x0d, 0x3d, 0xfd, 0x97, 0x07, 0xbd, 0xa7, 0x2e, 0x3a, 0xea, 0xb3, 0xbc, 0xb5,
	0xb3, 0xde, 0x77, 0xef, 0x75, 0xd8, 0x2e, 0xc5, 0x91, 0x8c, 0x02, 0xc7, 0xb5, 0xf7, 0x6f, 0x11,
	0x76, 0x60, 0x45, 0xce, 0x3f, 0xc3, 0xc6, 0x80, 0x7d, 0x00, 0xc6, 0xc0, 0x90, 0xaa, 0xb4, 0xed,
	0xa5, 0x58, 0x8d, 0x6d, 0x04, 0x1c, 0xa9, 0xd4, 0x4e, 0x84, 0x2d, 0x8c, 0x80, 0x97, 0x2a, 0x45,
	0x43, 0x8e, 0xd4, 0x91, 0x2c, 0x82, 0xdd, 0xfb, 0xab, 0x1c, 0xf5, 0x6d, 0xea, 0x21, 0xbe, 0x7b,
	0xbf, 0x49, 0x52, 0x06, 0xed, 0x58, 0x2d, 0x0b, 0x72, 0xfa, 0x80, 0xd3, 0x9a, 0xb4, 0xc2, 0x64,
	0xb5, 0x05, 0x9e, 0xd6, 0xd3, 0xdf, 0xb5, 0xa0, 0xfb, 0xc2, 0x86, 0xfe, 0x18, 0x7a, 0x75, 0x11,
	0x74, 0x26, 0x77, 0x24, 0x46, 0x98, 0x8d, 0xe6, 0xc0, 0x15, 0x60, 0x9f, 0xfb, 0x16, 0x78, 0x9e,
	0xb3, 0x8f, 0xa0, 0xa3, 0x63, 0x64, 0xd8, 0x98, 0x6e, 0xeb, 0xd8, 0x82, 0x21, 0x81, 0x36, 0x5d,
	0xda, 0x21, 0x82, 0x67, 0xca, 0x53, 0xe7, 0x7c, 0x79, 0xba, 0x0a, 0x90, 0x4b, 0x13, 0x88, 0xd0,
	0xe0, 0x7c, 0xe5, 0x46, 0xe4, 0x5c, 0x9a, 0x07, 0x04, 0x60, 0x9e, 0xe0, 0xf8, 0x6b, 0x23, 0x1f,
	0x97, 0x75, 0xe6, 0xf8, 0xab, 0xcc, 0xf9, 0x04, 0x7c, 0xdb, 0x59, 0x54, 0x4e, 0x8a, 0xfb, 0xbc,
	0x47, 0xf4, 0xf3, 0x1c, 0x6b, 0x1b, 0x06, 0xd8, 0x5a, 0xf5, 0xb0, 0xb1, 0x3d, 0x40, 0x74, 0x55,
	0x3e, 0xfe, 0xed, 0x81, 0xff, 0xd2, 0xf6, 0xf7, 0x12, 0xa3, 0xa5, 0x8e, 0x54, 0xb2, 0x48, 0x9f,
	0x37, 0x34, 0x9b, 0x00, 0xe8, 0x54, 0x98, 0xb9, 0x2a, 0xb2, 0x44, 0xb9, 0xa6, 0xb4, 0x86, 0xa0,
	0x0b, 0x65, 0xa9, 0x83, 0x24, 0x9a, 0xbb, 0xcf, 0x86, 0xae, 0x2c, 0xf5, 0x37, 0xd1, 0x1c, 0xc3,
	0xe8, 0xd8, 0xc8, 0xbc, 0x14, 0xee, 0xa3, 0xc1, 0x51, 0x94, 0x76, 0x73, 0x13, 0xc8, 0x52, 0x27,
	0xa4, 0x7c, 0x9f, 0xf7, 0xcc, 0xdc, 0xfc, 0xa2, 0xd4, 0x09, 0xde, 0x15, 0x89, 0x34, 0x15, 0x25,
	0x16, 0x1d, 0xb2, 0x40, 0x9f, 0xaf, 0x21, 0xe8, 0xb8, 0x3a, 0xc7, 0x7d, 0xbb, 0xb3, 0xce, 0xe5,
	0xcb, 0xd0, 0xcd, 0x45, 0xae, 0xf4, 0x8c, 0xcc, 0xd1, 0xe7, 0x8e, 0xc2, 0x48, 0xa0, 0x84, 0x04,
	0x42, 0x6d, 0xea, 0x69, 0xe8, 0x7c, 0x93, 0xcf, 0x15, 0xc5, 0x41, 0xa8, 0x32, 0x9d, 0xa4, 0xd2,
	0x69, 0x5d, 0x93, 0xe8, 0xa2, 0x99, 0x12, 0x45, 0x14, 0xe4, 0x22, 0x93, 0xee, 0x1b, 0xa9, 0x4f,
	0xc8, 0x33, 0x91, 0x49, 0x76, 0x1b, 0x7c, 0x37, 0x1b, 0x95, 0x6e, 0xd0, 0x62, 0xab, 0x54, 0xaf,
	0xad, 0xca, 0x1b, 0x99, 0xe9, 0x9f, 0x36, 0xa1, 0xbb, 0xa7, 0xf2, 0x79, 0xb2, 0x60, 0x37, 0xe9,
	0x2b, 0x0b, 0x3f, 0xca, 0xdc, 0xb0, 0x77, 0x71, 0xed, 0x03, 0xc7, 0x32, 0x78, 0x2d, 0x81, 0xc2,
	0xa5, 0x9d, 0x10, 0xdd, 0xd0, 0xb7, 0x26, 0xec, 0x46, 0x47, 0x5e, 0x4b, 0xb0, 0x1d, 0xe8, 0x2e,
	0x68, 0xfe, 0x70, 0x4f, 0x1a, 0xad, 0x64, 0xed, 0x5c, 0xc2, 0x1d, 0x1f, 0x67, 0x44, 0xbd, 0xcc,
	0xec, 0x04, 0x70, 0x66, 0x46, 0xc4, 0xa6, 0xcd, 0x89, 0x87, 0x57, 0xd7, 0x0d, 0xa5, 0x7b, 0xfe,
	0x6a, 0x57, 0x3c, 0x56, 0x3d, 0x66, 0xa7, 0xe9, 0x31, 0xbd, 0xf3, 0x57, 0xdb, 0x94, 0x6b, 0xba,
	0xce, 0x4e, 0xd3, 0x75, 0xfc, 0xf3, 0x92, 0xae, 0x3c, 0xd6, 0x7d, 0xe8, 0x73, 0xec, 0x43, 0xa5,
	0x29, 0x5d, 0x35, 0xbf, 0xb0, 0x3e, 0xc9, 0x96, 0xa6, 0xe4, 0x96, 0x8b, 0x62, 0x09, 0x3a, 0x93,
	0x3c, 0x7c, 0x46, 0x8c, 0x7c, 0xcc, 0x2d, 0x17, 0xef, 0x4d, 0xe9, 0x3b, 0x8f, 0xea, 0xf9, 0x99,
	0x7b, 0xed, 0xf7, 0x1f, 0x77, 0xfc, 0xe9, 0x1f, 0x3c, 0xe8, 0x70, 0x99, 0x8a, 0x13, 0xf6, 0x53,
	0xe8, 0xd0, 0xab, 0xc9, 0x51, 0xc3, 0xf5, 0x7e, 0x42, 0xfc, 0xc0, 0xaa, 0xc4, 0xad, 0x10, 0xbb,
	0x09, 0x9d, 0x02, 0x61, 0xf2, 0xd4, 0xf0, 0xde, 0xc7, 0xe7, 0xa5, 0x31, 0x92, 0x4a, 0x6e, 0x65,
	0x28, 0xe1, 0xea, 0xb2, 0xe6, 0xbe, 0xf8, 0x6b, 0x9a, 0x26, 0xb9, 0xd5, 0xbc, 0x61, 0x3f, 0x56,
	0xfa, 0x65, 0x3d, 0x6a, 0xdc, 0xb8, 0x05, 0xdb, 0xeb, 0xd7, 0x33, 0x1f, 0xda, 0x58, 0x5a, 0x46,
	0x1b, 0xac, 0x4f, 0xef, 0x2d, 0xcc, 0xc8, 0x43, 0xb0, 0x34, 0x4a, 0x8f, 0x5a, 0x37, 0xbe, 0x84,
	0xad, 0xb5, 0xfb, 0x19, 0xd4, 0xcd, 0x7b, 0xb4, 0xc1, 0xba, 0x58, 0x9c, 0x47, 0x1e, 0xfe, 0xea,
	0x78, 0xd4, 0xc2, 0xfd, 0x54, 0x44, 0x46, 0x9b, 0x0f, 0xe3, 0xd7, 0x6f, 0x26, 0x1b, 0xdf, 0xbe,
	0x99, 0x6c, 0x7c, 0xf7, 0x66, 0xe2, 0xfd, 0xe6, 0x74, 0xe2, 0xfd, 0xf1, 0x74, 0xe2, 0xfd, 0xf9,
	0x74, 0xe2, 0xbd, 0x3e, 0x9d, 0x78, 0x7f, 0x3f, 0x9d, 0x78, 0xff, 0x38, 0x9d, 0x6c, 0x7c, 0x77,
	0x3a, 0xf1, 0x7e, 0xff, 0x76, 0xb2, 0xf1, 0xfa, 0xed, 0x64, 0xe3, 0xdb, 0xb7, 0x93, 0x8d, 0x5f,
	0xdd, 0x3b, 0xf3, 0x97, 0x49, 0xba, 0x50, 0x26, 0xfe, 0x62, 0xf7, 0x4e, 0x6d, 0x87, 0x5b, 0xf4,
	0x47, 0xc9, 0xcf, 0x6b, 0x32, 0xb0, 0xff, 0xa7, 0x74, 0xe9, 0xe7, 0x8b, 0xff, 0x05, 0x00, 0x00,
	0xff, 0xff, 0xc9, 0xb4, 0x12, 0xd1, 0x89, 0x11, 0x00, 0x00,
}

func (x RelayStates) String() string {
	s, ok := RelayStates_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RelayNames) String() string {
	s, ok := RelayNames_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NTP) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NTP)
	if !ok {
		that2, ok := that.(NTP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DayLight != that1.DayLight {
		return false
	}
	if this.Server != that1.Server {
		return false
	}
	if this.Timezone != that1.Timezone {
		return false
	}
	return true
}
func (this *Mqtt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Mqtt)
	if !ok {
		that2, ok := that.(Mqtt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.Server != that1.Server {
		return false
	}
	return true
}
func (this *Network) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Network)
	if !ok {
		that2, ok := that.(Network)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Dhcp != that1.Dhcp {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	if this.Netmask != that1.Netmask {
		return false
	}
	if this.Gateway != that1.Gateway {
		return false
	}
	if this.Dns != that1.Dns {
		return false
	}
	if this.AllowPost != that1.AllowPost {
		return false
	}
	if !this.Mqtt.Equal(that1.Mqtt) {
		return false
	}
	if !this.Ntp.Equal(that1.Ntp) {
		return false
	}
	return true
}
func (this *Temp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Temp)
	if !ok {
		that2, ok := that.(Temp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.Init != that1.Init {
		return false
	}
	if len(this.Addr) != len(that1.Addr) {
		return false
	}
	for i := range this.Addr {
		if this.Addr[i] != that1.Addr[i] {
			return false
		}
	}
	return true
}
func (this *Limits) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Limits)
	if !ok {
		that2, ok := that.(Limits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WpMin != that1.WpMin {
		return false
	}
	if this.WpMax != that1.WpMax {
		return false
	}
	if this.PhMin != that1.PhMin {
		return false
	}
	if this.PhMax != that1.PhMax {
		return false
	}
	if this.ChMin != that1.ChMin {
		return false
	}
	if this.ChMax != that1.ChMax {
		return false
	}
	if this.WaitBeforeCh != that1.WaitBeforeCh {
		return false
	}
	if this.ChTempThreshold != that1.ChTempThreshold {
		return false
	}
	if this.ChTempWaitReset != that1.ChTempWaitReset {
		return false
	}
	if this.Wp_0Derive != that1.Wp_0Derive {
		return false
	}
	if this.TwMin != that1.TwMin {
		return false
	}
	if this.TwMax != that1.TwMax {
		return false
	}
	if this.TambMin != that1.TambMin {
		return false
	}
	return true
}
func (this *AnalogSensor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AnalogSensor)
	if !ok {
		that2, ok := that.(AnalogSensor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.AdcPin != that1.AdcPin {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if this.ThresholdAccuracy != that1.ThresholdAccuracy {
		return false
	}
	if this.Vmin != that1.Vmin {
		return false
	}
	if this.Vmax != that1.Vmax {
		return false
	}
	if this.PrecisionFactor != that1.PrecisionFactor {
		return false
	}
	if this.AutoCal != that1.AutoCal {
		return false
	}
	return true
}
func (this *Sensors) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sensors)
	if !ok {
		that2, ok := that.(Sensors)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Twin.Equal(that1.Twin) {
		return false
	}
	if !this.Twout.Equal(that1.Twout) {
		return false
	}
	if !this.Tamb.Equal(that1.Tamb) {
		return false
	}
	if this.WaitForConversion != that1.WaitForConversion {
		return false
	}
	if this.TempResolution != that1.TempResolution {
		return false
	}
	if this.PrecisionFactor != that1.PrecisionFactor {
		return false
	}
	if !this.Ph.Equal(that1.Ph) {
		return false
	}
	if !this.Ch.Equal(that1.Ch) {
		return false
	}
	if !this.Wp.Equal(that1.Wp) {
		return false
	}
	if this.AdcMode != that1.AdcMode {
		return false
	}
	if this.AdcDatarate != that1.AdcDatarate {
		return false
	}
	if this.AdcGain != that1.AdcGain {
		return false
	}
	return true
}
func (this *Global) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Global)
	if !ok {
		that2, ok := that.(Global)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LcdBacklightDuration != that1.LcdBacklightDuration {
		return false
	}
	if this.AckDuration != that1.AckDuration {
		return false
	}
	if this.AckTone != that1.AckTone {
		return false
	}
	if this.SerialOut != that1.SerialOut {
		return false
	}
	if this.DisplayStartup != that1.DisplayStartup {
		return false
	}
	if this.ForceLight != that1.ForceLight {
		return false
	}
	if this.WdtDuration != that1.WdtDuration {
		return false
	}
	return true
}
func (this *Pump) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Pump)
	if !ok {
		that2, ok := that.(Pump)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ForceFilter != that1.ForceFilter {
		return false
	}
	if this.ForcePh != that1.ForcePh {
		return false
	}
	if this.ForceCh != that1.ForceCh {
		return false
	}
	if this.Automatic != that1.Automatic {
		return false
	}
	if this.ForceCheck != that1.ForceCheck {
		return false
	}
	if this.ForceDuration != that1.ForceDuration {
		return false
	}
	if this.ForceStartTime != that1.ForceStartTime {
		return false
	}
	return true
}
func (this *Ads115Alarms) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ads115Alarms)
	if !ok {
		that2, ok := that.(Ads115Alarms)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NotReady != that1.NotReady {
		return false
	}
	if this.NotStarted != that1.NotStarted {
		return false
	}
	if this.NotConnected != that1.NotConnected {
		return false
	}
	return true
}
func (this *MqttAlarms) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MqttAlarms)
	if !ok {
		that2, ok := that.(MqttAlarms)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Metrics != that1.Metrics {
		return false
	}
	if this.States != that1.States {
		return false
	}
	if this.Alarms != that1.Alarms {
		return false
	}
	if this.Temps != that1.Temps {
		return false
	}
	return true
}
func (this *Alarms) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Alarms)
	if !ok {
		that2, ok := that.(Alarms)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Filter != that1.Filter {
		return false
	}
	if this.Ph != that1.Ph {
		return false
	}
	if this.Ch != that1.Ch {
		return false
	}
	if this.Rtc != that1.Rtc {
		return false
	}
	if this.WpHigh != that1.WpHigh {
		return false
	}
	if this.WpLow != that1.WpLow {
		return false
	}
	if this.WpBroken != that1.WpBroken {
		return false
	}
	if !this.Ads1115.Equal(that1.Ads1115) {
		return false
	}
	if this.TwFrost != that1.TwFrost {
		return false
	}
	if this.TwHigh != that1.TwHigh {
		return false
	}
	if this.TambFrost != that1.TambFrost {
		return false
	}
	if !this.Mqtt.Equal(that1.Mqtt) {
		return false
	}
	return true
}
func (this *Tests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Tests)
	if !ok {
		that2, ok := that.(Tests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.Twater != that1.Twater {
		return false
	}
	if this.Tamb != that1.Tamb {
		return false
	}
	if this.Ph != that1.Ph {
		return false
	}
	if this.Pressure != that1.Pressure {
		return false
	}
	return true
}
func (this *Metrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Metrics)
	if !ok {
		that2, ok := that.(Metrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tamb != that1.Tamb {
		return false
	}
	if this.Twater != that1.Twater {
		return false
	}
	if this.SavedTwater != that1.SavedTwater {
		return false
	}
	if this.Ph != that1.Ph {
		return false
	}
	if this.Ch != that1.Ch {
		return false
	}
	if this.Wp != that1.Wp {
		return false
	}
	if this.WpVolt != that1.WpVolt {
		return false
	}
	if this.Over_15Duration != that1.Over_15Duration {
		return false
	}
	if this.Hour != that1.Hour {
		return false
	}
	if this.Time != that1.Time {
		return false
	}
	return true
}
func (this *States) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*States)
	if !ok {
		that2, ok := that.(States)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Startup != that1.Startup {
		return false
	}
	if this.FilterOn != that1.FilterOn {
		return false
	}
	if this.PhOn != that1.PhOn {
		return false
	}
	if this.ChOn != that1.ChOn {
		return false
	}
	if this.Automatic != that1.Automatic {
		return false
	}
	if this.NetActive != that1.NetActive {
		return false
	}
	if this.Ntp != that1.Ntp {
		return false
	}
	if this.Rtc != that1.Rtc {
		return false
	}
	if this.LightOn != that1.LightOn {
		return false
	}
	if this.MqttConnected != that1.MqttConnected {
		return false
	}
	return true
}
func (this *Versions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Versions)
	if !ok {
		that2, ok := that.(Versions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Domopool != that1.Domopool {
		return false
	}
	if this.Platformio != that1.Platformio {
		return false
	}
	if this.EspIdf != that1.EspIdf {
		return false
	}
	if this.Xtensa != that1.Xtensa {
		return false
	}
	if this.TftEspi != that1.TftEspi {
		return false
	}
	if this.Dallastemp != that1.Dallastemp {
		return false
	}
	if this.Ads1115 != that1.Ads1115 {
		return false
	}
	if this.Nanopb != that1.Nanopb {
		return false
	}
	if this.Mqtt != that1.Mqtt {
		return false
	}
	return true
}
func (this *Infos) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Infos)
	if !ok {
		that2, ok := that.(Infos)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Compile != that1.Compile {
		return false
	}
	if this.BoardName != that1.BoardName {
		return false
	}
	if !this.Versions.Equal(that1.Versions) {
		return false
	}
	return true
}
func (this *Config) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Config)
	if !ok {
		that2, ok := that.(Config)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if !this.Sensors.Equal(that1.Sensors) {
		return false
	}
	if !this.Global.Equal(that1.Global) {
		return false
	}
	if !this.Pump.Equal(that1.Pump) {
		return false
	}
	if !this.Metrics.Equal(that1.Metrics) {
		return false
	}
	if !this.States.Equal(that1.States) {
		return false
	}
	if !this.Alarms.Equal(that1.Alarms) {
		return false
	}
	if !this.Tests.Equal(that1.Tests) {
		return false
	}
	if !this.Infos.Equal(that1.Infos) {
		return false
	}
	if !this.Limits.Equal(that1.Limits) {
		return false
	}
	return true
}
func (this *Relay) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Relay)
	if !ok {
		that2, ok := that.(Relay)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Relay != that1.Relay {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	return true
}
func (this *NTP) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&domopool_proto.NTP{")
	s = append(s, "DayLight: "+fmt.Sprintf("%#v", this.DayLight)+",\n")
	s = append(s, "Server: "+fmt.Sprintf("%#v", this.Server)+",\n")
	s = append(s, "Timezone: "+fmt.Sprintf("%#v", this.Timezone)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Mqtt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&domopool_proto.Mqtt{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "Server: "+fmt.Sprintf("%#v", this.Server)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Network) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&domopool_proto.Network{")
	s = append(s, "Dhcp: "+fmt.Sprintf("%#v", this.Dhcp)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "Netmask: "+fmt.Sprintf("%#v", this.Netmask)+",\n")
	s = append(s, "Gateway: "+fmt.Sprintf("%#v", this.Gateway)+",\n")
	s = append(s, "Dns: "+fmt.Sprintf("%#v", this.Dns)+",\n")
	s = append(s, "AllowPost: "+fmt.Sprintf("%#v", this.AllowPost)+",\n")
	if this.Mqtt != nil {
		s = append(s, "Mqtt: "+fmt.Sprintf("%#v", this.Mqtt)+",\n")
	}
	if this.Ntp != nil {
		s = append(s, "Ntp: "+fmt.Sprintf("%#v", this.Ntp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Temp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&domopool_proto.Temp{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "Init: "+fmt.Sprintf("%#v", this.Init)+",\n")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Limits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&domopool_proto.Limits{")
	s = append(s, "WpMin: "+fmt.Sprintf("%#v", this.WpMin)+",\n")
	s = append(s, "WpMax: "+fmt.Sprintf("%#v", this.WpMax)+",\n")
	s = append(s, "PhMin: "+fmt.Sprintf("%#v", this.PhMin)+",\n")
	s = append(s, "PhMax: "+fmt.Sprintf("%#v", this.PhMax)+",\n")
	s = append(s, "ChMin: "+fmt.Sprintf("%#v", this.ChMin)+",\n")
	s = append(s, "ChMax: "+fmt.Sprintf("%#v", this.ChMax)+",\n")
	s = append(s, "WaitBeforeCh: "+fmt.Sprintf("%#v", this.WaitBeforeCh)+",\n")
	s = append(s, "ChTempThreshold: "+fmt.Sprintf("%#v", this.ChTempThreshold)+",\n")
	s = append(s, "ChTempWaitReset: "+fmt.Sprintf("%#v", this.ChTempWaitReset)+",\n")
	s = append(s, "Wp_0Derive: "+fmt.Sprintf("%#v", this.Wp_0Derive)+",\n")
	s = append(s, "TwMin: "+fmt.Sprintf("%#v", this.TwMin)+",\n")
	s = append(s, "TwMax: "+fmt.Sprintf("%#v", this.TwMax)+",\n")
	s = append(s, "TambMin: "+fmt.Sprintf("%#v", this.TambMin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnalogSensor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&domopool_proto.AnalogSensor{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "AdcPin: "+fmt.Sprintf("%#v", this.AdcPin)+",\n")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "ThresholdAccuracy: "+fmt.Sprintf("%#v", this.ThresholdAccuracy)+",\n")
	s = append(s, "Vmin: "+fmt.Sprintf("%#v", this.Vmin)+",\n")
	s = append(s, "Vmax: "+fmt.Sprintf("%#v", this.Vmax)+",\n")
	s = append(s, "PrecisionFactor: "+fmt.Sprintf("%#v", this.PrecisionFactor)+",\n")
	s = append(s, "AutoCal: "+fmt.Sprintf("%#v", this.AutoCal)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sensors) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&domopool_proto.Sensors{")
	if this.Twin != nil {
		s = append(s, "Twin: "+fmt.Sprintf("%#v", this.Twin)+",\n")
	}
	if this.Twout != nil {
		s = append(s, "Twout: "+fmt.Sprintf("%#v", this.Twout)+",\n")
	}
	if this.Tamb != nil {
		s = append(s, "Tamb: "+fmt.Sprintf("%#v", this.Tamb)+",\n")
	}
	s = append(s, "WaitForConversion: "+fmt.Sprintf("%#v", this.WaitForConversion)+",\n")
	s = append(s, "TempResolution: "+fmt.Sprintf("%#v", this.TempResolution)+",\n")
	s = append(s, "PrecisionFactor: "+fmt.Sprintf("%#v", this.PrecisionFactor)+",\n")
	if this.Ph != nil {
		s = append(s, "Ph: "+fmt.Sprintf("%#v", this.Ph)+",\n")
	}
	if this.Ch != nil {
		s = append(s, "Ch: "+fmt.Sprintf("%#v", this.Ch)+",\n")
	}
	if this.Wp != nil {
		s = append(s, "Wp: "+fmt.Sprintf("%#v", this.Wp)+",\n")
	}
	s = append(s, "AdcMode: "+fmt.Sprintf("%#v", this.AdcMode)+",\n")
	s = append(s, "AdcDatarate: "+fmt.Sprintf("%#v", this.AdcDatarate)+",\n")
	s = append(s, "AdcGain: "+fmt.Sprintf("%#v", this.AdcGain)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Global) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&domopool_proto.Global{")
	s = append(s, "LcdBacklightDuration: "+fmt.Sprintf("%#v", this.LcdBacklightDuration)+",\n")
	s = append(s, "AckDuration: "+fmt.Sprintf("%#v", this.AckDuration)+",\n")
	s = append(s, "AckTone: "+fmt.Sprintf("%#v", this.AckTone)+",\n")
	s = append(s, "SerialOut: "+fmt.Sprintf("%#v", this.SerialOut)+",\n")
	s = append(s, "DisplayStartup: "+fmt.Sprintf("%#v", this.DisplayStartup)+",\n")
	s = append(s, "ForceLight: "+fmt.Sprintf("%#v", this.ForceLight)+",\n")
	s = append(s, "WdtDuration: "+fmt.Sprintf("%#v", this.WdtDuration)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pump) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&domopool_proto.Pump{")
	s = append(s, "ForceFilter: "+fmt.Sprintf("%#v", this.ForceFilter)+",\n")
	s = append(s, "ForcePh: "+fmt.Sprintf("%#v", this.ForcePh)+",\n")
	s = append(s, "ForceCh: "+fmt.Sprintf("%#v", this.ForceCh)+",\n")
	s = append(s, "Automatic: "+fmt.Sprintf("%#v", this.Automatic)+",\n")
	s = append(s, "ForceCheck: "+fmt.Sprintf("%#v", this.ForceCheck)+",\n")
	s = append(s, "ForceDuration: "+fmt.Sprintf("%#v", this.ForceDuration)+",\n")
	s = append(s, "ForceStartTime: "+fmt.Sprintf("%#v", this.ForceStartTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ads115Alarms) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&domopool_proto.Ads115Alarms{")
	s = append(s, "NotReady: "+fmt.Sprintf("%#v", this.NotReady)+",\n")
	s = append(s, "NotStarted: "+fmt.Sprintf("%#v", this.NotStarted)+",\n")
	s = append(s, "NotConnected: "+fmt.Sprintf("%#v", this.NotConnected)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MqttAlarms) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&domopool_proto.MqttAlarms{")
	s = append(s, "Metrics: "+fmt.Sprintf("%#v", this.Metrics)+",\n")
	s = append(s, "States: "+fmt.Sprintf("%#v", this.States)+",\n")
	s = append(s, "Alarms: "+fmt.Sprintf("%#v", this.Alarms)+",\n")
	s = append(s, "Temps: "+fmt.Sprintf("%#v", this.Temps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Alarms) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&domopool_proto.Alarms{")
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "Ph: "+fmt.Sprintf("%#v", this.Ph)+",\n")
	s = append(s, "Ch: "+fmt.Sprintf("%#v", this.Ch)+",\n")
	s = append(s, "Rtc: "+fmt.Sprintf("%#v", this.Rtc)+",\n")
	s = append(s, "WpHigh: "+fmt.Sprintf("%#v", this.WpHigh)+",\n")
	s = append(s, "WpLow: "+fmt.Sprintf("%#v", this.WpLow)+",\n")
	s = append(s, "WpBroken: "+fmt.Sprintf("%#v", this.WpBroken)+",\n")
	if this.Ads1115 != nil {
		s = append(s, "Ads1115: "+fmt.Sprintf("%#v", this.Ads1115)+",\n")
	}
	s = append(s, "TwFrost: "+fmt.Sprintf("%#v", this.TwFrost)+",\n")
	s = append(s, "TwHigh: "+fmt.Sprintf("%#v", this.TwHigh)+",\n")
	s = append(s, "TambFrost: "+fmt.Sprintf("%#v", this.TambFrost)+",\n")
	if this.Mqtt != nil {
		s = append(s, "Mqtt: "+fmt.Sprintf("%#v", this.Mqtt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Tests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&domopool_proto.Tests{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "Twater: "+fmt.Sprintf("%#v", this.Twater)+",\n")
	s = append(s, "Tamb: "+fmt.Sprintf("%#v", this.Tamb)+",\n")
	s = append(s, "Ph: "+fmt.Sprintf("%#v", this.Ph)+",\n")
	s = append(s, "Pressure: "+fmt.Sprintf("%#v", this.Pressure)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Metrics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&domopool_proto.Metrics{")
	s = append(s, "Tamb: "+fmt.Sprintf("%#v", this.Tamb)+",\n")
	s = append(s, "Twater: "+fmt.Sprintf("%#v", this.Twater)+",\n")
	s = append(s, "SavedTwater: "+fmt.Sprintf("%#v", this.SavedTwater)+",\n")
	s = append(s, "Ph: "+fmt.Sprintf("%#v", this.Ph)+",\n")
	s = append(s, "Ch: "+fmt.Sprintf("%#v", this.Ch)+",\n")
	s = append(s, "Wp: "+fmt.Sprintf("%#v", this.Wp)+",\n")
	s = append(s, "WpVolt: "+fmt.Sprintf("%#v", this.WpVolt)+",\n")
	s = append(s, "Over_15Duration: "+fmt.Sprintf("%#v", this.Over_15Duration)+",\n")
	s = append(s, "Hour: "+fmt.Sprintf("%#v", this.Hour)+",\n")
	s = append(s, "Time: "+fmt.Sprintf("%#v", this.Time)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *States) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&domopool_proto.States{")
	s = append(s, "Startup: "+fmt.Sprintf("%#v", this.Startup)+",\n")
	s = append(s, "FilterOn: "+fmt.Sprintf("%#v", this.FilterOn)+",\n")
	s = append(s, "PhOn: "+fmt.Sprintf("%#v", this.PhOn)+",\n")
	s = append(s, "ChOn: "+fmt.Sprintf("%#v", this.ChOn)+",\n")
	s = append(s, "Automatic: "+fmt.Sprintf("%#v", this.Automatic)+",\n")
	s = append(s, "NetActive: "+fmt.Sprintf("%#v", this.NetActive)+",\n")
	s = append(s, "Ntp: "+fmt.Sprintf("%#v", this.Ntp)+",\n")
	s = append(s, "Rtc: "+fmt.Sprintf("%#v", this.Rtc)+",\n")
	s = append(s, "LightOn: "+fmt.Sprintf("%#v", this.LightOn)+",\n")
	s = append(s, "MqttConnected: "+fmt.Sprintf("%#v", this.MqttConnected)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Versions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&domopool_proto.Versions{")
	s = append(s, "Domopool: "+fmt.Sprintf("%#v", this.Domopool)+",\n")
	s = append(s, "Platformio: "+fmt.Sprintf("%#v", this.Platformio)+",\n")
	s = append(s, "EspIdf: "+fmt.Sprintf("%#v", this.EspIdf)+",\n")
	s = append(s, "Xtensa: "+fmt.Sprintf("%#v", this.Xtensa)+",\n")
	s = append(s, "TftEspi: "+fmt.Sprintf("%#v", this.TftEspi)+",\n")
	s = append(s, "Dallastemp: "+fmt.Sprintf("%#v", this.Dallastemp)+",\n")
	s = append(s, "Ads1115: "+fmt.Sprintf("%#v", this.Ads1115)+",\n")
	s = append(s, "Nanopb: "+fmt.Sprintf("%#v", this.Nanopb)+",\n")
	s = append(s, "Mqtt: "+fmt.Sprintf("%#v", this.Mqtt)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Infos) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&domopool_proto.Infos{")
	s = append(s, "Compile: "+fmt.Sprintf("%#v", this.Compile)+",\n")
	s = append(s, "BoardName: "+fmt.Sprintf("%#v", this.BoardName)+",\n")
	if this.Versions != nil {
		s = append(s, "Versions: "+fmt.Sprintf("%#v", this.Versions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Config) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&domopool_proto.Config{")
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Sensors != nil {
		s = append(s, "Sensors: "+fmt.Sprintf("%#v", this.Sensors)+",\n")
	}
	if this.Global != nil {
		s = append(s, "Global: "+fmt.Sprintf("%#v", this.Global)+",\n")
	}
	if this.Pump != nil {
		s = append(s, "Pump: "+fmt.Sprintf("%#v", this.Pump)+",\n")
	}
	if this.Metrics != nil {
		s = append(s, "Metrics: "+fmt.Sprintf("%#v", this.Metrics)+",\n")
	}
	if this.States != nil {
		s = append(s, "States: "+fmt.Sprintf("%#v", this.States)+",\n")
	}
	if this.Alarms != nil {
		s = append(s, "Alarms: "+fmt.Sprintf("%#v", this.Alarms)+",\n")
	}
	if this.Tests != nil {
		s = append(s, "Tests: "+fmt.Sprintf("%#v", this.Tests)+",\n")
	}
	if this.Infos != nil {
		s = append(s, "Infos: "+fmt.Sprintf("%#v", this.Infos)+",\n")
	}
	if this.Limits != nil {
		s = append(s, "Limits: "+fmt.Sprintf("%#v", this.Limits)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Relay) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&domopool_proto.Relay{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Relay: "+fmt.Sprintf("%#v", this.Relay)+",\n")
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDomopool(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timezone != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Timezone))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x12
	}
	if m.DayLight != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.DayLight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mqtt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mqtt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mqtt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ntp != nil {
		{
			size, err := m.Ntp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Mqtt != nil {
		{
			size, err := m.Mqtt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AllowPost {
		i--
		if m.AllowPost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Dns) > 0 {
		i -= len(m.Dns)
		copy(dAtA[i:], m.Dns)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Dns)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Gateway) > 0 {
		i -= len(m.Gateway)
		copy(dAtA[i:], m.Gateway)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Gateway)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Netmask) > 0 {
		i -= len(m.Netmask)
		copy(dAtA[i:], m.Netmask)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Netmask)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if m.Dhcp {
		i--
		if m.Dhcp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Temp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Temp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Temp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA4 := make([]byte, len(m.Addr)*10)
		var j3 int
		for _, num := range m.Addr {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintDomopool(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x42
	}
	if m.Init {
		i--
		if m.Init {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TambMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TambMin))))
		i--
		dAtA[i] = 0x6d
	}
	if m.TwMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TwMax))))
		i--
		dAtA[i] = 0x65
	}
	if m.TwMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TwMin))))
		i--
		dAtA[i] = 0x5d
	}
	if m.Wp_0Derive != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Wp_0Derive))))
		i--
		dAtA[i] = 0x55
	}
	if m.ChTempWaitReset != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChTempWaitReset))))
		i--
		dAtA[i] = 0x4d
	}
	if m.ChTempThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChTempThreshold))))
		i--
		dAtA[i] = 0x45
	}
	if m.WaitBeforeCh != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.WaitBeforeCh))
		i--
		dAtA[i] = 0x38
	}
	if m.ChMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChMax))))
		i--
		dAtA[i] = 0x35
	}
	if m.ChMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChMin))))
		i--
		dAtA[i] = 0x2d
	}
	if m.PhMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhMax))))
		i--
		dAtA[i] = 0x25
	}
	if m.PhMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhMin))))
		i--
		dAtA[i] = 0x1d
	}
	if m.WpMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WpMax))))
		i--
		dAtA[i] = 0x15
	}
	if m.WpMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WpMin))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *AnalogSensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalogSensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalogSensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoCal {
		i--
		if m.AutoCal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PrecisionFactor != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.PrecisionFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.Vmax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Vmax))))
		i--
		dAtA[i] = 0x35
	}
	if m.Vmin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Vmin))))
		i--
		dAtA[i] = 0x2d
	}
	if m.ThresholdAccuracy != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.ThresholdAccuracy))
		i--
		dAtA[i] = 0x20
	}
	if m.AdcPin != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AdcPin))
		i--
		dAtA[i] = 0x18
	}
	if m.Threshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Threshold))))
		i--
		dAtA[i] = 0x15
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sensors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sensors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sensors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdcGain != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AdcGain))
		i--
		dAtA[i] = 0x60
	}
	if m.AdcDatarate != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AdcDatarate))
		i--
		dAtA[i] = 0x58
	}
	if m.AdcMode != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AdcMode))
		i--
		dAtA[i] = 0x50
	}
	if m.Wp != nil {
		{
			size, err := m.Wp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Ch != nil {
		{
			size, err := m.Ch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Ph != nil {
		{
			size, err := m.Ph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PrecisionFactor != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.PrecisionFactor))
		i--
		dAtA[i] = 0x30
	}
	if m.TempResolution != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.TempResolution))
		i--
		dAtA[i] = 0x28
	}
	if m.WaitForConversion {
		i--
		if m.WaitForConversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Tamb != nil {
		{
			size, err := m.Tamb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Twout != nil {
		{
			size, err := m.Twout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Twin != nil {
		{
			size, err := m.Twin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WdtDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.WdtDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.ForceLight {
		i--
		if m.ForceLight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DisplayStartup {
		i--
		if m.DisplayStartup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SerialOut {
		i--
		if m.SerialOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AckTone != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AckTone))))
		i--
		dAtA[i] = 0x19
	}
	if m.AckDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AckDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.LcdBacklightDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.LcdBacklightDuration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pump) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pump) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pump) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceStartTime != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.ForceStartTime))
		i--
		dAtA[i] = 0x38
	}
	if m.ForceDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.ForceDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.ForceCheck {
		i--
		if m.ForceCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Automatic {
		i--
		if m.Automatic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ForceCh {
		i--
		if m.ForceCh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ForcePh {
		i--
		if m.ForcePh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ForceFilter {
		i--
		if m.ForceFilter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ads115Alarms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ads115Alarms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ads115Alarms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotConnected {
		i--
		if m.NotConnected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NotStarted {
		i--
		if m.NotStarted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NotReady {
		i--
		if m.NotReady {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MqttAlarms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MqttAlarms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MqttAlarms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Temps {
		i--
		if m.Temps {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Alarms {
		i--
		if m.Alarms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.States {
		i--
		if m.States {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Metrics {
		i--
		if m.Metrics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alarms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alarms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alarms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mqtt != nil {
		{
			size, err := m.Mqtt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.TambFrost {
		i--
		if m.TambFrost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.TwHigh {
		i--
		if m.TwHigh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.TwFrost {
		i--
		if m.TwFrost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Ads1115 != nil {
		{
			size, err := m.Ads1115.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.WpBroken {
		i--
		if m.WpBroken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.WpLow {
		i--
		if m.WpLow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.WpHigh {
		i--
		if m.WpHigh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Rtc {
		i--
		if m.Rtc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Ch {
		i--
		if m.Ch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Ph {
		i--
		if m.Ph {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Filter {
		i--
		if m.Filter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pressure != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Pressure))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Ph != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ph))))
		i--
		dAtA[i] = 0x25
	}
	if m.Tamb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Tamb))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Twater != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Twater))))
		i--
		dAtA[i] = 0x15
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x50
	}
	if m.Hour != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Hour))
		i--
		dAtA[i] = 0x48
	}
	if m.Over_15Duration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Over_15Duration))
		i--
		dAtA[i] = 0x40
	}
	if m.WpVolt != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WpVolt))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Wp != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Wp))))
		i--
		dAtA[i] = 0x35
	}
	if m.Ch != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ch))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Ph != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ph))))
		i--
		dAtA[i] = 0x25
	}
	if m.SavedTwater != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SavedTwater))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Twater != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Twater))))
		i--
		dAtA[i] = 0x15
	}
	if m.Tamb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Tamb))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *States) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *States) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *States) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MqttConnected {
		i--
		if m.MqttConnected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.LightOn {
		i--
		if m.LightOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Rtc {
		i--
		if m.Rtc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Ntp {
		i--
		if m.Ntp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NetActive {
		i--
		if m.NetActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Automatic {
		i--
		if m.Automatic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ChOn {
		i--
		if m.ChOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PhOn {
		i--
		if m.PhOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FilterOn {
		i--
		if m.FilterOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Startup {
		i--
		if m.Startup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Versions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Versions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Versions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mqtt) > 0 {
		i -= len(m.Mqtt)
		copy(dAtA[i:], m.Mqtt)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Mqtt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Nanopb) > 0 {
		i -= len(m.Nanopb)
		copy(dAtA[i:], m.Nanopb)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Nanopb)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Ads1115) > 0 {
		i -= len(m.Ads1115)
		copy(dAtA[i:], m.Ads1115)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Ads1115)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Dallastemp) > 0 {
		i -= len(m.Dallastemp)
		copy(dAtA[i:], m.Dallastemp)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Dallastemp)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TftEspi) > 0 {
		i -= len(m.TftEspi)
		copy(dAtA[i:], m.TftEspi)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.TftEspi)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Xtensa) > 0 {
		i -= len(m.Xtensa)
		copy(dAtA[i:], m.Xtensa)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Xtensa)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EspIdf) > 0 {
		i -= len(m.EspIdf)
		copy(dAtA[i:], m.EspIdf)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.EspIdf)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Platformio != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Platformio))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Domopool) > 0 {
		i -= len(m.Domopool)
		copy(dAtA[i:], m.Domopool)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Domopool)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Infos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Infos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Infos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Versions != nil {
		{
			size, err := m.Versions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BoardName) > 0 {
		i -= len(m.BoardName)
		copy(dAtA[i:], m.BoardName)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.BoardName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Compile) > 0 {
		i -= len(m.Compile)
		copy(dAtA[i:], m.Compile)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Compile)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limits != nil {
		{
			size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Infos != nil {
		{
			size, err := m.Infos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Tests != nil {
		{
			size, err := m.Tests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Alarms != nil {
		{
			size, err := m.Alarms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.States != nil {
		{
			size, err := m.States.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Pump != nil {
		{
			size, err := m.Pump.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Sensors != nil {
		{
			size, err := m.Sensors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Relay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartTime != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Duration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x18
	}
	if m.Relay != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Relay))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDomopool(dAtA []byte, offset int, v uint64) int {
	offset -= sovDomopool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DayLight != 0 {
		n += 1 + sovDomopool(uint64(m.DayLight))
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Timezone != 0 {
		n += 1 + sovDomopool(uint64(m.Timezone))
	}
	return n
}

func (m *Mqtt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	return n
}

func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dhcp {
		n += 2
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Netmask)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Dns)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.AllowPost {
		n += 2
	}
	if m.Mqtt != nil {
		l = m.Mqtt.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Ntp != nil {
		l = m.Ntp.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	return n
}

func (m *Temp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Init {
		n += 2
	}
	if len(m.Addr) > 0 {
		l = 0
		for _, e := range m.Addr {
			l += sovDomopool(uint64(e))
		}
		n += 1 + sovDomopool(uint64(l)) + l
	}
	return n
}

func (m *Limits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WpMin != 0 {
		n += 5
	}
	if m.WpMax != 0 {
		n += 5
	}
	if m.PhMin != 0 {
		n += 5
	}
	if m.PhMax != 0 {
		n += 5
	}
	if m.ChMin != 0 {
		n += 5
	}
	if m.ChMax != 0 {
		n += 5
	}
	if m.WaitBeforeCh != 0 {
		n += 1 + sovDomopool(uint64(m.WaitBeforeCh))
	}
	if m.ChTempThreshold != 0 {
		n += 5
	}
	if m.ChTempWaitReset != 0 {
		n += 5
	}
	if m.Wp_0Derive != 0 {
		n += 5
	}
	if m.TwMin != 0 {
		n += 5
	}
	if m.TwMax != 0 {
		n += 5
	}
	if m.TambMin != 0 {
		n += 5
	}
	return n
}

func (m *AnalogSensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Threshold != 0 {
		n += 5
	}
	if m.AdcPin != 0 {
		n += 1 + sovDomopool(uint64(m.AdcPin))
	}
	if m.ThresholdAccuracy != 0 {
		n += 1 + sovDomopool(uint64(m.ThresholdAccuracy))
	}
	if m.Vmin != 0 {
		n += 5
	}
	if m.Vmax != 0 {
		n += 5
	}
	if m.PrecisionFactor != 0 {
		n += 1 + sovDomopool(uint64(m.PrecisionFactor))
	}
	if m.AutoCal {
		n += 2
	}
	return n
}

func (m *Sensors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Twin != nil {
		l = m.Twin.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Twout != nil {
		l = m.Twout.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Tamb != nil {
		l = m.Tamb.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.WaitForConversion {
		n += 2
	}
	if m.TempResolution != 0 {
		n += 1 + sovDomopool(uint64(m.TempResolution))
	}
	if m.PrecisionFactor != 0 {
		n += 1 + sovDomopool(uint64(m.PrecisionFactor))
	}
	if m.Ph != nil {
		l = m.Ph.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Ch != nil {
		l = m.Ch.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Wp != nil {
		l = m.Wp.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.AdcMode != 0 {
		n += 1 + sovDomopool(uint64(m.AdcMode))
	}
	if m.AdcDatarate != 0 {
		n += 1 + sovDomopool(uint64(m.AdcDatarate))
	}
	if m.AdcGain != 0 {
		n += 1 + sovDomopool(uint64(m.AdcGain))
	}
	return n
}

func (m *Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LcdBacklightDuration != 0 {
		n += 1 + sovDomopool(uint64(m.LcdBacklightDuration))
	}
	if m.AckDuration != 0 {
		n += 1 + sovDomopool(uint64(m.AckDuration))
	}
	if m.AckTone != 0 {
		n += 9
	}
	if m.SerialOut {
		n += 2
	}
	if m.DisplayStartup {
		n += 2
	}
	if m.ForceLight {
		n += 2
	}
	if m.WdtDuration != 0 {
		n += 1 + sovDomopool(uint64(m.WdtDuration))
	}
	return n
}

func (m *Pump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForceFilter {
		n += 2
	}
	if m.ForcePh {
		n += 2
	}
	if m.ForceCh {
		n += 2
	}
	if m.Automatic {
		n += 2
	}
	if m.ForceCheck {
		n += 2
	}
	if m.ForceDuration != 0 {
		n += 1 + sovDomopool(uint64(m.ForceDuration))
	}
	if m.ForceStartTime != 0 {
		n += 1 + sovDomopool(uint64(m.ForceStartTime))
	}
	return n
}

func (m *Ads115Alarms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotReady {
		n += 2
	}
	if m.NotStarted {
		n += 2
	}
	if m.NotConnected {
		n += 2
	}
	return n
}

func (m *MqttAlarms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metrics {
		n += 2
	}
	if m.States {
		n += 2
	}
	if m.Alarms {
		n += 2
	}
	if m.Temps {
		n += 2
	}
	return n
}

func (m *Alarms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter {
		n += 2
	}
	if m.Ph {
		n += 2
	}
	if m.Ch {
		n += 2
	}
	if m.Rtc {
		n += 2
	}
	if m.WpHigh {
		n += 2
	}
	if m.WpLow {
		n += 2
	}
	if m.WpBroken {
		n += 2
	}
	if m.Ads1115 != nil {
		l = m.Ads1115.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.TwFrost {
		n += 2
	}
	if m.TwHigh {
		n += 2
	}
	if m.TambFrost {
		n += 2
	}
	if m.Mqtt != nil {
		l = m.Mqtt.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	return n
}

func (m *Tests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Twater != 0 {
		n += 5
	}
	if m.Tamb != 0 {
		n += 5
	}
	if m.Ph != 0 {
		n += 5
	}
	if m.Pressure != 0 {
		n += 5
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tamb != 0 {
		n += 5
	}
	if m.Twater != 0 {
		n += 5
	}
	if m.SavedTwater != 0 {
		n += 5
	}
	if m.Ph != 0 {
		n += 5
	}
	if m.Ch != 0 {
		n += 5
	}
	if m.Wp != 0 {
		n += 5
	}
	if m.WpVolt != 0 {
		n += 5
	}
	if m.Over_15Duration != 0 {
		n += 1 + sovDomopool(uint64(m.Over_15Duration))
	}
	if m.Hour != 0 {
		n += 1 + sovDomopool(uint64(m.Hour))
	}
	if m.Time != 0 {
		n += 1 + sovDomopool(uint64(m.Time))
	}
	return n
}

func (m *States) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Startup {
		n += 2
	}
	if m.FilterOn {
		n += 2
	}
	if m.PhOn {
		n += 2
	}
	if m.ChOn {
		n += 2
	}
	if m.Automatic {
		n += 2
	}
	if m.NetActive {
		n += 2
	}
	if m.Ntp {
		n += 2
	}
	if m.Rtc {
		n += 2
	}
	if m.LightOn {
		n += 2
	}
	if m.MqttConnected {
		n += 2
	}
	return n
}

func (m *Versions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domopool)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Platformio != 0 {
		n += 1 + sovDomopool(uint64(m.Platformio))
	}
	l = len(m.EspIdf)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Xtensa)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.TftEspi)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Dallastemp)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Ads1115)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Nanopb)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Mqtt)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	return n
}

func (m *Infos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Compile)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.BoardName)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Versions != nil {
		l = m.Versions.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Sensors != nil {
		l = m.Sensors.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Pump != nil {
		l = m.Pump.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.States != nil {
		l = m.States.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Alarms != nil {
		l = m.Alarms.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Tests != nil {
		l = m.Tests.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Infos != nil {
		l = m.Infos.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	return n
}

func (m *Relay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDomopool(uint64(m.State))
	}
	if m.Relay != 0 {
		n += 1 + sovDomopool(uint64(m.Relay))
	}
	if m.Duration != 0 {
		n += 1 + sovDomopool(uint64(m.Duration))
	}
	if m.StartTime != 0 {
		n += 1 + sovDomopool(uint64(m.StartTime))
	}
	return n
}

func sovDomopool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDomopool(x uint64) (n int) {
	return sovDomopool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NTP) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NTP{`,
		`DayLight:` + fmt.Sprintf("%v", this.DayLight) + `,`,
		`Server:` + fmt.Sprintf("%v", this.Server) + `,`,
		`Timezone:` + fmt.Sprintf("%v", this.Timezone) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Mqtt) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Mqtt{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`Server:` + fmt.Sprintf("%v", this.Server) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Network) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Network{`,
		`Dhcp:` + fmt.Sprintf("%v", this.Dhcp) + `,`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`Netmask:` + fmt.Sprintf("%v", this.Netmask) + `,`,
		`Gateway:` + fmt.Sprintf("%v", this.Gateway) + `,`,
		`Dns:` + fmt.Sprintf("%v", this.Dns) + `,`,
		`AllowPost:` + fmt.Sprintf("%v", this.AllowPost) + `,`,
		`Mqtt:` + strings.Replace(this.Mqtt.String(), "Mqtt", "Mqtt", 1) + `,`,
		`Ntp:` + strings.Replace(this.Ntp.String(), "NTP", "NTP", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Temp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Temp{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`Init:` + fmt.Sprintf("%v", this.Init) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Limits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Limits{`,
		`WpMin:` + fmt.Sprintf("%v", this.WpMin) + `,`,
		`WpMax:` + fmt.Sprintf("%v", this.WpMax) + `,`,
		`PhMin:` + fmt.Sprintf("%v", this.PhMin) + `,`,
		`PhMax:` + fmt.Sprintf("%v", this.PhMax) + `,`,
		`ChMin:` + fmt.Sprintf("%v", this.ChMin) + `,`,
		`ChMax:` + fmt.Sprintf("%v", this.ChMax) + `,`,
		`WaitBeforeCh:` + fmt.Sprintf("%v", this.WaitBeforeCh) + `,`,
		`ChTempThreshold:` + fmt.Sprintf("%v", this.ChTempThreshold) + `,`,
		`ChTempWaitReset:` + fmt.Sprintf("%v", this.ChTempWaitReset) + `,`,
		`Wp_0Derive:` + fmt.Sprintf("%v", this.Wp_0Derive) + `,`,
		`TwMin:` + fmt.Sprintf("%v", this.TwMin) + `,`,
		`TwMax:` + fmt.Sprintf("%v", this.TwMax) + `,`,
		`TambMin:` + fmt.Sprintf("%v", this.TambMin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AnalogSensor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AnalogSensor{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`AdcPin:` + fmt.Sprintf("%v", this.AdcPin) + `,`,
		`ThresholdAccuracy:` + fmt.Sprintf("%v", this.ThresholdAccuracy) + `,`,
		`Vmin:` + fmt.Sprintf("%v", this.Vmin) + `,`,
		`Vmax:` + fmt.Sprintf("%v", this.Vmax) + `,`,
		`PrecisionFactor:` + fmt.Sprintf("%v", this.PrecisionFactor) + `,`,
		`AutoCal:` + fmt.Sprintf("%v", this.AutoCal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sensors) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sensors{`,
		`Twin:` + strings.Replace(this.Twin.String(), "Temp", "Temp", 1) + `,`,
		`Twout:` + strings.Replace(this.Twout.String(), "Temp", "Temp", 1) + `,`,
		`Tamb:` + strings.Replace(this.Tamb.String(), "Temp", "Temp", 1) + `,`,
		`WaitForConversion:` + fmt.Sprintf("%v", this.WaitForConversion) + `,`,
		`TempResolution:` + fmt.Sprintf("%v", this.TempResolution) + `,`,
		`PrecisionFactor:` + fmt.Sprintf("%v", this.PrecisionFactor) + `,`,
		`Ph:` + strings.Replace(this.Ph.String(), "AnalogSensor", "AnalogSensor", 1) + `,`,
		`Ch:` + strings.Replace(this.Ch.String(), "AnalogSensor", "AnalogSensor", 1) + `,`,
		`Wp:` + strings.Replace(this.Wp.String(), "AnalogSensor", "AnalogSensor", 1) + `,`,
		`AdcMode:` + fmt.Sprintf("%v", this.AdcMode) + `,`,
		`AdcDatarate:` + fmt.Sprintf("%v", this.AdcDatarate) + `,`,
		`AdcGain:` + fmt.Sprintf("%v", this.AdcGain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Global) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Global{`,
		`LcdBacklightDuration:` + fmt.Sprintf("%v", this.LcdBacklightDuration) + `,`,
		`AckDuration:` + fmt.Sprintf("%v", this.AckDuration) + `,`,
		`AckTone:` + fmt.Sprintf("%v", this.AckTone) + `,`,
		`SerialOut:` + fmt.Sprintf("%v", this.SerialOut) + `,`,
		`DisplayStartup:` + fmt.Sprintf("%v", this.DisplayStartup) + `,`,
		`ForceLight:` + fmt.Sprintf("%v", this.ForceLight) + `,`,
		`WdtDuration:` + fmt.Sprintf("%v", this.WdtDuration) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Pump) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Pump{`,
		`ForceFilter:` + fmt.Sprintf("%v", this.ForceFilter) + `,`,
		`ForcePh:` + fmt.Sprintf("%v", this.ForcePh) + `,`,
		`ForceCh:` + fmt.Sprintf("%v", this.ForceCh) + `,`,
		`Automatic:` + fmt.Sprintf("%v", this.Automatic) + `,`,
		`ForceCheck:` + fmt.Sprintf("%v", this.ForceCheck) + `,`,
		`ForceDuration:` + fmt.Sprintf("%v", this.ForceDuration) + `,`,
		`ForceStartTime:` + fmt.Sprintf("%v", this.ForceStartTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ads115Alarms) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ads115Alarms{`,
		`NotReady:` + fmt.Sprintf("%v", this.NotReady) + `,`,
		`NotStarted:` + fmt.Sprintf("%v", this.NotStarted) + `,`,
		`NotConnected:` + fmt.Sprintf("%v", this.NotConnected) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MqttAlarms) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MqttAlarms{`,
		`Metrics:` + fmt.Sprintf("%v", this.Metrics) + `,`,
		`States:` + fmt.Sprintf("%v", this.States) + `,`,
		`Alarms:` + fmt.Sprintf("%v", this.Alarms) + `,`,
		`Temps:` + fmt.Sprintf("%v", this.Temps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Alarms) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Alarms{`,
		`Filter:` + fmt.Sprintf("%v", this.Filter) + `,`,
		`Ph:` + fmt.Sprintf("%v", this.Ph) + `,`,
		`Ch:` + fmt.Sprintf("%v", this.Ch) + `,`,
		`Rtc:` + fmt.Sprintf("%v", this.Rtc) + `,`,
		`WpHigh:` + fmt.Sprintf("%v", this.WpHigh) + `,`,
		`WpLow:` + fmt.Sprintf("%v", this.WpLow) + `,`,
		`WpBroken:` + fmt.Sprintf("%v", this.WpBroken) + `,`,
		`Ads1115:` + strings.Replace(this.Ads1115.String(), "Ads115Alarms", "Ads115Alarms", 1) + `,`,
		`TwFrost:` + fmt.Sprintf("%v", this.TwFrost) + `,`,
		`TwHigh:` + fmt.Sprintf("%v", this.TwHigh) + `,`,
		`TambFrost:` + fmt.Sprintf("%v", this.TambFrost) + `,`,
		`Mqtt:` + strings.Replace(this.Mqtt.String(), "MqttAlarms", "MqttAlarms", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Tests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Tests{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`Twater:` + fmt.Sprintf("%v", this.Twater) + `,`,
		`Tamb:` + fmt.Sprintf("%v", this.Tamb) + `,`,
		`Ph:` + fmt.Sprintf("%v", this.Ph) + `,`,
		`Pressure:` + fmt.Sprintf("%v", this.Pressure) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Metrics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Metrics{`,
		`Tamb:` + fmt.Sprintf("%v", this.Tamb) + `,`,
		`Twater:` + fmt.Sprintf("%v", this.Twater) + `,`,
		`SavedTwater:` + fmt.Sprintf("%v", this.SavedTwater) + `,`,
		`Ph:` + fmt.Sprintf("%v", this.Ph) + `,`,
		`Ch:` + fmt.Sprintf("%v", this.Ch) + `,`,
		`Wp:` + fmt.Sprintf("%v", this.Wp) + `,`,
		`WpVolt:` + fmt.Sprintf("%v", this.WpVolt) + `,`,
		`Over_15Duration:` + fmt.Sprintf("%v", this.Over_15Duration) + `,`,
		`Hour:` + fmt.Sprintf("%v", this.Hour) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *States) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&States{`,
		`Startup:` + fmt.Sprintf("%v", this.Startup) + `,`,
		`FilterOn:` + fmt.Sprintf("%v", this.FilterOn) + `,`,
		`PhOn:` + fmt.Sprintf("%v", this.PhOn) + `,`,
		`ChOn:` + fmt.Sprintf("%v", this.ChOn) + `,`,
		`Automatic:` + fmt.Sprintf("%v", this.Automatic) + `,`,
		`NetActive:` + fmt.Sprintf("%v", this.NetActive) + `,`,
		`Ntp:` + fmt.Sprintf("%v", this.Ntp) + `,`,
		`Rtc:` + fmt.Sprintf("%v", this.Rtc) + `,`,
		`LightOn:` + fmt.Sprintf("%v", this.LightOn) + `,`,
		`MqttConnected:` + fmt.Sprintf("%v", this.MqttConnected) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Versions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Versions{`,
		`Domopool:` + fmt.Sprintf("%v", this.Domopool) + `,`,
		`Platformio:` + fmt.Sprintf("%v", this.Platformio) + `,`,
		`EspIdf:` + fmt.Sprintf("%v", this.EspIdf) + `,`,
		`Xtensa:` + fmt.Sprintf("%v", this.Xtensa) + `,`,
		`TftEspi:` + fmt.Sprintf("%v", this.TftEspi) + `,`,
		`Dallastemp:` + fmt.Sprintf("%v", this.Dallastemp) + `,`,
		`Ads1115:` + fmt.Sprintf("%v", this.Ads1115) + `,`,
		`Nanopb:` + fmt.Sprintf("%v", this.Nanopb) + `,`,
		`Mqtt:` + fmt.Sprintf("%v", this.Mqtt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Infos) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Infos{`,
		`Compile:` + fmt.Sprintf("%v", this.Compile) + `,`,
		`BoardName:` + fmt.Sprintf("%v", this.BoardName) + `,`,
		`Versions:` + strings.Replace(this.Versions.String(), "Versions", "Versions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Config) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Config{`,
		`Network:` + strings.Replace(this.Network.String(), "Network", "Network", 1) + `,`,
		`Sensors:` + strings.Replace(this.Sensors.String(), "Sensors", "Sensors", 1) + `,`,
		`Global:` + strings.Replace(this.Global.String(), "Global", "Global", 1) + `,`,
		`Pump:` + strings.Replace(this.Pump.String(), "Pump", "Pump", 1) + `,`,
		`Metrics:` + strings.Replace(this.Metrics.String(), "Metrics", "Metrics", 1) + `,`,
		`States:` + strings.Replace(this.States.String(), "States", "States", 1) + `,`,
		`Alarms:` + strings.Replace(this.Alarms.String(), "Alarms", "Alarms", 1) + `,`,
		`Tests:` + strings.Replace(this.Tests.String(), "Tests", "Tests", 1) + `,`,
		`Infos:` + strings.Replace(this.Infos.String(), "Infos", "Infos", 1) + `,`,
		`Limits:` + strings.Replace(this.Limits.String(), "Limits", "Limits", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Relay) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Relay{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Relay:` + fmt.Sprintf("%v", this.Relay) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDomopool(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayLight", wireType)
			}
			m.DayLight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DayLight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timezone", wireType)
			}
			m.Timezone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timezone |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mqtt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mqtt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mqtt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dhcp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dhcp = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Netmask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Netmask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPost = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mqtt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mqtt == nil {
				m.Mqtt = &Mqtt{}
			}
			if err := m.Mqtt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ntp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ntp == nil {
				m.Ntp = &NTP{}
			}
			if err := m.Ntp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Temp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Temp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Temp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Init = bool(v != 0)
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomopool
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Addr = append(m.Addr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomopool
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomopool
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDomopool
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Addr) == 0 {
					m.Addr = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomopool
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Addr = append(m.Addr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WpMin = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WpMax = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhMin = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhMax = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChMin = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChMax = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitBeforeCh", wireType)
			}
			m.WaitBeforeCh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitBeforeCh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChTempThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChTempThreshold = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChTempWaitReset", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChTempWaitReset = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wp_0Derive", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Wp_0Derive = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TwMin = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TwMax = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TambMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TambMin = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalogSensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalogSensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalogSensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Threshold = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdcPin", wireType)
			}
			m.AdcPin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdcPin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdAccuracy", wireType)
			}
			m.ThresholdAccuracy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThresholdAccuracy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vmin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Vmin = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vmax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Vmax = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionFactor", wireType)
			}
			m.PrecisionFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoCal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sensors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sensors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sensors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Twin == nil {
				m.Twin = &Temp{}
			}
			if err := m.Twin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Twout == nil {
				m.Twout = &Temp{}
			}
			if err := m.Twout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tamb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tamb == nil {
				m.Tamb = &Temp{}
			}
			if err := m.Tamb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitForConversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaitForConversion = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempResolution", wireType)
			}
			m.TempResolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempResolution |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionFactor", wireType)
			}
			m.PrecisionFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ph == nil {
				m.Ph = &AnalogSensor{}
			}
			if err := m.Ph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ch == nil {
				m.Ch = &AnalogSensor{}
			}
			if err := m.Ch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wp == nil {
				m.Wp = &AnalogSensor{}
			}
			if err := m.Wp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdcMode", wireType)
			}
			m.AdcMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdcMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdcDatarate", wireType)
			}
			m.AdcDatarate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdcDatarate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdcGain", wireType)
			}
			m.AdcGain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdcGain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LcdBacklightDuration", wireType)
			}
			m.LcdBacklightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LcdBacklightDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckDuration", wireType)
			}
			m.AckDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckTone", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AckTone = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SerialOut = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayStartup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisplayStartup = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceLight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceLight = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdtDuration", wireType)
			}
			m.WdtDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WdtDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pump) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pump: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pump: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceFilter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceFilter = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePh = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceCh = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Automatic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Automatic = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceCheck = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceDuration", wireType)
			}
			m.ForceDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceStartTime", wireType)
			}
			m.ForceStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceStartTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ads115Alarms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ads115Alarms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ads115Alarms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotReady = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotStarted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotStarted = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotConnected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MqttAlarms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MqttAlarms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MqttAlarms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Metrics = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.States = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alarms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Alarms = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temps", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temps = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alarms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alarms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alarms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Filter = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ph = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ch = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rtc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpHigh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WpHigh = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpLow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WpLow = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpBroken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WpBroken = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ads1115", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ads1115 == nil {
				m.Ads1115 = &Ads115Alarms{}
			}
			if err := m.Ads1115.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwFrost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TwFrost = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwHigh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TwHigh = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TambFrost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TambFrost = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mqtt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mqtt == nil {
				m.Mqtt = &MqttAlarms{}
			}
			if err := m.Mqtt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twater", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Twater = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tamb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Tamb = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ph = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pressure", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Pressure = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tamb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Tamb = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twater", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Twater = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SavedTwater", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SavedTwater = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ph = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ch", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ch = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Wp = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpVolt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WpVolt = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_15Duration", wireType)
			}
			m.Over_15Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_15Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			m.Hour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hour |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *States) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: States: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: States: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Startup = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterOn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhOn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChOn = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Automatic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Automatic = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetActive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ntp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ntp = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rtc = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LightOn = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MqttConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MqttConnected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Versions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Versions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Versions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domopool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domopool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platformio", wireType)
			}
			m.Platformio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Platformio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspIdf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EspIdf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xtensa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Xtensa = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TftEspi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TftEspi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dallastemp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dallastemp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ads1115", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ads1115 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanopb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nanopb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mqtt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mqtt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Infos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Infos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Infos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoardName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BoardName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Versions == nil {
				m.Versions = &Versions{}
			}
			if err := m.Versions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sensors == nil {
				m.Sensors = &Sensors{}
			}
			if err := m.Sensors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Global == nil {
				m.Global = &Global{}
			}
			if err := m.Global.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pump", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pump == nil {
				m.Pump = &Pump{}
			}
			if err := m.Pump.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.States == nil {
				m.States = &States{}
			}
			if err := m.States.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alarms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alarms == nil {
				m.Alarms = &Alarms{}
			}
			if err := m.Alarms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tests == nil {
				m.Tests = &Tests{}
			}
			if err := m.Tests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infos == nil {
				m.Infos = &Infos{}
			}
			if err := m.Infos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &Limits{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RelayStates(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relay", wireType)
			}
			m.Relay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Relay |= RelayNames(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDomopool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDomopool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDomopool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDomopool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDomopool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDomopool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDomopool = fmt.Errorf("proto: unexpected end of group")
)
