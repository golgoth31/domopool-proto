// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: domopool.proto

package domopool_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FilterStates int32

const (
	FilterStates_def   FilterStates = 0
	FilterStates_auto  FilterStates = 1
	FilterStates_start FilterStates = 2
	FilterStates_stop  FilterStates = 3
)

var FilterStates_name = map[int32]string{
	0: "def",
	1: "auto",
	2: "start",
	3: "stop",
}

var FilterStates_value = map[string]int32{
	"def":   0,
	"auto":  1,
	"start": 2,
	"stop":  3,
}

func (x FilterStates) String() string {
	return proto.EnumName(FilterStates_name, int32(x))
}

func (FilterStates) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{0}
}

type NTP struct {
	DayLight             uint32   `protobuf:"varint,1,opt,name=day_light,json=dayLight,proto3" json:"day_light,omitempty"`
	Server               string   `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
	Timezone             uint32   `protobuf:"varint,3,opt,name=timezone,proto3" json:"timezone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NTP) Reset()         { *m = NTP{} }
func (m *NTP) String() string { return proto.CompactTextString(m) }
func (*NTP) ProtoMessage()    {}
func (*NTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{0}
}
func (m *NTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NTP.Merge(m, src)
}
func (m *NTP) XXX_Size() int {
	return m.Size()
}
func (m *NTP) XXX_DiscardUnknown() {
	xxx_messageInfo_NTP.DiscardUnknown(m)
}

var xxx_messageInfo_NTP proto.InternalMessageInfo

func (m *NTP) GetDayLight() uint32 {
	if m != nil {
		return m.DayLight
	}
	return 0
}

func (m *NTP) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *NTP) GetTimezone() uint32 {
	if m != nil {
		return m.Timezone
	}
	return 0
}

type Mqtt struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Server               string   `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Mqtt) Reset()         { *m = Mqtt{} }
func (m *Mqtt) String() string { return proto.CompactTextString(m) }
func (*Mqtt) ProtoMessage()    {}
func (*Mqtt) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{1}
}
func (m *Mqtt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mqtt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mqtt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mqtt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mqtt.Merge(m, src)
}
func (m *Mqtt) XXX_Size() int {
	return m.Size()
}
func (m *Mqtt) XXX_DiscardUnknown() {
	xxx_messageInfo_Mqtt.DiscardUnknown(m)
}

var xxx_messageInfo_Mqtt proto.InternalMessageInfo

func (m *Mqtt) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Mqtt) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

type Network struct {
	Dhcp                 bool     `protobuf:"varint,1,opt,name=dhcp,proto3" json:"dhcp,omitempty"`
	Ip                   string   `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Netmask              string   `protobuf:"bytes,3,opt,name=netmask,proto3" json:"netmask,omitempty"`
	Gateway              string   `protobuf:"bytes,4,opt,name=gateway,proto3" json:"gateway,omitempty"`
	Dns                  string   `protobuf:"bytes,5,opt,name=dns,proto3" json:"dns,omitempty"`
	AllowPost            bool     `protobuf:"varint,6,opt,name=allow_post,json=allowPost,proto3" json:"allow_post,omitempty"`
	Mqtt                 *Mqtt    `protobuf:"bytes,7,opt,name=mqtt,proto3" json:"mqtt,omitempty"`
	Ntp                  *NTP     `protobuf:"bytes,8,opt,name=ntp,proto3" json:"ntp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Network) Reset()         { *m = Network{} }
func (m *Network) String() string { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()    {}
func (*Network) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{2}
}
func (m *Network) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Network) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Network.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Network) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Network.Merge(m, src)
}
func (m *Network) XXX_Size() int {
	return m.Size()
}
func (m *Network) XXX_DiscardUnknown() {
	xxx_messageInfo_Network.DiscardUnknown(m)
}

var xxx_messageInfo_Network proto.InternalMessageInfo

func (m *Network) GetDhcp() bool {
	if m != nil {
		return m.Dhcp
	}
	return false
}

func (m *Network) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Network) GetNetmask() string {
	if m != nil {
		return m.Netmask
	}
	return ""
}

func (m *Network) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *Network) GetDns() string {
	if m != nil {
		return m.Dns
	}
	return ""
}

func (m *Network) GetAllowPost() bool {
	if m != nil {
		return m.AllowPost
	}
	return false
}

func (m *Network) GetMqtt() *Mqtt {
	if m != nil {
		return m.Mqtt
	}
	return nil
}

func (m *Network) GetNtp() *NTP {
	if m != nil {
		return m.Ntp
	}
	return nil
}

type Temp struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Init                 bool     `protobuf:"varint,2,opt,name=init,proto3" json:"init,omitempty"`
	Addr                 []uint32 `protobuf:"varint,8,rep,packed,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Temp) Reset()         { *m = Temp{} }
func (m *Temp) String() string { return proto.CompactTextString(m) }
func (*Temp) ProtoMessage()    {}
func (*Temp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{3}
}
func (m *Temp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Temp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Temp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Temp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Temp.Merge(m, src)
}
func (m *Temp) XXX_Size() int {
	return m.Size()
}
func (m *Temp) XXX_DiscardUnknown() {
	xxx_messageInfo_Temp.DiscardUnknown(m)
}

var xxx_messageInfo_Temp proto.InternalMessageInfo

func (m *Temp) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Temp) GetInit() bool {
	if m != nil {
		return m.Init
	}
	return false
}

func (m *Temp) GetAddr() []uint32 {
	if m != nil {
		return m.Addr
	}
	return nil
}

type Limits struct {
	WpMin float32 `protobuf:"fixed32,1,opt,name=wp_min,json=wpMin,proto3" json:"wp_min,omitempty"`
	WpMax float32 `protobuf:"fixed32,2,opt,name=wp_max,json=wpMax,proto3" json:"wp_max,omitempty"`
	PhMin float32 `protobuf:"fixed32,3,opt,name=ph_min,json=phMin,proto3" json:"ph_min,omitempty"`
	PhMax float32 `protobuf:"fixed32,4,opt,name=ph_max,json=phMax,proto3" json:"ph_max,omitempty"`
	ChMin float32 `protobuf:"fixed32,5,opt,name=ch_min,json=chMin,proto3" json:"ch_min,omitempty"`
	ChMax float32 `protobuf:"fixed32,6,opt,name=ch_max,json=chMax,proto3" json:"ch_max,omitempty"`
	// number of hour to wait when temp is above 15 to activate ch
	WaitBeforeCh uint32 `protobuf:"varint,7,opt,name=wait_before_ch,json=waitBeforeCh,proto3" json:"wait_before_ch,omitempty"`
	// temp threshold to activate ch
	ChTempThreshold float32 `protobuf:"fixed32,8,opt,name=ch_temp_threshold,json=chTempThreshold,proto3" json:"ch_temp_threshold,omitempty"`
	// temp threshold to reset ch wait time
	ChTempWaitReset      float32  `protobuf:"fixed32,9,opt,name=ch_temp_wait_reset,json=chTempWaitReset,proto3" json:"ch_temp_wait_reset,omitempty"`
	Wp_0Derive           float32  `protobuf:"fixed32,10,opt,name=wp_0_derive,json=wp0Derive,proto3" json:"wp_0_derive,omitempty"`
	TwMin                uint32   `protobuf:"varint,11,opt,name=tw_min,json=twMin,proto3" json:"tw_min,omitempty"`
	TwMax                uint32   `protobuf:"varint,12,opt,name=tw_max,json=twMax,proto3" json:"tw_max,omitempty"`
	TambMin              int32    `protobuf:"varint,13,opt,name=tamb_min,json=tambMin,proto3" json:"tamb_min,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Limits) Reset()         { *m = Limits{} }
func (m *Limits) String() string { return proto.CompactTextString(m) }
func (*Limits) ProtoMessage()    {}
func (*Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{4}
}
func (m *Limits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limits.Merge(m, src)
}
func (m *Limits) XXX_Size() int {
	return m.Size()
}
func (m *Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_Limits proto.InternalMessageInfo

func (m *Limits) GetWpMin() float32 {
	if m != nil {
		return m.WpMin
	}
	return 0
}

func (m *Limits) GetWpMax() float32 {
	if m != nil {
		return m.WpMax
	}
	return 0
}

func (m *Limits) GetPhMin() float32 {
	if m != nil {
		return m.PhMin
	}
	return 0
}

func (m *Limits) GetPhMax() float32 {
	if m != nil {
		return m.PhMax
	}
	return 0
}

func (m *Limits) GetChMin() float32 {
	if m != nil {
		return m.ChMin
	}
	return 0
}

func (m *Limits) GetChMax() float32 {
	if m != nil {
		return m.ChMax
	}
	return 0
}

func (m *Limits) GetWaitBeforeCh() uint32 {
	if m != nil {
		return m.WaitBeforeCh
	}
	return 0
}

func (m *Limits) GetChTempThreshold() float32 {
	if m != nil {
		return m.ChTempThreshold
	}
	return 0
}

func (m *Limits) GetChTempWaitReset() float32 {
	if m != nil {
		return m.ChTempWaitReset
	}
	return 0
}

func (m *Limits) GetWp_0Derive() float32 {
	if m != nil {
		return m.Wp_0Derive
	}
	return 0
}

func (m *Limits) GetTwMin() uint32 {
	if m != nil {
		return m.TwMin
	}
	return 0
}

func (m *Limits) GetTwMax() uint32 {
	if m != nil {
		return m.TwMax
	}
	return 0
}

func (m *Limits) GetTambMin() int32 {
	if m != nil {
		return m.TambMin
	}
	return 0
}

type AnalogSensor struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	AdcPin               uint32   `protobuf:"varint,3,opt,name=adc_pin,json=adcPin,proto3" json:"adc_pin,omitempty"`
	Threshold            float32  `protobuf:"fixed32,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	ThresholdAccuracy    uint32   `protobuf:"varint,4,opt,name=threshold_accuracy,json=thresholdAccuracy,proto3" json:"threshold_accuracy,omitempty"`
	Vmin                 float32  `protobuf:"fixed32,5,opt,name=vmin,proto3" json:"vmin,omitempty"`
	Vmax                 float32  `protobuf:"fixed32,6,opt,name=vmax,proto3" json:"vmax,omitempty"`
	PrecisionFactor      uint32   `protobuf:"varint,7,opt,name=precision_factor,json=precisionFactor,proto3" json:"precision_factor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalogSensor) Reset()         { *m = AnalogSensor{} }
func (m *AnalogSensor) String() string { return proto.CompactTextString(m) }
func (*AnalogSensor) ProtoMessage()    {}
func (*AnalogSensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{5}
}
func (m *AnalogSensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalogSensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalogSensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalogSensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalogSensor.Merge(m, src)
}
func (m *AnalogSensor) XXX_Size() int {
	return m.Size()
}
func (m *AnalogSensor) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalogSensor.DiscardUnknown(m)
}

var xxx_messageInfo_AnalogSensor proto.InternalMessageInfo

func (m *AnalogSensor) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AnalogSensor) GetAdcPin() uint32 {
	if m != nil {
		return m.AdcPin
	}
	return 0
}

func (m *AnalogSensor) GetThreshold() float32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *AnalogSensor) GetThresholdAccuracy() uint32 {
	if m != nil {
		return m.ThresholdAccuracy
	}
	return 0
}

func (m *AnalogSensor) GetVmin() float32 {
	if m != nil {
		return m.Vmin
	}
	return 0
}

func (m *AnalogSensor) GetVmax() float32 {
	if m != nil {
		return m.Vmax
	}
	return 0
}

func (m *AnalogSensor) GetPrecisionFactor() uint32 {
	if m != nil {
		return m.PrecisionFactor
	}
	return 0
}

type Sensors struct {
	Twin                 *Temp         `protobuf:"bytes,1,opt,name=twin,proto3" json:"twin,omitempty"`
	Twout                *Temp         `protobuf:"bytes,2,opt,name=twout,proto3" json:"twout,omitempty"`
	Tamb                 *Temp         `protobuf:"bytes,3,opt,name=tamb,proto3" json:"tamb,omitempty"`
	WaitForConversion    bool          `protobuf:"varint,4,opt,name=wait_for_conversion,json=waitForConversion,proto3" json:"wait_for_conversion,omitempty"`
	TempResolution       uint32        `protobuf:"varint,5,opt,name=temp_resolution,json=tempResolution,proto3" json:"temp_resolution,omitempty"`
	PrecisionFactor      uint32        `protobuf:"varint,6,opt,name=precision_factor,json=precisionFactor,proto3" json:"precision_factor,omitempty"`
	Ph                   *AnalogSensor `protobuf:"bytes,7,opt,name=ph,proto3" json:"ph,omitempty"`
	Ch                   *AnalogSensor `protobuf:"bytes,8,opt,name=ch,proto3" json:"ch,omitempty"`
	Wp                   *AnalogSensor `protobuf:"bytes,9,opt,name=wp,proto3" json:"wp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Sensors) Reset()         { *m = Sensors{} }
func (m *Sensors) String() string { return proto.CompactTextString(m) }
func (*Sensors) ProtoMessage()    {}
func (*Sensors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{6}
}
func (m *Sensors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sensors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sensors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sensors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sensors.Merge(m, src)
}
func (m *Sensors) XXX_Size() int {
	return m.Size()
}
func (m *Sensors) XXX_DiscardUnknown() {
	xxx_messageInfo_Sensors.DiscardUnknown(m)
}

var xxx_messageInfo_Sensors proto.InternalMessageInfo

func (m *Sensors) GetTwin() *Temp {
	if m != nil {
		return m.Twin
	}
	return nil
}

func (m *Sensors) GetTwout() *Temp {
	if m != nil {
		return m.Twout
	}
	return nil
}

func (m *Sensors) GetTamb() *Temp {
	if m != nil {
		return m.Tamb
	}
	return nil
}

func (m *Sensors) GetWaitForConversion() bool {
	if m != nil {
		return m.WaitForConversion
	}
	return false
}

func (m *Sensors) GetTempResolution() uint32 {
	if m != nil {
		return m.TempResolution
	}
	return 0
}

func (m *Sensors) GetPrecisionFactor() uint32 {
	if m != nil {
		return m.PrecisionFactor
	}
	return 0
}

func (m *Sensors) GetPh() *AnalogSensor {
	if m != nil {
		return m.Ph
	}
	return nil
}

func (m *Sensors) GetCh() *AnalogSensor {
	if m != nil {
		return m.Ch
	}
	return nil
}

func (m *Sensors) GetWp() *AnalogSensor {
	if m != nil {
		return m.Wp
	}
	return nil
}

type Global struct {
	LcdBacklightDuration uint32   `protobuf:"varint,1,opt,name=lcd_backlight_duration,json=lcdBacklightDuration,proto3" json:"lcd_backlight_duration,omitempty"`
	AckDuration          uint32   `protobuf:"varint,2,opt,name=ack_duration,json=ackDuration,proto3" json:"ack_duration,omitempty"`
	AckTone              float64  `protobuf:"fixed64,3,opt,name=ack_tone,json=ackTone,proto3" json:"ack_tone,omitempty"`
	SerialOut            bool     `protobuf:"varint,4,opt,name=serial_out,json=serialOut,proto3" json:"serial_out,omitempty"`
	DisplayStartup       bool     `protobuf:"varint,5,opt,name=display_startup,json=displayStartup,proto3" json:"display_startup,omitempty"`
	ForceLight           bool     `protobuf:"varint,6,opt,name=force_light,json=forceLight,proto3" json:"force_light,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Global) Reset()         { *m = Global{} }
func (m *Global) String() string { return proto.CompactTextString(m) }
func (*Global) ProtoMessage()    {}
func (*Global) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{7}
}
func (m *Global) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Global) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Global.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Global) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Global.Merge(m, src)
}
func (m *Global) XXX_Size() int {
	return m.Size()
}
func (m *Global) XXX_DiscardUnknown() {
	xxx_messageInfo_Global.DiscardUnknown(m)
}

var xxx_messageInfo_Global proto.InternalMessageInfo

func (m *Global) GetLcdBacklightDuration() uint32 {
	if m != nil {
		return m.LcdBacklightDuration
	}
	return 0
}

func (m *Global) GetAckDuration() uint32 {
	if m != nil {
		return m.AckDuration
	}
	return 0
}

func (m *Global) GetAckTone() float64 {
	if m != nil {
		return m.AckTone
	}
	return 0
}

func (m *Global) GetSerialOut() bool {
	if m != nil {
		return m.SerialOut
	}
	return false
}

func (m *Global) GetDisplayStartup() bool {
	if m != nil {
		return m.DisplayStartup
	}
	return false
}

func (m *Global) GetForceLight() bool {
	if m != nil {
		return m.ForceLight
	}
	return false
}

type Pump struct {
	ForceFilter          bool     `protobuf:"varint,1,opt,name=force_filter,json=forceFilter,proto3" json:"force_filter,omitempty"`
	ForcePh              bool     `protobuf:"varint,2,opt,name=force_ph,json=forcePh,proto3" json:"force_ph,omitempty"`
	ForceCh              bool     `protobuf:"varint,3,opt,name=force_ch,json=forceCh,proto3" json:"force_ch,omitempty"`
	Automatic            bool     `protobuf:"varint,4,opt,name=automatic,proto3" json:"automatic,omitempty"`
	ForceCheck           bool     `protobuf:"varint,5,opt,name=force_check,json=forceCheck,proto3" json:"force_check,omitempty"`
	ForceDuration        uint32   `protobuf:"varint,6,opt,name=force_duration,json=forceDuration,proto3" json:"force_duration,omitempty"`
	ForceStartTime       uint32   `protobuf:"varint,7,opt,name=force_start_time,json=forceStartTime,proto3" json:"force_start_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pump) Reset()         { *m = Pump{} }
func (m *Pump) String() string { return proto.CompactTextString(m) }
func (*Pump) ProtoMessage()    {}
func (*Pump) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{8}
}
func (m *Pump) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pump) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pump.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pump) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pump.Merge(m, src)
}
func (m *Pump) XXX_Size() int {
	return m.Size()
}
func (m *Pump) XXX_DiscardUnknown() {
	xxx_messageInfo_Pump.DiscardUnknown(m)
}

var xxx_messageInfo_Pump proto.InternalMessageInfo

func (m *Pump) GetForceFilter() bool {
	if m != nil {
		return m.ForceFilter
	}
	return false
}

func (m *Pump) GetForcePh() bool {
	if m != nil {
		return m.ForcePh
	}
	return false
}

func (m *Pump) GetForceCh() bool {
	if m != nil {
		return m.ForceCh
	}
	return false
}

func (m *Pump) GetAutomatic() bool {
	if m != nil {
		return m.Automatic
	}
	return false
}

func (m *Pump) GetForceCheck() bool {
	if m != nil {
		return m.ForceCheck
	}
	return false
}

func (m *Pump) GetForceDuration() uint32 {
	if m != nil {
		return m.ForceDuration
	}
	return 0
}

func (m *Pump) GetForceStartTime() uint32 {
	if m != nil {
		return m.ForceStartTime
	}
	return 0
}

type Ads115Alarms struct {
	NotReady             bool     `protobuf:"varint,1,opt,name=not_ready,json=notReady,proto3" json:"not_ready,omitempty"`
	NotStarted           bool     `protobuf:"varint,2,opt,name=not_started,json=notStarted,proto3" json:"not_started,omitempty"`
	NotConnected         bool     `protobuf:"varint,3,opt,name=not_connected,json=notConnected,proto3" json:"not_connected,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ads115Alarms) Reset()         { *m = Ads115Alarms{} }
func (m *Ads115Alarms) String() string { return proto.CompactTextString(m) }
func (*Ads115Alarms) ProtoMessage()    {}
func (*Ads115Alarms) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{9}
}
func (m *Ads115Alarms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ads115Alarms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ads115Alarms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ads115Alarms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ads115Alarms.Merge(m, src)
}
func (m *Ads115Alarms) XXX_Size() int {
	return m.Size()
}
func (m *Ads115Alarms) XXX_DiscardUnknown() {
	xxx_messageInfo_Ads115Alarms.DiscardUnknown(m)
}

var xxx_messageInfo_Ads115Alarms proto.InternalMessageInfo

func (m *Ads115Alarms) GetNotReady() bool {
	if m != nil {
		return m.NotReady
	}
	return false
}

func (m *Ads115Alarms) GetNotStarted() bool {
	if m != nil {
		return m.NotStarted
	}
	return false
}

func (m *Ads115Alarms) GetNotConnected() bool {
	if m != nil {
		return m.NotConnected
	}
	return false
}

type Alarms struct {
	Filter               bool          `protobuf:"varint,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Ph                   bool          `protobuf:"varint,2,opt,name=ph,proto3" json:"ph,omitempty"`
	Ch                   bool          `protobuf:"varint,3,opt,name=ch,proto3" json:"ch,omitempty"`
	Rtc                  bool          `protobuf:"varint,5,opt,name=rtc,proto3" json:"rtc,omitempty"`
	WpHigh               bool          `protobuf:"varint,6,opt,name=wp_high,json=wpHigh,proto3" json:"wp_high,omitempty"`
	WpLow                bool          `protobuf:"varint,7,opt,name=wp_low,json=wpLow,proto3" json:"wp_low,omitempty"`
	WpBroken             bool          `protobuf:"varint,8,opt,name=wp_broken,json=wpBroken,proto3" json:"wp_broken,omitempty"`
	Ads1115              *Ads115Alarms `protobuf:"bytes,9,opt,name=ads1115,proto3" json:"ads1115,omitempty"`
	TwFrost              bool          `protobuf:"varint,10,opt,name=tw_frost,json=twFrost,proto3" json:"tw_frost,omitempty"`
	TwHigh               bool          `protobuf:"varint,11,opt,name=tw_high,json=twHigh,proto3" json:"tw_high,omitempty"`
	TambFrost            bool          `protobuf:"varint,12,opt,name=tamb_frost,json=tambFrost,proto3" json:"tamb_frost,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Alarms) Reset()         { *m = Alarms{} }
func (m *Alarms) String() string { return proto.CompactTextString(m) }
func (*Alarms) ProtoMessage()    {}
func (*Alarms) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{10}
}
func (m *Alarms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alarms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alarms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alarms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alarms.Merge(m, src)
}
func (m *Alarms) XXX_Size() int {
	return m.Size()
}
func (m *Alarms) XXX_DiscardUnknown() {
	xxx_messageInfo_Alarms.DiscardUnknown(m)
}

var xxx_messageInfo_Alarms proto.InternalMessageInfo

func (m *Alarms) GetFilter() bool {
	if m != nil {
		return m.Filter
	}
	return false
}

func (m *Alarms) GetPh() bool {
	if m != nil {
		return m.Ph
	}
	return false
}

func (m *Alarms) GetCh() bool {
	if m != nil {
		return m.Ch
	}
	return false
}

func (m *Alarms) GetRtc() bool {
	if m != nil {
		return m.Rtc
	}
	return false
}

func (m *Alarms) GetWpHigh() bool {
	if m != nil {
		return m.WpHigh
	}
	return false
}

func (m *Alarms) GetWpLow() bool {
	if m != nil {
		return m.WpLow
	}
	return false
}

func (m *Alarms) GetWpBroken() bool {
	if m != nil {
		return m.WpBroken
	}
	return false
}

func (m *Alarms) GetAds1115() *Ads115Alarms {
	if m != nil {
		return m.Ads1115
	}
	return nil
}

func (m *Alarms) GetTwFrost() bool {
	if m != nil {
		return m.TwFrost
	}
	return false
}

func (m *Alarms) GetTwHigh() bool {
	if m != nil {
		return m.TwHigh
	}
	return false
}

func (m *Alarms) GetTambFrost() bool {
	if m != nil {
		return m.TambFrost
	}
	return false
}

type Tests struct {
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Twater               float32  `protobuf:"fixed32,2,opt,name=twater,proto3" json:"twater,omitempty"`
	Tamb                 float32  `protobuf:"fixed32,3,opt,name=tamb,proto3" json:"tamb,omitempty"`
	Ph                   float32  `protobuf:"fixed32,4,opt,name=ph,proto3" json:"ph,omitempty"`
	Pressure             float32  `protobuf:"fixed32,5,opt,name=pressure,proto3" json:"pressure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tests) Reset()         { *m = Tests{} }
func (m *Tests) String() string { return proto.CompactTextString(m) }
func (*Tests) ProtoMessage()    {}
func (*Tests) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{11}
}
func (m *Tests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tests.Merge(m, src)
}
func (m *Tests) XXX_Size() int {
	return m.Size()
}
func (m *Tests) XXX_DiscardUnknown() {
	xxx_messageInfo_Tests.DiscardUnknown(m)
}

var xxx_messageInfo_Tests proto.InternalMessageInfo

func (m *Tests) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Tests) GetTwater() float32 {
	if m != nil {
		return m.Twater
	}
	return 0
}

func (m *Tests) GetTamb() float32 {
	if m != nil {
		return m.Tamb
	}
	return 0
}

func (m *Tests) GetPh() float32 {
	if m != nil {
		return m.Ph
	}
	return 0
}

func (m *Tests) GetPressure() float32 {
	if m != nil {
		return m.Pressure
	}
	return 0
}

type Metrics struct {
	Tamb                 float32  `protobuf:"fixed32,1,opt,name=tamb,proto3" json:"tamb,omitempty"`
	Twater               float32  `protobuf:"fixed32,2,opt,name=twater,proto3" json:"twater,omitempty"`
	SavedTwater          float32  `protobuf:"fixed32,3,opt,name=saved_twater,json=savedTwater,proto3" json:"saved_twater,omitempty"`
	Ph                   float32  `protobuf:"fixed32,4,opt,name=ph,proto3" json:"ph,omitempty"`
	Ch                   float32  `protobuf:"fixed32,5,opt,name=ch,proto3" json:"ch,omitempty"`
	Wp                   float32  `protobuf:"fixed32,6,opt,name=wp,proto3" json:"wp,omitempty"`
	WpVolt               float32  `protobuf:"fixed32,7,opt,name=wp_volt,json=wpVolt,proto3" json:"wp_volt,omitempty"`
	Over_15Duration      uint32   `protobuf:"varint,8,opt,name=over_15_duration,json=over15Duration,proto3" json:"over_15_duration,omitempty"`
	Hour                 uint32   `protobuf:"varint,9,opt,name=hour,proto3" json:"hour,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{12}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetTamb() float32 {
	if m != nil {
		return m.Tamb
	}
	return 0
}

func (m *Metrics) GetTwater() float32 {
	if m != nil {
		return m.Twater
	}
	return 0
}

func (m *Metrics) GetSavedTwater() float32 {
	if m != nil {
		return m.SavedTwater
	}
	return 0
}

func (m *Metrics) GetPh() float32 {
	if m != nil {
		return m.Ph
	}
	return 0
}

func (m *Metrics) GetCh() float32 {
	if m != nil {
		return m.Ch
	}
	return 0
}

func (m *Metrics) GetWp() float32 {
	if m != nil {
		return m.Wp
	}
	return 0
}

func (m *Metrics) GetWpVolt() float32 {
	if m != nil {
		return m.WpVolt
	}
	return 0
}

func (m *Metrics) GetOver_15Duration() uint32 {
	if m != nil {
		return m.Over_15Duration
	}
	return 0
}

func (m *Metrics) GetHour() uint32 {
	if m != nil {
		return m.Hour
	}
	return 0
}

type States struct {
	Startup              bool     `protobuf:"varint,1,opt,name=startup,proto3" json:"startup,omitempty"`
	FilterOn             bool     `protobuf:"varint,2,opt,name=filter_on,json=filterOn,proto3" json:"filter_on,omitempty"`
	PhOn                 bool     `protobuf:"varint,3,opt,name=ph_on,json=phOn,proto3" json:"ph_on,omitempty"`
	ChOn                 bool     `protobuf:"varint,4,opt,name=ch_on,json=chOn,proto3" json:"ch_on,omitempty"`
	Automatic            bool     `protobuf:"varint,5,opt,name=automatic,proto3" json:"automatic,omitempty"`
	NetActive            bool     `protobuf:"varint,6,opt,name=net_active,json=netActive,proto3" json:"net_active,omitempty"`
	Ntp                  bool     `protobuf:"varint,7,opt,name=ntp,proto3" json:"ntp,omitempty"`
	Rtc                  bool     `protobuf:"varint,8,opt,name=rtc,proto3" json:"rtc,omitempty"`
	LightOn              bool     `protobuf:"varint,9,opt,name=light_on,json=lightOn,proto3" json:"light_on,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *States) Reset()         { *m = States{} }
func (m *States) String() string { return proto.CompactTextString(m) }
func (*States) ProtoMessage()    {}
func (*States) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{13}
}
func (m *States) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *States) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_States.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *States) XXX_Merge(src proto.Message) {
	xxx_messageInfo_States.Merge(m, src)
}
func (m *States) XXX_Size() int {
	return m.Size()
}
func (m *States) XXX_DiscardUnknown() {
	xxx_messageInfo_States.DiscardUnknown(m)
}

var xxx_messageInfo_States proto.InternalMessageInfo

func (m *States) GetStartup() bool {
	if m != nil {
		return m.Startup
	}
	return false
}

func (m *States) GetFilterOn() bool {
	if m != nil {
		return m.FilterOn
	}
	return false
}

func (m *States) GetPhOn() bool {
	if m != nil {
		return m.PhOn
	}
	return false
}

func (m *States) GetChOn() bool {
	if m != nil {
		return m.ChOn
	}
	return false
}

func (m *States) GetAutomatic() bool {
	if m != nil {
		return m.Automatic
	}
	return false
}

func (m *States) GetNetActive() bool {
	if m != nil {
		return m.NetActive
	}
	return false
}

func (m *States) GetNtp() bool {
	if m != nil {
		return m.Ntp
	}
	return false
}

func (m *States) GetRtc() bool {
	if m != nil {
		return m.Rtc
	}
	return false
}

func (m *States) GetLightOn() bool {
	if m != nil {
		return m.LightOn
	}
	return false
}

type Versions struct {
	Domopool             string   `protobuf:"bytes,1,opt,name=domopool,proto3" json:"domopool,omitempty"`
	Platformio           uint32   `protobuf:"varint,2,opt,name=platformio,proto3" json:"platformio,omitempty"`
	EspIdf               string   `protobuf:"bytes,3,opt,name=esp_idf,json=espIdf,proto3" json:"esp_idf,omitempty"`
	Xtensa               string   `protobuf:"bytes,4,opt,name=xtensa,proto3" json:"xtensa,omitempty"`
	TftEspi              string   `protobuf:"bytes,6,opt,name=tft_espi,json=tftEspi,proto3" json:"tft_espi,omitempty"`
	Dallastemp           string   `protobuf:"bytes,7,opt,name=dallastemp,proto3" json:"dallastemp,omitempty"`
	Ads1115              string   `protobuf:"bytes,8,opt,name=ads1115,proto3" json:"ads1115,omitempty"`
	Nanopb               string   `protobuf:"bytes,9,opt,name=nanopb,proto3" json:"nanopb,omitempty"`
	Mqtt                 string   `protobuf:"bytes,10,opt,name=mqtt,proto3" json:"mqtt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Versions) Reset()         { *m = Versions{} }
func (m *Versions) String() string { return proto.CompactTextString(m) }
func (*Versions) ProtoMessage()    {}
func (*Versions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{14}
}
func (m *Versions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Versions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Versions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Versions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Versions.Merge(m, src)
}
func (m *Versions) XXX_Size() int {
	return m.Size()
}
func (m *Versions) XXX_DiscardUnknown() {
	xxx_messageInfo_Versions.DiscardUnknown(m)
}

var xxx_messageInfo_Versions proto.InternalMessageInfo

func (m *Versions) GetDomopool() string {
	if m != nil {
		return m.Domopool
	}
	return ""
}

func (m *Versions) GetPlatformio() uint32 {
	if m != nil {
		return m.Platformio
	}
	return 0
}

func (m *Versions) GetEspIdf() string {
	if m != nil {
		return m.EspIdf
	}
	return ""
}

func (m *Versions) GetXtensa() string {
	if m != nil {
		return m.Xtensa
	}
	return ""
}

func (m *Versions) GetTftEspi() string {
	if m != nil {
		return m.TftEspi
	}
	return ""
}

func (m *Versions) GetDallastemp() string {
	if m != nil {
		return m.Dallastemp
	}
	return ""
}

func (m *Versions) GetAds1115() string {
	if m != nil {
		return m.Ads1115
	}
	return ""
}

func (m *Versions) GetNanopb() string {
	if m != nil {
		return m.Nanopb
	}
	return ""
}

func (m *Versions) GetMqtt() string {
	if m != nil {
		return m.Mqtt
	}
	return ""
}

type Infos struct {
	Compile              string    `protobuf:"bytes,1,opt,name=compile,proto3" json:"compile,omitempty"`
	BoardName            string    `protobuf:"bytes,2,opt,name=board_name,json=boardName,proto3" json:"board_name,omitempty"`
	Versions             *Versions `protobuf:"bytes,3,opt,name=versions,proto3" json:"versions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Infos) Reset()         { *m = Infos{} }
func (m *Infos) String() string { return proto.CompactTextString(m) }
func (*Infos) ProtoMessage()    {}
func (*Infos) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{15}
}
func (m *Infos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Infos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Infos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Infos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Infos.Merge(m, src)
}
func (m *Infos) XXX_Size() int {
	return m.Size()
}
func (m *Infos) XXX_DiscardUnknown() {
	xxx_messageInfo_Infos.DiscardUnknown(m)
}

var xxx_messageInfo_Infos proto.InternalMessageInfo

func (m *Infos) GetCompile() string {
	if m != nil {
		return m.Compile
	}
	return ""
}

func (m *Infos) GetBoardName() string {
	if m != nil {
		return m.BoardName
	}
	return ""
}

func (m *Infos) GetVersions() *Versions {
	if m != nil {
		return m.Versions
	}
	return nil
}

type Config struct {
	Network              *Network `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Sensors              *Sensors `protobuf:"bytes,2,opt,name=sensors,proto3" json:"sensors,omitempty"`
	Global               *Global  `protobuf:"bytes,3,opt,name=global,proto3" json:"global,omitempty"`
	Pump                 *Pump    `protobuf:"bytes,5,opt,name=pump,proto3" json:"pump,omitempty"`
	Metrics              *Metrics `protobuf:"bytes,6,opt,name=metrics,proto3" json:"metrics,omitempty"`
	States               *States  `protobuf:"bytes,7,opt,name=states,proto3" json:"states,omitempty"`
	Alarms               *Alarms  `protobuf:"bytes,8,opt,name=alarms,proto3" json:"alarms,omitempty"`
	Tests                *Tests   `protobuf:"bytes,9,opt,name=tests,proto3" json:"tests,omitempty"`
	Infos                *Infos   `protobuf:"bytes,10,opt,name=infos,proto3" json:"infos,omitempty"`
	Limits               *Limits  `protobuf:"bytes,11,opt,name=limits,proto3" json:"limits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{16}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Config) GetSensors() *Sensors {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *Config) GetGlobal() *Global {
	if m != nil {
		return m.Global
	}
	return nil
}

func (m *Config) GetPump() *Pump {
	if m != nil {
		return m.Pump
	}
	return nil
}

func (m *Config) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Config) GetStates() *States {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Config) GetAlarms() *Alarms {
	if m != nil {
		return m.Alarms
	}
	return nil
}

func (m *Config) GetTests() *Tests {
	if m != nil {
		return m.Tests
	}
	return nil
}

func (m *Config) GetInfos() *Infos {
	if m != nil {
		return m.Infos
	}
	return nil
}

func (m *Config) GetLimits() *Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

type Filter struct {
	State                FilterStates `protobuf:"varint,1,opt,name=state,proto3,enum=domopool.FilterStates" json:"state,omitempty"`
	Duration             uint32       `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	StartTime            uint32       `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{17}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetState() FilterStates {
	if m != nil {
		return m.State
	}
	return FilterStates_def
}

func (m *Filter) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Filter) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

type Switch struct {
	State                FilterStates `protobuf:"varint,1,opt,name=state,proto3,enum=domopool.FilterStates" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Switch) Reset()         { *m = Switch{} }
func (m *Switch) String() string { return proto.CompactTextString(m) }
func (*Switch) ProtoMessage()    {}
func (*Switch) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d32c57b52397a6e, []int{18}
}
func (m *Switch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Switch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Switch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Switch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Switch.Merge(m, src)
}
func (m *Switch) XXX_Size() int {
	return m.Size()
}
func (m *Switch) XXX_DiscardUnknown() {
	xxx_messageInfo_Switch.DiscardUnknown(m)
}

var xxx_messageInfo_Switch proto.InternalMessageInfo

func (m *Switch) GetState() FilterStates {
	if m != nil {
		return m.State
	}
	return FilterStates_def
}

func init() {
	proto.RegisterEnum("domopool.FilterStates", FilterStates_name, FilterStates_value)
	proto.RegisterType((*NTP)(nil), "domopool.NTP")
	proto.RegisterType((*Mqtt)(nil), "domopool.Mqtt")
	proto.RegisterType((*Network)(nil), "domopool.Network")
	proto.RegisterType((*Temp)(nil), "domopool.Temp")
	proto.RegisterType((*Limits)(nil), "domopool.Limits")
	proto.RegisterType((*AnalogSensor)(nil), "domopool.AnalogSensor")
	proto.RegisterType((*Sensors)(nil), "domopool.Sensors")
	proto.RegisterType((*Global)(nil), "domopool.Global")
	proto.RegisterType((*Pump)(nil), "domopool.Pump")
	proto.RegisterType((*Ads115Alarms)(nil), "domopool.Ads115Alarms")
	proto.RegisterType((*Alarms)(nil), "domopool.Alarms")
	proto.RegisterType((*Tests)(nil), "domopool.Tests")
	proto.RegisterType((*Metrics)(nil), "domopool.Metrics")
	proto.RegisterType((*States)(nil), "domopool.States")
	proto.RegisterType((*Versions)(nil), "domopool.Versions")
	proto.RegisterType((*Infos)(nil), "domopool.Infos")
	proto.RegisterType((*Config)(nil), "domopool.Config")
	proto.RegisterType((*Filter)(nil), "domopool.Filter")
	proto.RegisterType((*Switch)(nil), "domopool.Switch")
}

func init() { proto.RegisterFile("domopool.proto", fileDescriptor_6d32c57b52397a6e) }

var fileDescriptor_6d32c57b52397a6e = []byte{
	// 1848 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x67, 0xbe, 0x7b, 0x9e, 0x3d, 0x13, 0xa7, 0x16, 0xbc, 0x93, 0x40, 0xbc, 0xde, 0x61, 0x17,
	0xcc, 0xae, 0xe2, 0xc4, 0x59, 0xa2, 0x45, 0xe2, 0x82, 0xe3, 0x25, 0xec, 0x4a, 0xf9, 0xb0, 0xca,
	0x56, 0x90, 0xb8, 0xb4, 0x6a, 0xaa, 0x6b, 0xa6, 0x5b, 0xd3, 0xdd, 0x55, 0xe9, 0xae, 0x71, 0xdb,
	0xfc, 0x3d, 0x5c, 0xf8, 0x4f, 0x38, 0x72, 0xe3, 0x08, 0x44, 0xe2, 0xcc, 0x81, 0x0b, 0xe2, 0x84,
	0xde, 0xab, 0xea, 0x9e, 0x99, 0x90, 0x44, 0xe2, 0x34, 0xfd, 0x7e, 0xef, 0x57, 0x1f, 0xef, 0xa3,
	0xde, 0x7b, 0x03, 0xe3, 0x48, 0x67, 0xda, 0x68, 0x9d, 0x1e, 0x9b, 0x42, 0x5b, 0xcd, 0x82, 0x5a,
	0xbe, 0x7b, 0x7f, 0x91, 0xd8, 0x78, 0x35, 0x3b, 0x96, 0x3a, 0x7b, 0xb0, 0xd0, 0x0b, 0xfd, 0x80,
	0x08, 0xb3, 0xd5, 0x9c, 0x24, 0x12, 0xe8, 0xcb, 0x2d, 0x9c, 0xbe, 0x82, 0xce, 0x8b, 0xcb, 0x73,
	0xf6, 0x43, 0x18, 0x46, 0xe2, 0x26, 0x4c, 0x93, 0x45, 0x6c, 0x27, 0xad, 0xc3, 0xd6, 0xd1, 0x88,
	0x07, 0x91, 0xb8, 0x79, 0x86, 0x32, 0xdb, 0x87, 0x7e, 0xa9, 0x8a, 0x2b, 0x55, 0x4c, 0xda, 0x87,
	0xad, 0xa3, 0x21, 0xf7, 0x12, 0xbb, 0x0b, 0x81, 0x4d, 0x32, 0xf5, 0x7b, 0x9d, 0xab, 0x49, 0xc7,
	0xad, 0xa9, 0xe5, 0xe9, 0x2f, 0xa0, 0xfb, 0xfc, 0xb5, 0xb5, 0x6c, 0x02, 0x03, 0x95, 0x8b, 0x59,
	0xaa, 0x22, 0xda, 0x36, 0xe0, 0xb5, 0xf8, 0xbe, 0x5d, 0xa7, 0x7f, 0x69, 0xc1, 0xe0, 0x85, 0xb2,
	0x95, 0x2e, 0x96, 0x8c, 0x41, 0x37, 0x8a, 0xa5, 0xf1, 0x4b, 0xe9, 0x9b, 0x8d, 0xa1, 0x9d, 0x18,
	0xbf, 0xa6, 0x9d, 0x18, 0x3c, 0x21, 0x57, 0x36, 0x13, 0xe5, 0x92, 0x2e, 0x31, 0xe4, 0xb5, 0x88,
	0x9a, 0x85, 0xb0, 0xaa, 0x12, 0x37, 0x93, 0xae, 0xd3, 0x78, 0x91, 0xed, 0x41, 0x27, 0xca, 0xcb,
	0x49, 0x8f, 0x50, 0xfc, 0x64, 0xf7, 0x00, 0x44, 0x9a, 0xea, 0x2a, 0x34, 0xba, 0xb4, 0x93, 0x3e,
	0x9d, 0x37, 0x24, 0xe4, 0x5c, 0x97, 0x96, 0x4d, 0xa1, 0x9b, 0xbd, 0xb6, 0x76, 0x32, 0x38, 0x6c,
	0x1d, 0xed, 0x3c, 0x1a, 0x1f, 0x37, 0xee, 0x47, 0x23, 0x39, 0xe9, 0xd8, 0x27, 0xd0, 0xc9, 0xad,
	0x99, 0x04, 0x44, 0x19, 0xad, 0x29, 0x2f, 0x2e, 0xcf, 0x39, 0x6a, 0xa6, 0xdf, 0x42, 0xf7, 0x52,
	0x65, 0xe6, 0x03, 0x3e, 0x61, 0xd0, 0x4d, 0xf2, 0xc4, 0x92, 0x75, 0x01, 0xa7, 0x6f, 0xc4, 0x44,
	0x14, 0x15, 0x93, 0xe0, 0xb0, 0x73, 0x34, 0xe2, 0xf4, 0x3d, 0xfd, 0x4f, 0x1b, 0xfa, 0xcf, 0x92,
	0x2c, 0xb1, 0x25, 0xfb, 0x01, 0xf4, 0x2b, 0x13, 0x66, 0x49, 0x4e, 0x7b, 0xb5, 0x79, 0xaf, 0x32,
	0xcf, 0x93, 0xbc, 0x86, 0xc5, 0x35, 0xed, 0xe5, 0x60, 0x71, 0x8d, 0xb0, 0x89, 0x89, 0xdd, 0x71,
	0xb0, 0x89, 0x3d, 0x1b, 0x61, 0x71, 0x4d, 0x8e, 0x72, 0xb0, 0x63, 0x4b, 0xc7, 0xee, 0x39, 0x58,
	0xd6, 0x6c, 0xe9, 0xd8, 0xfd, 0x06, 0x16, 0xd7, 0xec, 0x33, 0x18, 0x57, 0x22, 0xb1, 0xe1, 0x4c,
	0xcd, 0x75, 0xa1, 0x42, 0x19, 0x93, 0xb7, 0x46, 0x7c, 0x17, 0xd1, 0x27, 0x04, 0x9e, 0xc5, 0xec,
	0x0b, 0xb8, 0x2d, 0xe3, 0xd0, 0xaa, 0xcc, 0x84, 0x36, 0x2e, 0x54, 0x19, 0xeb, 0x34, 0x22, 0x9f,
	0xb5, 0xf9, 0x2d, 0x19, 0xa3, 0x7f, 0x2e, 0x6b, 0x98, 0x7d, 0x09, 0xac, 0xe6, 0xd2, 0xce, 0x85,
	0x2a, 0x95, 0x9d, 0x0c, 0x37, 0xc9, 0xbf, 0x15, 0x89, 0xe5, 0x08, 0xb3, 0x03, 0xd8, 0xa9, 0x4c,
	0xf8, 0x30, 0x8c, 0x54, 0x91, 0x5c, 0xa9, 0x09, 0x10, 0x6b, 0x58, 0x99, 0x87, 0xdf, 0x10, 0x80,
	0xb7, 0xb6, 0x15, 0x19, 0xb3, 0x43, 0xd7, 0xea, 0xd9, 0xca, 0x1b, 0x83, 0xb0, 0xb8, 0x9e, 0xec,
	0x36, 0xb0, 0xb8, 0x66, 0x77, 0x20, 0xb0, 0x22, 0x9b, 0x11, 0x7f, 0x74, 0xd8, 0x3a, 0xea, 0xf1,
	0x01, 0xca, 0xcf, 0x93, 0x7c, 0xfa, 0xf7, 0x16, 0xec, 0x9e, 0xe6, 0x22, 0xd5, 0x8b, 0x0b, 0x95,
	0x97, 0xba, 0xf8, 0x40, 0x3c, 0x3f, 0x86, 0x81, 0x88, 0x64, 0x68, 0xbc, 0xbf, 0x47, 0xbc, 0x2f,
	0x22, 0x79, 0x9e, 0xe4, 0xec, 0x47, 0x30, 0x5c, 0x5b, 0xef, 0x22, 0xb4, 0x06, 0xd8, 0x7d, 0x60,
	0x8d, 0x10, 0x0a, 0x29, 0x57, 0x85, 0x90, 0x2e, 0x87, 0x47, 0xfc, 0x76, 0xa3, 0x39, 0xf5, 0x0a,
	0xcc, 0x90, 0xab, 0x75, 0x90, 0xe8, 0xdb, 0x61, 0x4d, 0x84, 0xe8, 0x9b, 0xfd, 0x0c, 0xf6, 0x4c,
	0xa1, 0x64, 0x52, 0x26, 0x3a, 0x0f, 0xe7, 0x42, 0x5a, 0x5d, 0xf8, 0x10, 0xdd, 0x6a, 0xf0, 0xa7,
	0x04, 0x4f, 0xff, 0xd5, 0x86, 0x81, 0xb3, 0xae, 0xc4, 0xdc, 0xb7, 0x95, 0xcf, 0xaf, 0xad, 0xdc,
	0x47, 0xff, 0x73, 0xd2, 0xb1, 0xcf, 0xa0, 0x67, 0x2b, 0xbd, 0x72, 0x99, 0xfb, 0xbf, 0x24, 0xa7,
	0xa4, 0x9d, 0x44, 0x36, 0x23, 0x5f, 0xbc, 0x6b, 0x27, 0x91, 0xcd, 0xd8, 0x31, 0x7c, 0x44, 0xb1,
	0x9e, 0xeb, 0x22, 0x94, 0x3a, 0xbf, 0x52, 0x05, 0x5e, 0x8b, 0x8c, 0x0f, 0xf8, 0x6d, 0x54, 0x3d,
	0xd5, 0xc5, 0x59, 0xa3, 0x60, 0x3f, 0x85, 0x5b, 0x94, 0x20, 0x85, 0x2a, 0x75, 0xba, 0xb2, 0xc8,
	0xed, 0x91, 0x4d, 0x63, 0x84, 0x79, 0x83, 0xbe, 0xd3, 0xfa, 0xfe, 0x3b, 0xad, 0x67, 0x3f, 0x81,
	0xb6, 0x89, 0xfd, 0x5b, 0xdf, 0x5f, 0xdf, 0x72, 0x33, 0xe8, 0xbc, 0x6d, 0x62, 0xe4, 0xc9, 0xd8,
	0x3f, 0xf8, 0xf7, 0xf2, 0x24, 0xf1, 0x2a, 0x43, 0x79, 0xfb, 0x01, 0x5e, 0x65, 0xa6, 0xff, 0x68,
	0x41, 0xff, 0x37, 0xa9, 0x9e, 0x89, 0x94, 0xfd, 0x1c, 0xf6, 0x53, 0x19, 0x85, 0x33, 0x21, 0x97,
	0x54, 0x94, 0xc3, 0x68, 0x55, 0x08, 0xb2, 0xce, 0x55, 0xe7, 0xef, 0xa7, 0x32, 0x7a, 0x52, 0x2b,
	0xbf, 0xf1, 0x3a, 0xf6, 0x29, 0xec, 0x0a, 0xb9, 0x5c, 0x73, 0xdb, 0xc4, 0xdd, 0x11, 0x72, 0xd9,
	0x50, 0xee, 0x40, 0x80, 0x14, 0x5b, 0x17, 0xed, 0x16, 0x1f, 0x08, 0xb9, 0xbc, 0xd4, 0xb9, 0xc2,
	0x1a, 0x58, 0xaa, 0x22, 0x11, 0x69, 0x88, 0x91, 0x74, 0x1e, 0x1f, 0x3a, 0xe4, 0xe5, 0xca, 0xa2,
	0xa7, 0xa3, 0xa4, 0x34, 0xa9, 0xb8, 0x09, 0x4b, 0x2b, 0x0a, 0xbb, 0x32, 0xe4, 0xe9, 0x80, 0x8f,
	0x3d, 0x7c, 0xe1, 0x50, 0xf6, 0x09, 0xec, 0xcc, 0x75, 0x21, 0x95, 0x6f, 0x27, 0xae, 0x98, 0x02,
	0x41, 0xd4, 0x50, 0xa6, 0xff, 0x6c, 0x41, 0xf7, 0x7c, 0x95, 0x19, 0xbc, 0xaf, 0x63, 0xce, 0x93,
	0xd4, 0xaa, 0xc2, 0x3f, 0x1f, 0xb7, 0xfa, 0x29, 0x41, 0x78, 0x5f, 0x47, 0x31, 0xb1, 0x2f, 0x8b,
	0x03, 0x92, 0xcf, 0xe3, 0xb5, 0x4a, 0xc6, 0x64, 0x4a, 0xad, 0x3a, 0x8b, 0xf1, 0x7d, 0x89, 0x95,
	0xd5, 0x99, 0xb0, 0x89, 0xac, 0x2d, 0x69, 0x80, 0xf5, 0x05, 0x65, 0xac, 0xe4, 0xd2, 0x5b, 0x01,
	0x7e, 0xad, 0x92, 0x4b, 0xf6, 0x39, 0x8c, 0x1d, 0xa1, 0xf1, 0xa4, 0xcb, 0x94, 0x11, 0xa1, 0x8d,
	0x2f, 0x8f, 0x60, 0xcf, 0xd1, 0xc8, 0x1f, 0x21, 0x36, 0x3f, 0xff, 0xa0, 0xdc, 0x72, 0x72, 0xc8,
	0x65, 0x92, 0xa9, 0xe9, 0x6b, 0xd8, 0x3d, 0x8d, 0xca, 0x93, 0x93, 0xc7, 0xa7, 0xa9, 0x28, 0xb2,
	0x12, 0xfb, 0x6d, 0xae, 0xb1, 0xa0, 0x89, 0xe8, 0xc6, 0x5b, 0x1d, 0xe4, 0xda, 0x72, 0x94, 0xf1,
	0x7a, 0xa8, 0xa4, 0x4d, 0x55, 0xe4, 0xad, 0x86, 0x5c, 0xdb, 0x0b, 0x87, 0xb0, 0x1f, 0xc3, 0x08,
	0x09, 0x52, 0xe7, 0xb9, 0x92, 0x48, 0x71, 0xd6, 0xef, 0xe6, 0xda, 0x9e, 0xd5, 0xd8, 0xf4, 0x0f,
	0x6d, 0xe8, 0xfb, 0xd3, 0xf6, 0xa1, 0xbf, 0xe5, 0x60, 0x2f, 0x61, 0x2b, 0x6d, 0xbc, 0x8a, 0xf9,
	0x3c, 0xa6, 0x7c, 0x76, 0x9b, 0x61, 0xde, 0xee, 0x41, 0xa7, 0xb0, 0xd2, 0xfb, 0x07, 0x3f, 0xb1,
	0xa0, 0x55, 0x26, 0x8c, 0x93, 0x45, 0xec, 0xc3, 0xda, 0xaf, 0xcc, 0xb7, 0xc9, 0x22, 0xf6, 0xfd,
	0x26, 0xd5, 0x15, 0x39, 0x20, 0xc0, 0x7e, 0xf3, 0x4c, 0x57, 0x68, 0x67, 0x65, 0xc2, 0x59, 0xa1,
	0x97, 0x2a, 0xa7, 0x87, 0x12, 0xf0, 0xa0, 0x32, 0x4f, 0x48, 0x66, 0x0f, 0xb1, 0x3a, 0x96, 0x27,
	0x27, 0x27, 0x8f, 0xdf, 0xf1, 0x36, 0x36, 0xbc, 0xc5, 0x6b, 0x1a, 0x55, 0xe5, 0x2a, 0x9c, 0x17,
	0xd8, 0xa3, 0xc1, 0x45, 0xdc, 0x56, 0x4f, 0x51, 0xc4, 0x9b, 0xd9, 0xca, 0xdd, 0x6c, 0xc7, 0xdd,
	0xcc, 0x56, 0x74, 0xb3, 0x7b, 0x00, 0x54, 0xc9, 0xdd, 0xaa, 0x5d, 0x97, 0x0b, 0x88, 0xd0, 0xba,
	0xe9, 0x0d, 0xf4, 0x2e, 0x55, 0x69, 0xcb, 0x0f, 0x4f, 0x2a, 0xb6, 0x12, 0xd6, 0x4f, 0x2a, 0x6d,
	0xee, 0x25, 0xac, 0xb1, 0x4d, 0x39, 0x6b, 0xfb, 0xf2, 0xe5, 0x5c, 0xea, 0xba, 0x28, 0xba, 0xf4,
	0x2e, 0x04, 0xa6, 0x50, 0x65, 0xb9, 0x2a, 0x94, 0xaf, 0xcf, 0x8d, 0x3c, 0xfd, 0x6b, 0x0b, 0x06,
	0xcf, 0x95, 0x2d, 0x12, 0x59, 0x36, 0x7b, 0xb5, 0x36, 0xf6, 0x7a, 0xdf, 0xb9, 0x9f, 0xc2, 0x6e,
	0x29, 0xae, 0x54, 0x14, 0x7a, 0xad, 0x3b, 0x7f, 0x87, 0xb0, 0x4b, 0x47, 0x79, 0xfb, 0x1a, 0x2e,
	0xb2, 0xee, 0x02, 0x18, 0xd9, 0x31, 0x55, 0x24, 0xd7, 0x1c, 0xda, 0x95, 0xf1, 0x71, 0xbd, 0xd2,
	0xa9, 0x1b, 0x71, 0xda, 0x18, 0xd7, 0x57, 0x3a, 0xb5, 0x98, 0xe2, 0xfa, 0x4a, 0x15, 0xe1, 0xc9,
	0xe3, 0xf5, 0x5b, 0x08, 0x5c, 0x8a, 0x23, 0x7e, 0xf2, 0xb8, 0x79, 0x0c, 0x0c, 0xba, 0xb1, 0x5e,
	0x15, 0x14, 0xca, 0x11, 0xa7, 0x6f, 0x2a, 0x68, 0x17, 0x56, 0x58, 0x45, 0xee, 0xad, 0xab, 0x86,
	0x77, 0xaf, 0x17, 0x31, 0x47, 0x5c, 0x3e, 0x86, 0xbe, 0x62, 0x05, 0x3c, 0x70, 0xc0, 0xcb, 0x9c,
	0x7d, 0x04, 0x3d, 0x13, 0xa3, 0xc2, 0x65, 0x65, 0xd7, 0xc4, 0x0e, 0x94, 0x04, 0xba, 0x97, 0xdd,
	0x95, 0x08, 0x6e, 0x3d, 0xf9, 0xde, 0xdb, 0x4f, 0xfe, 0x1e, 0x40, 0xae, 0x6c, 0x28, 0xa4, 0xc5,
	0xe1, 0xc0, 0xcf, 0x77, 0xb9, 0xb2, 0xa7, 0x04, 0x60, 0xa6, 0xe3, 0xec, 0xe6, 0x72, 0x17, 0x3f,
	0xeb, 0xdc, 0x0f, 0xd6, 0xb9, 0x7f, 0x07, 0x02, 0x57, 0x8a, 0x75, 0x4e, 0x46, 0x06, 0x7c, 0x40,
	0xf2, 0xcb, 0x7c, 0xfa, 0xef, 0x16, 0x04, 0xaf, 0x5c, 0x43, 0x2a, 0x31, 0xe4, 0x75, 0x1a, 0x93,
	0xa9, 0x43, 0xde, 0xc8, 0xec, 0x00, 0xc0, 0xa4, 0xc2, 0xce, 0x75, 0x91, 0x25, 0xda, 0x97, 0xe7,
	0x0d, 0x04, 0xe3, 0xa0, 0x4a, 0x13, 0x26, 0xd1, 0xdc, 0x0f, 0xb3, 0x7d, 0x55, 0x9a, 0xef, 0xa2,
	0x39, 0xe6, 0xc2, 0xb5, 0x55, 0x79, 0x29, 0xfc, 0x28, 0xeb, 0x25, 0x7a, 0x11, 0x73, 0x1b, 0xaa,
	0xd2, 0x24, 0x64, 0xd5, 0x90, 0x0f, 0xec, 0xdc, 0xfe, 0xba, 0x34, 0x09, 0x9e, 0x15, 0x89, 0x34,
	0x15, 0x25, 0x36, 0x42, 0x32, 0x6d, 0xc8, 0x37, 0x10, 0x8c, 0x48, 0xfd, 0xfc, 0x02, 0xb7, 0xb2,
	0x7e, 0x66, 0xfb, 0xd0, 0xcf, 0x45, 0xae, 0xcd, 0x8c, 0xec, 0x1c, 0x72, 0x2f, 0x61, 0x88, 0x69,
	0x0a, 0x06, 0x42, 0xe9, 0x7b, 0x6a, 0xa0, 0xf7, 0x5d, 0x3e, 0xd7, 0x14, 0x60, 0xa9, 0x33, 0x93,
	0xa4, 0xca, 0x5b, 0x5d, 0x8b, 0xe8, 0xfb, 0x99, 0x16, 0x45, 0x14, 0xe6, 0x22, 0x53, 0x7e, 0x72,
	0x1f, 0x12, 0xf2, 0x42, 0x64, 0x8a, 0x1d, 0x43, 0xe0, 0x9b, 0x79, 0xe9, 0x27, 0x03, 0xb6, 0xae,
	0x03, 0xb5, 0x57, 0x79, 0xc3, 0x99, 0xfe, 0xb1, 0x03, 0xfd, 0x33, 0x9d, 0xcf, 0x93, 0x05, 0xfb,
	0x92, 0x66, 0x7f, 0xfc, 0xab, 0xe0, 0xa7, 0x93, 0xdb, 0x1b, 0x63, 0xb7, 0x53, 0xf0, 0x9a, 0x81,
	0xe4, 0xd2, 0x8d, 0x34, 0x7e, 0x4a, 0xd9, 0x20, 0xfb, 0x59, 0x87, 0xd7, 0x0c, 0x76, 0x04, 0xfd,
	0x05, 0x75, 0x62, 0x7f, 0xa5, 0xbd, 0x35, 0xd7, 0x75, 0x68, 0xee, 0xf5, 0x38, 0xd4, 0x98, 0x55,
	0xe6, 0x7a, 0xe1, 0xd6, 0x50, 0x83, 0x1d, 0x8e, 0x93, 0x0e, 0x8f, 0xce, 0xdc, 0x43, 0xa7, 0x20,
	0x6d, 0x1d, 0xed, 0x2b, 0x00, 0xaf, 0x19, 0x78, 0x74, 0x49, 0x6f, 0xc6, 0x4f, 0x20, 0x1b, 0x47,
	0xbb, 0xb7, 0xc4, 0xbd, 0x1e, 0x99, 0x82, 0x2a, 0xa4, 0x9f, 0x41, 0x36, 0x98, 0xbe, 0x72, 0x7a,
	0x3d, 0xfb, 0x1c, 0x7a, 0x16, 0xab, 0x9c, 0x2f, 0xb4, 0xb7, 0x36, 0x47, 0xaf, 0xd2, 0x96, 0xdc,
	0x69, 0x91, 0x96, 0x60, 0x30, 0x29, 0xc2, 0x5b, 0x34, 0x8a, 0x31, 0x77, 0x5a, 0x3c, 0x37, 0xa5,
	0x7f, 0x1f, 0x54, 0x6a, 0xb7, 0xce, 0x75, 0xff, 0x4a, 0xb8, 0xd7, 0x4f, 0x0b, 0xe8, 0xfb, 0x3e,
	0x7e, 0x1f, 0x7a, 0x74, 0x6b, 0x0a, 0xd4, 0xf8, 0xd1, 0xc7, 0xeb, 0x25, 0x8e, 0x10, 0x3a, 0x9b,
	0xb8, 0x63, 0xd1, 0x23, 0xda, 0x9e, 0x62, 0x1a, 0x99, 0xe6, 0x94, 0x75, 0xc3, 0x75, 0x83, 0xf5,
	0xb0, 0x6c, 0x7a, 0xed, 0xd7, 0xd0, 0xbf, 0xa8, 0x12, 0x2b, 0xe3, 0xff, 0xf3, 0xcc, 0x2f, 0xbe,
	0x86, 0xd1, 0x16, 0xce, 0x06, 0xd0, 0x89, 0xd4, 0x7c, 0xef, 0x7b, 0x2c, 0x80, 0x2e, 0x96, 0x92,
	0xbd, 0x16, 0x1b, 0xd2, 0x96, 0x85, 0xdd, 0x6b, 0x23, 0x58, 0x5a, 0x6d, 0xf6, 0x3a, 0x4f, 0x7e,
	0xf5, 0xa7, 0x37, 0x07, 0xad, 0x3f, 0xbf, 0x39, 0x68, 0xfd, 0xed, 0xcd, 0x41, 0xeb, 0x77, 0x8f,
	0xb6, 0xfe, 0x81, 0xa7, 0x0b, 0x6d, 0xe3, 0xaf, 0x4e, 0x1e, 0xd4, 0x47, 0xdf, 0xa7, 0xff, 0xdd,
	0xbf, 0xac, 0xc5, 0xd0, 0xfd, 0x3d, 0xef, 0xd3, 0xcf, 0x57, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff,
	0xba, 0xf8, 0x54, 0xf5, 0xd8, 0x0f, 0x00, 0x00,
}

func (m *NTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timezone != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Timezone))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x12
	}
	if m.DayLight != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.DayLight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mqtt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mqtt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mqtt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ntp != nil {
		{
			size, err := m.Ntp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Mqtt != nil {
		{
			size, err := m.Mqtt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AllowPost {
		i--
		if m.AllowPost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Dns) > 0 {
		i -= len(m.Dns)
		copy(dAtA[i:], m.Dns)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Dns)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Gateway) > 0 {
		i -= len(m.Gateway)
		copy(dAtA[i:], m.Gateway)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Gateway)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Netmask) > 0 {
		i -= len(m.Netmask)
		copy(dAtA[i:], m.Netmask)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Netmask)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if m.Dhcp {
		i--
		if m.Dhcp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Temp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Temp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Temp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		dAtA4 := make([]byte, len(m.Addr)*10)
		var j3 int
		for _, num := range m.Addr {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintDomopool(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x42
	}
	if m.Init {
		i--
		if m.Init {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TambMin != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.TambMin))
		i--
		dAtA[i] = 0x68
	}
	if m.TwMax != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.TwMax))
		i--
		dAtA[i] = 0x60
	}
	if m.TwMin != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.TwMin))
		i--
		dAtA[i] = 0x58
	}
	if m.Wp_0Derive != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Wp_0Derive))))
		i--
		dAtA[i] = 0x55
	}
	if m.ChTempWaitReset != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChTempWaitReset))))
		i--
		dAtA[i] = 0x4d
	}
	if m.ChTempThreshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChTempThreshold))))
		i--
		dAtA[i] = 0x45
	}
	if m.WaitBeforeCh != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.WaitBeforeCh))
		i--
		dAtA[i] = 0x38
	}
	if m.ChMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChMax))))
		i--
		dAtA[i] = 0x35
	}
	if m.ChMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChMin))))
		i--
		dAtA[i] = 0x2d
	}
	if m.PhMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhMax))))
		i--
		dAtA[i] = 0x25
	}
	if m.PhMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhMin))))
		i--
		dAtA[i] = 0x1d
	}
	if m.WpMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WpMax))))
		i--
		dAtA[i] = 0x15
	}
	if m.WpMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WpMin))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *AnalogSensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalogSensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalogSensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrecisionFactor != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.PrecisionFactor))
		i--
		dAtA[i] = 0x38
	}
	if m.Vmax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Vmax))))
		i--
		dAtA[i] = 0x35
	}
	if m.Vmin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Vmin))))
		i--
		dAtA[i] = 0x2d
	}
	if m.ThresholdAccuracy != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.ThresholdAccuracy))
		i--
		dAtA[i] = 0x20
	}
	if m.AdcPin != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AdcPin))
		i--
		dAtA[i] = 0x18
	}
	if m.Threshold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Threshold))))
		i--
		dAtA[i] = 0x15
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sensors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sensors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sensors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Wp != nil {
		{
			size, err := m.Wp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Ch != nil {
		{
			size, err := m.Ch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Ph != nil {
		{
			size, err := m.Ph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PrecisionFactor != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.PrecisionFactor))
		i--
		dAtA[i] = 0x30
	}
	if m.TempResolution != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.TempResolution))
		i--
		dAtA[i] = 0x28
	}
	if m.WaitForConversion {
		i--
		if m.WaitForConversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Tamb != nil {
		{
			size, err := m.Tamb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Twout != nil {
		{
			size, err := m.Twout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Twin != nil {
		{
			size, err := m.Twin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ForceLight {
		i--
		if m.ForceLight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DisplayStartup {
		i--
		if m.DisplayStartup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SerialOut {
		i--
		if m.SerialOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AckTone != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AckTone))))
		i--
		dAtA[i] = 0x19
	}
	if m.AckDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.AckDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.LcdBacklightDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.LcdBacklightDuration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pump) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pump) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pump) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ForceStartTime != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.ForceStartTime))
		i--
		dAtA[i] = 0x38
	}
	if m.ForceDuration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.ForceDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.ForceCheck {
		i--
		if m.ForceCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Automatic {
		i--
		if m.Automatic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ForceCh {
		i--
		if m.ForceCh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ForcePh {
		i--
		if m.ForcePh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ForceFilter {
		i--
		if m.ForceFilter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ads115Alarms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ads115Alarms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ads115Alarms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NotConnected {
		i--
		if m.NotConnected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NotStarted {
		i--
		if m.NotStarted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NotReady {
		i--
		if m.NotReady {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alarms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alarms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alarms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TambFrost {
		i--
		if m.TambFrost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.TwHigh {
		i--
		if m.TwHigh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.TwFrost {
		i--
		if m.TwFrost {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Ads1115 != nil {
		{
			size, err := m.Ads1115.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.WpBroken {
		i--
		if m.WpBroken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.WpLow {
		i--
		if m.WpLow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.WpHigh {
		i--
		if m.WpHigh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Rtc {
		i--
		if m.Rtc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Ch {
		i--
		if m.Ch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Ph {
		i--
		if m.Ph {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Filter {
		i--
		if m.Filter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pressure != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Pressure))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Ph != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ph))))
		i--
		dAtA[i] = 0x25
	}
	if m.Tamb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Tamb))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Twater != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Twater))))
		i--
		dAtA[i] = 0x15
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hour != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Hour))
		i--
		dAtA[i] = 0x48
	}
	if m.Over_15Duration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Over_15Duration))
		i--
		dAtA[i] = 0x40
	}
	if m.WpVolt != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WpVolt))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Wp != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Wp))))
		i--
		dAtA[i] = 0x35
	}
	if m.Ch != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ch))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Ph != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Ph))))
		i--
		dAtA[i] = 0x25
	}
	if m.SavedTwater != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SavedTwater))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Twater != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Twater))))
		i--
		dAtA[i] = 0x15
	}
	if m.Tamb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Tamb))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *States) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *States) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *States) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LightOn {
		i--
		if m.LightOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Rtc {
		i--
		if m.Rtc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Ntp {
		i--
		if m.Ntp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NetActive {
		i--
		if m.NetActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Automatic {
		i--
		if m.Automatic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ChOn {
		i--
		if m.ChOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PhOn {
		i--
		if m.PhOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FilterOn {
		i--
		if m.FilterOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Startup {
		i--
		if m.Startup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Versions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Versions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Versions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mqtt) > 0 {
		i -= len(m.Mqtt)
		copy(dAtA[i:], m.Mqtt)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Mqtt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Nanopb) > 0 {
		i -= len(m.Nanopb)
		copy(dAtA[i:], m.Nanopb)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Nanopb)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Ads1115) > 0 {
		i -= len(m.Ads1115)
		copy(dAtA[i:], m.Ads1115)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Ads1115)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Dallastemp) > 0 {
		i -= len(m.Dallastemp)
		copy(dAtA[i:], m.Dallastemp)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Dallastemp)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TftEspi) > 0 {
		i -= len(m.TftEspi)
		copy(dAtA[i:], m.TftEspi)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.TftEspi)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Xtensa) > 0 {
		i -= len(m.Xtensa)
		copy(dAtA[i:], m.Xtensa)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Xtensa)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EspIdf) > 0 {
		i -= len(m.EspIdf)
		copy(dAtA[i:], m.EspIdf)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.EspIdf)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Platformio != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Platformio))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Domopool) > 0 {
		i -= len(m.Domopool)
		copy(dAtA[i:], m.Domopool)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Domopool)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Infos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Infos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Infos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Versions != nil {
		{
			size, err := m.Versions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BoardName) > 0 {
		i -= len(m.BoardName)
		copy(dAtA[i:], m.BoardName)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.BoardName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Compile) > 0 {
		i -= len(m.Compile)
		copy(dAtA[i:], m.Compile)
		i = encodeVarintDomopool(dAtA, i, uint64(len(m.Compile)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limits != nil {
		{
			size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Infos != nil {
		{
			size, err := m.Infos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Tests != nil {
		{
			size, err := m.Tests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Alarms != nil {
		{
			size, err := m.Alarms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.States != nil {
		{
			size, err := m.States.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Pump != nil {
		{
			size, err := m.Pump.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Sensors != nil {
		{
			size, err := m.Sensors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDomopool(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartTime != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Duration != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Switch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Switch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Switch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintDomopool(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDomopool(dAtA []byte, offset int, v uint64) int {
	offset -= sovDomopool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DayLight != 0 {
		n += 1 + sovDomopool(uint64(m.DayLight))
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Timezone != 0 {
		n += 1 + sovDomopool(uint64(m.Timezone))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mqtt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dhcp {
		n += 2
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Netmask)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Dns)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.AllowPost {
		n += 2
	}
	if m.Mqtt != nil {
		l = m.Mqtt.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Ntp != nil {
		l = m.Ntp.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Temp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Init {
		n += 2
	}
	if len(m.Addr) > 0 {
		l = 0
		for _, e := range m.Addr {
			l += sovDomopool(uint64(e))
		}
		n += 1 + sovDomopool(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Limits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WpMin != 0 {
		n += 5
	}
	if m.WpMax != 0 {
		n += 5
	}
	if m.PhMin != 0 {
		n += 5
	}
	if m.PhMax != 0 {
		n += 5
	}
	if m.ChMin != 0 {
		n += 5
	}
	if m.ChMax != 0 {
		n += 5
	}
	if m.WaitBeforeCh != 0 {
		n += 1 + sovDomopool(uint64(m.WaitBeforeCh))
	}
	if m.ChTempThreshold != 0 {
		n += 5
	}
	if m.ChTempWaitReset != 0 {
		n += 5
	}
	if m.Wp_0Derive != 0 {
		n += 5
	}
	if m.TwMin != 0 {
		n += 1 + sovDomopool(uint64(m.TwMin))
	}
	if m.TwMax != 0 {
		n += 1 + sovDomopool(uint64(m.TwMax))
	}
	if m.TambMin != 0 {
		n += 1 + sovDomopool(uint64(m.TambMin))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalogSensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Threshold != 0 {
		n += 5
	}
	if m.AdcPin != 0 {
		n += 1 + sovDomopool(uint64(m.AdcPin))
	}
	if m.ThresholdAccuracy != 0 {
		n += 1 + sovDomopool(uint64(m.ThresholdAccuracy))
	}
	if m.Vmin != 0 {
		n += 5
	}
	if m.Vmax != 0 {
		n += 5
	}
	if m.PrecisionFactor != 0 {
		n += 1 + sovDomopool(uint64(m.PrecisionFactor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sensors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Twin != nil {
		l = m.Twin.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Twout != nil {
		l = m.Twout.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Tamb != nil {
		l = m.Tamb.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.WaitForConversion {
		n += 2
	}
	if m.TempResolution != 0 {
		n += 1 + sovDomopool(uint64(m.TempResolution))
	}
	if m.PrecisionFactor != 0 {
		n += 1 + sovDomopool(uint64(m.PrecisionFactor))
	}
	if m.Ph != nil {
		l = m.Ph.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Ch != nil {
		l = m.Ch.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Wp != nil {
		l = m.Wp.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LcdBacklightDuration != 0 {
		n += 1 + sovDomopool(uint64(m.LcdBacklightDuration))
	}
	if m.AckDuration != 0 {
		n += 1 + sovDomopool(uint64(m.AckDuration))
	}
	if m.AckTone != 0 {
		n += 9
	}
	if m.SerialOut {
		n += 2
	}
	if m.DisplayStartup {
		n += 2
	}
	if m.ForceLight {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForceFilter {
		n += 2
	}
	if m.ForcePh {
		n += 2
	}
	if m.ForceCh {
		n += 2
	}
	if m.Automatic {
		n += 2
	}
	if m.ForceCheck {
		n += 2
	}
	if m.ForceDuration != 0 {
		n += 1 + sovDomopool(uint64(m.ForceDuration))
	}
	if m.ForceStartTime != 0 {
		n += 1 + sovDomopool(uint64(m.ForceStartTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ads115Alarms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotReady {
		n += 2
	}
	if m.NotStarted {
		n += 2
	}
	if m.NotConnected {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alarms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter {
		n += 2
	}
	if m.Ph {
		n += 2
	}
	if m.Ch {
		n += 2
	}
	if m.Rtc {
		n += 2
	}
	if m.WpHigh {
		n += 2
	}
	if m.WpLow {
		n += 2
	}
	if m.WpBroken {
		n += 2
	}
	if m.Ads1115 != nil {
		l = m.Ads1115.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.TwFrost {
		n += 2
	}
	if m.TwHigh {
		n += 2
	}
	if m.TambFrost {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Twater != 0 {
		n += 5
	}
	if m.Tamb != 0 {
		n += 5
	}
	if m.Ph != 0 {
		n += 5
	}
	if m.Pressure != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tamb != 0 {
		n += 5
	}
	if m.Twater != 0 {
		n += 5
	}
	if m.SavedTwater != 0 {
		n += 5
	}
	if m.Ph != 0 {
		n += 5
	}
	if m.Ch != 0 {
		n += 5
	}
	if m.Wp != 0 {
		n += 5
	}
	if m.WpVolt != 0 {
		n += 5
	}
	if m.Over_15Duration != 0 {
		n += 1 + sovDomopool(uint64(m.Over_15Duration))
	}
	if m.Hour != 0 {
		n += 1 + sovDomopool(uint64(m.Hour))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *States) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Startup {
		n += 2
	}
	if m.FilterOn {
		n += 2
	}
	if m.PhOn {
		n += 2
	}
	if m.ChOn {
		n += 2
	}
	if m.Automatic {
		n += 2
	}
	if m.NetActive {
		n += 2
	}
	if m.Ntp {
		n += 2
	}
	if m.Rtc {
		n += 2
	}
	if m.LightOn {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Versions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domopool)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Platformio != 0 {
		n += 1 + sovDomopool(uint64(m.Platformio))
	}
	l = len(m.EspIdf)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Xtensa)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.TftEspi)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Dallastemp)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Ads1115)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Nanopb)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.Mqtt)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Infos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Compile)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	l = len(m.BoardName)
	if l > 0 {
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Versions != nil {
		l = m.Versions.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Sensors != nil {
		l = m.Sensors.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Pump != nil {
		l = m.Pump.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.States != nil {
		l = m.States.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Alarms != nil {
		l = m.Alarms.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Tests != nil {
		l = m.Tests.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Infos != nil {
		l = m.Infos.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.Limits != nil {
		l = m.Limits.Size()
		n += 1 + l + sovDomopool(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDomopool(uint64(m.State))
	}
	if m.Duration != 0 {
		n += 1 + sovDomopool(uint64(m.Duration))
	}
	if m.StartTime != 0 {
		n += 1 + sovDomopool(uint64(m.StartTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Switch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovDomopool(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDomopool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDomopool(x uint64) (n int) {
	return sovDomopool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayLight", wireType)
			}
			m.DayLight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DayLight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timezone", wireType)
			}
			m.Timezone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timezone |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mqtt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mqtt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mqtt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dhcp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dhcp = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Netmask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Netmask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPost = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mqtt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mqtt == nil {
				m.Mqtt = &Mqtt{}
			}
			if err := m.Mqtt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ntp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ntp == nil {
				m.Ntp = &NTP{}
			}
			if err := m.Ntp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Temp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Temp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Temp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Init = bool(v != 0)
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomopool
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Addr = append(m.Addr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDomopool
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDomopool
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDomopool
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Addr) == 0 {
					m.Addr = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDomopool
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Addr = append(m.Addr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WpMin = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WpMax = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhMin = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhMax = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChMin = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChMax = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitBeforeCh", wireType)
			}
			m.WaitBeforeCh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitBeforeCh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChTempThreshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChTempThreshold = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChTempWaitReset", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChTempWaitReset = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wp_0Derive", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Wp_0Derive = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwMin", wireType)
			}
			m.TwMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TwMin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwMax", wireType)
			}
			m.TwMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TwMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TambMin", wireType)
			}
			m.TambMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TambMin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalogSensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalogSensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalogSensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Threshold = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdcPin", wireType)
			}
			m.AdcPin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdcPin |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdAccuracy", wireType)
			}
			m.ThresholdAccuracy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThresholdAccuracy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vmin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Vmin = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vmax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Vmax = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionFactor", wireType)
			}
			m.PrecisionFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sensors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sensors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sensors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Twin == nil {
				m.Twin = &Temp{}
			}
			if err := m.Twin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Twout == nil {
				m.Twout = &Temp{}
			}
			if err := m.Twout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tamb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tamb == nil {
				m.Tamb = &Temp{}
			}
			if err := m.Tamb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitForConversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaitForConversion = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempResolution", wireType)
			}
			m.TempResolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempResolution |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionFactor", wireType)
			}
			m.PrecisionFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ph == nil {
				m.Ph = &AnalogSensor{}
			}
			if err := m.Ph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ch == nil {
				m.Ch = &AnalogSensor{}
			}
			if err := m.Ch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wp == nil {
				m.Wp = &AnalogSensor{}
			}
			if err := m.Wp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LcdBacklightDuration", wireType)
			}
			m.LcdBacklightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LcdBacklightDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckDuration", wireType)
			}
			m.AckDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckTone", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AckTone = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SerialOut = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayStartup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisplayStartup = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceLight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceLight = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pump) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pump: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pump: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceFilter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceFilter = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePh = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceCh = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Automatic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Automatic = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceCheck = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceDuration", wireType)
			}
			m.ForceDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceDuration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceStartTime", wireType)
			}
			m.ForceStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceStartTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ads115Alarms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ads115Alarms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ads115Alarms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotReady = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotStarted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotStarted = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotConnected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alarms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alarms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alarms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Filter = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ph = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ch = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rtc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpHigh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WpHigh = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpLow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WpLow = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpBroken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WpBroken = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ads1115", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ads1115 == nil {
				m.Ads1115 = &Ads115Alarms{}
			}
			if err := m.Ads1115.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwFrost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TwFrost = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwHigh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TwHigh = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TambFrost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TambFrost = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twater", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Twater = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tamb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Tamb = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ph = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pressure", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Pressure = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tamb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Tamb = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twater", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Twater = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SavedTwater", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SavedTwater = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ph", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ph = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ch", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Ch = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Wp = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WpVolt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WpVolt = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_15Duration", wireType)
			}
			m.Over_15Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_15Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			m.Hour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hour |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *States) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: States: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: States: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Startup = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterOn = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhOn = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChOn = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Automatic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Automatic = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetActive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ntp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ntp = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rtc = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LightOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Versions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Versions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Versions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domopool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domopool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platformio", wireType)
			}
			m.Platformio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Platformio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspIdf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EspIdf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xtensa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Xtensa = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TftEspi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TftEspi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dallastemp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dallastemp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ads1115", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ads1115 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanopb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nanopb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mqtt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mqtt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Infos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Infos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Infos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoardName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BoardName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Versions == nil {
				m.Versions = &Versions{}
			}
			if err := m.Versions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sensors == nil {
				m.Sensors = &Sensors{}
			}
			if err := m.Sensors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Global == nil {
				m.Global = &Global{}
			}
			if err := m.Global.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pump", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pump == nil {
				m.Pump = &Pump{}
			}
			if err := m.Pump.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.States == nil {
				m.States = &States{}
			}
			if err := m.States.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alarms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alarms == nil {
				m.Alarms = &Alarms{}
			}
			if err := m.Alarms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tests == nil {
				m.Tests = &Tests{}
			}
			if err := m.Tests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infos == nil {
				m.Infos = &Infos{}
			}
			if err := m.Infos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDomopool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDomopool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limits == nil {
				m.Limits = &Limits{}
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FilterStates(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Switch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= FilterStates(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDomopool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDomopool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDomopool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDomopool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDomopool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDomopool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDomopool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDomopool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDomopool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDomopool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDomopool = fmt.Errorf("proto: unexpected end of group")
)
