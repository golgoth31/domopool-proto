// This file is generated by rust-protobuf 2.22.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `domopool.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_1;

#[derive(PartialEq,Clone,Default)]
pub struct NTP {
    // message fields
    pub day_light: u32,
    pub server: ::std::string::String,
    pub timezone: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NTP {
    fn default() -> &'a NTP {
        <NTP as ::protobuf::Message>::default_instance()
    }
}

impl NTP {
    pub fn new() -> NTP {
        ::std::default::Default::default()
    }

    // uint32 day_light = 1;


    pub fn get_day_light(&self) -> u32 {
        self.day_light
    }
    pub fn clear_day_light(&mut self) {
        self.day_light = 0;
    }

    // Param is passed by value, moved
    pub fn set_day_light(&mut self, v: u32) {
        self.day_light = v;
    }

    // string server = 2;


    pub fn get_server(&self) -> &str {
        &self.server
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        &mut self.server
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server, ::std::string::String::new())
    }

    // uint32 timezone = 3;


    pub fn get_timezone(&self) -> u32 {
        self.timezone
    }
    pub fn clear_timezone(&mut self) {
        self.timezone = 0;
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: u32) {
        self.timezone = v;
    }
}

impl ::protobuf::Message for NTP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.day_light = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timezone = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.day_light != 0 {
            my_size += ::protobuf::rt::value_size(1, self.day_light, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.server.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.server);
        }
        if self.timezone != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timezone, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.day_light != 0 {
            os.write_uint32(1, self.day_light)?;
        }
        if !self.server.is_empty() {
            os.write_string(2, &self.server)?;
        }
        if self.timezone != 0 {
            os.write_uint32(3, self.timezone)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NTP {
        NTP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "day_light",
                |m: &NTP| { &m.day_light },
                |m: &mut NTP| { &mut m.day_light },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server",
                |m: &NTP| { &m.server },
                |m: &mut NTP| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timezone",
                |m: &NTP| { &m.timezone },
                |m: &mut NTP| { &mut m.timezone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NTP>(
                "NTP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NTP {
        static instance: ::protobuf::rt::LazyV2<NTP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NTP::new)
    }
}

impl ::protobuf::Clear for NTP {
    fn clear(&mut self) {
        self.day_light = 0;
        self.server.clear();
        self.timezone = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NTP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NTP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mqtt {
    // message fields
    pub enabled: bool,
    pub server: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mqtt {
    fn default() -> &'a Mqtt {
        <Mqtt as ::protobuf::Message>::default_instance()
    }
}

impl Mqtt {
    pub fn new() -> Mqtt {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // string server = 2;


    pub fn get_server(&self) -> &str {
        &self.server
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        &mut self.server
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Mqtt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if !self.server.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.server);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if !self.server.is_empty() {
            os.write_string(2, &self.server)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mqtt {
        Mqtt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &Mqtt| { &m.enabled },
                |m: &mut Mqtt| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server",
                |m: &Mqtt| { &m.server },
                |m: &mut Mqtt| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mqtt>(
                "Mqtt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mqtt {
        static instance: ::protobuf::rt::LazyV2<Mqtt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mqtt::new)
    }
}

impl ::protobuf::Clear for Mqtt {
    fn clear(&mut self) {
        self.enabled = false;
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mqtt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mqtt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Network {
    // message fields
    pub dhcp: bool,
    pub ip: ::std::string::String,
    pub netmask: ::std::string::String,
    pub gateway: ::std::string::String,
    pub dns: ::std::string::String,
    pub allow_post: bool,
    pub mqtt: ::protobuf::SingularPtrField<Mqtt>,
    pub ntp: ::protobuf::SingularPtrField<NTP>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Network {
    fn default() -> &'a Network {
        <Network as ::protobuf::Message>::default_instance()
    }
}

impl Network {
    pub fn new() -> Network {
        ::std::default::Default::default()
    }

    // bool dhcp = 1;


    pub fn get_dhcp(&self) -> bool {
        self.dhcp
    }
    pub fn clear_dhcp(&mut self) {
        self.dhcp = false;
    }

    // Param is passed by value, moved
    pub fn set_dhcp(&mut self, v: bool) {
        self.dhcp = v;
    }

    // string ip = 2;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    // string netmask = 3;


    pub fn get_netmask(&self) -> &str {
        &self.netmask
    }
    pub fn clear_netmask(&mut self) {
        self.netmask.clear();
    }

    // Param is passed by value, moved
    pub fn set_netmask(&mut self, v: ::std::string::String) {
        self.netmask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_netmask(&mut self) -> &mut ::std::string::String {
        &mut self.netmask
    }

    // Take field
    pub fn take_netmask(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.netmask, ::std::string::String::new())
    }

    // string gateway = 4;


    pub fn get_gateway(&self) -> &str {
        &self.gateway
    }
    pub fn clear_gateway(&mut self) {
        self.gateway.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        &mut self.gateway
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gateway, ::std::string::String::new())
    }

    // string dns = 5;


    pub fn get_dns(&self) -> &str {
        &self.dns
    }
    pub fn clear_dns(&mut self) {
        self.dns.clear();
    }

    // Param is passed by value, moved
    pub fn set_dns(&mut self, v: ::std::string::String) {
        self.dns = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dns(&mut self) -> &mut ::std::string::String {
        &mut self.dns
    }

    // Take field
    pub fn take_dns(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dns, ::std::string::String::new())
    }

    // bool allow_post = 6;


    pub fn get_allow_post(&self) -> bool {
        self.allow_post
    }
    pub fn clear_allow_post(&mut self) {
        self.allow_post = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_post(&mut self, v: bool) {
        self.allow_post = v;
    }

    // .domopool.Mqtt mqtt = 7;


    pub fn get_mqtt(&self) -> &Mqtt {
        self.mqtt.as_ref().unwrap_or_else(|| <Mqtt as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mqtt(&mut self) {
        self.mqtt.clear();
    }

    pub fn has_mqtt(&self) -> bool {
        self.mqtt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: Mqtt) {
        self.mqtt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mqtt(&mut self) -> &mut Mqtt {
        if self.mqtt.is_none() {
            self.mqtt.set_default();
        }
        self.mqtt.as_mut().unwrap()
    }

    // Take field
    pub fn take_mqtt(&mut self) -> Mqtt {
        self.mqtt.take().unwrap_or_else(|| Mqtt::new())
    }

    // .domopool.NTP ntp = 8;


    pub fn get_ntp(&self) -> &NTP {
        self.ntp.as_ref().unwrap_or_else(|| <NTP as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ntp(&mut self) {
        self.ntp.clear();
    }

    pub fn has_ntp(&self) -> bool {
        self.ntp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ntp(&mut self, v: NTP) {
        self.ntp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ntp(&mut self) -> &mut NTP {
        if self.ntp.is_none() {
            self.ntp.set_default();
        }
        self.ntp.as_mut().unwrap()
    }

    // Take field
    pub fn take_ntp(&mut self) -> NTP {
        self.ntp.take().unwrap_or_else(|| NTP::new())
    }
}

impl ::protobuf::Message for Network {
    fn is_initialized(&self) -> bool {
        for v in &self.mqtt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ntp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dhcp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.netmask)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gateway)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dns)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_post = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mqtt)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ntp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dhcp != false {
            my_size += 2;
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ip);
        }
        if !self.netmask.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.netmask);
        }
        if !self.gateway.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.gateway);
        }
        if !self.dns.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dns);
        }
        if self.allow_post != false {
            my_size += 2;
        }
        if let Some(ref v) = self.mqtt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ntp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dhcp != false {
            os.write_bool(1, self.dhcp)?;
        }
        if !self.ip.is_empty() {
            os.write_string(2, &self.ip)?;
        }
        if !self.netmask.is_empty() {
            os.write_string(3, &self.netmask)?;
        }
        if !self.gateway.is_empty() {
            os.write_string(4, &self.gateway)?;
        }
        if !self.dns.is_empty() {
            os.write_string(5, &self.dns)?;
        }
        if self.allow_post != false {
            os.write_bool(6, self.allow_post)?;
        }
        if let Some(ref v) = self.mqtt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ntp.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Network {
        Network::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dhcp",
                |m: &Network| { &m.dhcp },
                |m: &mut Network| { &mut m.dhcp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &Network| { &m.ip },
                |m: &mut Network| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "netmask",
                |m: &Network| { &m.netmask },
                |m: &mut Network| { &mut m.netmask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateway",
                |m: &Network| { &m.gateway },
                |m: &mut Network| { &mut m.gateway },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dns",
                |m: &Network| { &m.dns },
                |m: &mut Network| { &mut m.dns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_post",
                |m: &Network| { &m.allow_post },
                |m: &mut Network| { &mut m.allow_post },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mqtt>>(
                "mqtt",
                |m: &Network| { &m.mqtt },
                |m: &mut Network| { &mut m.mqtt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NTP>>(
                "ntp",
                |m: &Network| { &m.ntp },
                |m: &mut Network| { &mut m.ntp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Network>(
                "Network",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Network {
        static instance: ::protobuf::rt::LazyV2<Network> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Network::new)
    }
}

impl ::protobuf::Clear for Network {
    fn clear(&mut self) {
        self.dhcp = false;
        self.ip.clear();
        self.netmask.clear();
        self.gateway.clear();
        self.dns.clear();
        self.allow_post = false;
        self.mqtt.clear();
        self.ntp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Network {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Network {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Temp {
    // message fields
    pub enabled: bool,
    pub init: bool,
    pub addr: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Temp {
    fn default() -> &'a Temp {
        <Temp as ::protobuf::Message>::default_instance()
    }
}

impl Temp {
    pub fn new() -> Temp {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // bool init = 2;


    pub fn get_init(&self) -> bool {
        self.init
    }
    pub fn clear_init(&mut self) {
        self.init = false;
    }

    // Param is passed by value, moved
    pub fn set_init(&mut self, v: bool) {
        self.init = v;
    }

    // repeated uint32 addr = 8;


    pub fn get_addr(&self) -> &[u32] {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::vec::Vec<u32>) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addr(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.addr, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Temp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.init = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.init != false {
            my_size += 2;
        }
        for value in &self.addr {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.init != false {
            os.write_bool(2, self.init)?;
        }
        for v in &self.addr {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Temp {
        Temp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &Temp| { &m.enabled },
                |m: &mut Temp| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "init",
                |m: &Temp| { &m.init },
                |m: &mut Temp| { &mut m.init },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "addr",
                |m: &Temp| { &m.addr },
                |m: &mut Temp| { &mut m.addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Temp>(
                "Temp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Temp {
        static instance: ::protobuf::rt::LazyV2<Temp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Temp::new)
    }
}

impl ::protobuf::Clear for Temp {
    fn clear(&mut self) {
        self.enabled = false;
        self.init = false;
        self.addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Temp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Temp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Limits {
    // message fields
    pub wp_min: f32,
    pub wp_max: f32,
    pub ph_min: f32,
    pub ph_max: f32,
    pub ch_min: f32,
    pub ch_max: f32,
    pub wait_before_ch: u32,
    pub ch_temp_threshold: f32,
    pub ch_temp_wait_reset: f32,
    pub wp_0_derive: f32,
    pub tw_min: f32,
    pub tw_max: f32,
    pub tamb_min: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Limits {
    fn default() -> &'a Limits {
        <Limits as ::protobuf::Message>::default_instance()
    }
}

impl Limits {
    pub fn new() -> Limits {
        ::std::default::Default::default()
    }

    // float wp_min = 1;


    pub fn get_wp_min(&self) -> f32 {
        self.wp_min
    }
    pub fn clear_wp_min(&mut self) {
        self.wp_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wp_min(&mut self, v: f32) {
        self.wp_min = v;
    }

    // float wp_max = 2;


    pub fn get_wp_max(&self) -> f32 {
        self.wp_max
    }
    pub fn clear_wp_max(&mut self) {
        self.wp_max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wp_max(&mut self, v: f32) {
        self.wp_max = v;
    }

    // float ph_min = 3;


    pub fn get_ph_min(&self) -> f32 {
        self.ph_min
    }
    pub fn clear_ph_min(&mut self) {
        self.ph_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ph_min(&mut self, v: f32) {
        self.ph_min = v;
    }

    // float ph_max = 4;


    pub fn get_ph_max(&self) -> f32 {
        self.ph_max
    }
    pub fn clear_ph_max(&mut self) {
        self.ph_max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ph_max(&mut self, v: f32) {
        self.ph_max = v;
    }

    // float ch_min = 5;


    pub fn get_ch_min(&self) -> f32 {
        self.ch_min
    }
    pub fn clear_ch_min(&mut self) {
        self.ch_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ch_min(&mut self, v: f32) {
        self.ch_min = v;
    }

    // float ch_max = 6;


    pub fn get_ch_max(&self) -> f32 {
        self.ch_max
    }
    pub fn clear_ch_max(&mut self) {
        self.ch_max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ch_max(&mut self, v: f32) {
        self.ch_max = v;
    }

    // uint32 wait_before_ch = 7;


    pub fn get_wait_before_ch(&self) -> u32 {
        self.wait_before_ch
    }
    pub fn clear_wait_before_ch(&mut self) {
        self.wait_before_ch = 0;
    }

    // Param is passed by value, moved
    pub fn set_wait_before_ch(&mut self, v: u32) {
        self.wait_before_ch = v;
    }

    // float ch_temp_threshold = 8;


    pub fn get_ch_temp_threshold(&self) -> f32 {
        self.ch_temp_threshold
    }
    pub fn clear_ch_temp_threshold(&mut self) {
        self.ch_temp_threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ch_temp_threshold(&mut self, v: f32) {
        self.ch_temp_threshold = v;
    }

    // float ch_temp_wait_reset = 9;


    pub fn get_ch_temp_wait_reset(&self) -> f32 {
        self.ch_temp_wait_reset
    }
    pub fn clear_ch_temp_wait_reset(&mut self) {
        self.ch_temp_wait_reset = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ch_temp_wait_reset(&mut self, v: f32) {
        self.ch_temp_wait_reset = v;
    }

    // float wp_0_derive = 10;


    pub fn get_wp_0_derive(&self) -> f32 {
        self.wp_0_derive
    }
    pub fn clear_wp_0_derive(&mut self) {
        self.wp_0_derive = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wp_0_derive(&mut self, v: f32) {
        self.wp_0_derive = v;
    }

    // float tw_min = 11;


    pub fn get_tw_min(&self) -> f32 {
        self.tw_min
    }
    pub fn clear_tw_min(&mut self) {
        self.tw_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tw_min(&mut self, v: f32) {
        self.tw_min = v;
    }

    // float tw_max = 12;


    pub fn get_tw_max(&self) -> f32 {
        self.tw_max
    }
    pub fn clear_tw_max(&mut self) {
        self.tw_max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tw_max(&mut self, v: f32) {
        self.tw_max = v;
    }

    // float tamb_min = 13;


    pub fn get_tamb_min(&self) -> f32 {
        self.tamb_min
    }
    pub fn clear_tamb_min(&mut self) {
        self.tamb_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tamb_min(&mut self, v: f32) {
        self.tamb_min = v;
    }
}

impl ::protobuf::Message for Limits {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wp_min = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wp_max = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ph_min = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ph_max = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ch_min = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ch_max = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wait_before_ch = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ch_temp_threshold = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ch_temp_wait_reset = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wp_0_derive = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tw_min = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tw_max = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tamb_min = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wp_min != 0. {
            my_size += 5;
        }
        if self.wp_max != 0. {
            my_size += 5;
        }
        if self.ph_min != 0. {
            my_size += 5;
        }
        if self.ph_max != 0. {
            my_size += 5;
        }
        if self.ch_min != 0. {
            my_size += 5;
        }
        if self.ch_max != 0. {
            my_size += 5;
        }
        if self.wait_before_ch != 0 {
            my_size += ::protobuf::rt::value_size(7, self.wait_before_ch, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ch_temp_threshold != 0. {
            my_size += 5;
        }
        if self.ch_temp_wait_reset != 0. {
            my_size += 5;
        }
        if self.wp_0_derive != 0. {
            my_size += 5;
        }
        if self.tw_min != 0. {
            my_size += 5;
        }
        if self.tw_max != 0. {
            my_size += 5;
        }
        if self.tamb_min != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.wp_min != 0. {
            os.write_float(1, self.wp_min)?;
        }
        if self.wp_max != 0. {
            os.write_float(2, self.wp_max)?;
        }
        if self.ph_min != 0. {
            os.write_float(3, self.ph_min)?;
        }
        if self.ph_max != 0. {
            os.write_float(4, self.ph_max)?;
        }
        if self.ch_min != 0. {
            os.write_float(5, self.ch_min)?;
        }
        if self.ch_max != 0. {
            os.write_float(6, self.ch_max)?;
        }
        if self.wait_before_ch != 0 {
            os.write_uint32(7, self.wait_before_ch)?;
        }
        if self.ch_temp_threshold != 0. {
            os.write_float(8, self.ch_temp_threshold)?;
        }
        if self.ch_temp_wait_reset != 0. {
            os.write_float(9, self.ch_temp_wait_reset)?;
        }
        if self.wp_0_derive != 0. {
            os.write_float(10, self.wp_0_derive)?;
        }
        if self.tw_min != 0. {
            os.write_float(11, self.tw_min)?;
        }
        if self.tw_max != 0. {
            os.write_float(12, self.tw_max)?;
        }
        if self.tamb_min != 0. {
            os.write_float(13, self.tamb_min)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Limits {
        Limits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wp_min",
                |m: &Limits| { &m.wp_min },
                |m: &mut Limits| { &mut m.wp_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wp_max",
                |m: &Limits| { &m.wp_max },
                |m: &mut Limits| { &mut m.wp_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ph_min",
                |m: &Limits| { &m.ph_min },
                |m: &mut Limits| { &mut m.ph_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ph_max",
                |m: &Limits| { &m.ph_max },
                |m: &mut Limits| { &mut m.ph_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ch_min",
                |m: &Limits| { &m.ch_min },
                |m: &mut Limits| { &mut m.ch_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ch_max",
                |m: &Limits| { &m.ch_max },
                |m: &mut Limits| { &mut m.ch_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "wait_before_ch",
                |m: &Limits| { &m.wait_before_ch },
                |m: &mut Limits| { &mut m.wait_before_ch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ch_temp_threshold",
                |m: &Limits| { &m.ch_temp_threshold },
                |m: &mut Limits| { &mut m.ch_temp_threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ch_temp_wait_reset",
                |m: &Limits| { &m.ch_temp_wait_reset },
                |m: &mut Limits| { &mut m.ch_temp_wait_reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wp_0_derive",
                |m: &Limits| { &m.wp_0_derive },
                |m: &mut Limits| { &mut m.wp_0_derive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tw_min",
                |m: &Limits| { &m.tw_min },
                |m: &mut Limits| { &mut m.tw_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tw_max",
                |m: &Limits| { &m.tw_max },
                |m: &mut Limits| { &mut m.tw_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tamb_min",
                |m: &Limits| { &m.tamb_min },
                |m: &mut Limits| { &mut m.tamb_min },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Limits>(
                "Limits",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Limits {
        static instance: ::protobuf::rt::LazyV2<Limits> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Limits::new)
    }
}

impl ::protobuf::Clear for Limits {
    fn clear(&mut self) {
        self.wp_min = 0.;
        self.wp_max = 0.;
        self.ph_min = 0.;
        self.ph_max = 0.;
        self.ch_min = 0.;
        self.ch_max = 0.;
        self.wait_before_ch = 0;
        self.ch_temp_threshold = 0.;
        self.ch_temp_wait_reset = 0.;
        self.wp_0_derive = 0.;
        self.tw_min = 0.;
        self.tw_max = 0.;
        self.tamb_min = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Limits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Limits {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalogSensor {
    // message fields
    pub enabled: bool,
    pub adc_pin: u32,
    pub threshold: f32,
    pub threshold_accuracy: u32,
    pub vmin: f32,
    pub vmax: f32,
    pub precision_factor: u32,
    pub auto_cal: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalogSensor {
    fn default() -> &'a AnalogSensor {
        <AnalogSensor as ::protobuf::Message>::default_instance()
    }
}

impl AnalogSensor {
    pub fn new() -> AnalogSensor {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // uint32 adc_pin = 3;


    pub fn get_adc_pin(&self) -> u32 {
        self.adc_pin
    }
    pub fn clear_adc_pin(&mut self) {
        self.adc_pin = 0;
    }

    // Param is passed by value, moved
    pub fn set_adc_pin(&mut self, v: u32) {
        self.adc_pin = v;
    }

    // float threshold = 2;


    pub fn get_threshold(&self) -> f32 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: f32) {
        self.threshold = v;
    }

    // uint32 threshold_accuracy = 4;


    pub fn get_threshold_accuracy(&self) -> u32 {
        self.threshold_accuracy
    }
    pub fn clear_threshold_accuracy(&mut self) {
        self.threshold_accuracy = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold_accuracy(&mut self, v: u32) {
        self.threshold_accuracy = v;
    }

    // float vmin = 5;


    pub fn get_vmin(&self) -> f32 {
        self.vmin
    }
    pub fn clear_vmin(&mut self) {
        self.vmin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_vmin(&mut self, v: f32) {
        self.vmin = v;
    }

    // float vmax = 6;


    pub fn get_vmax(&self) -> f32 {
        self.vmax
    }
    pub fn clear_vmax(&mut self) {
        self.vmax = 0.;
    }

    // Param is passed by value, moved
    pub fn set_vmax(&mut self, v: f32) {
        self.vmax = v;
    }

    // uint32 precision_factor = 7;


    pub fn get_precision_factor(&self) -> u32 {
        self.precision_factor
    }
    pub fn clear_precision_factor(&mut self) {
        self.precision_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_precision_factor(&mut self, v: u32) {
        self.precision_factor = v;
    }

    // bool auto_cal = 8;


    pub fn get_auto_cal(&self) -> bool {
        self.auto_cal
    }
    pub fn clear_auto_cal(&mut self) {
        self.auto_cal = false;
    }

    // Param is passed by value, moved
    pub fn set_auto_cal(&mut self, v: bool) {
        self.auto_cal = v;
    }
}

impl ::protobuf::Message for AnalogSensor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.adc_pin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.threshold = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threshold_accuracy = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.vmin = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.vmax = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.precision_factor = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_cal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.adc_pin != 0 {
            my_size += ::protobuf::rt::value_size(3, self.adc_pin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.threshold != 0. {
            my_size += 5;
        }
        if self.threshold_accuracy != 0 {
            my_size += ::protobuf::rt::value_size(4, self.threshold_accuracy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vmin != 0. {
            my_size += 5;
        }
        if self.vmax != 0. {
            my_size += 5;
        }
        if self.precision_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.precision_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.auto_cal != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.adc_pin != 0 {
            os.write_uint32(3, self.adc_pin)?;
        }
        if self.threshold != 0. {
            os.write_float(2, self.threshold)?;
        }
        if self.threshold_accuracy != 0 {
            os.write_uint32(4, self.threshold_accuracy)?;
        }
        if self.vmin != 0. {
            os.write_float(5, self.vmin)?;
        }
        if self.vmax != 0. {
            os.write_float(6, self.vmax)?;
        }
        if self.precision_factor != 0 {
            os.write_uint32(7, self.precision_factor)?;
        }
        if self.auto_cal != false {
            os.write_bool(8, self.auto_cal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalogSensor {
        AnalogSensor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &AnalogSensor| { &m.enabled },
                |m: &mut AnalogSensor| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "adc_pin",
                |m: &AnalogSensor| { &m.adc_pin },
                |m: &mut AnalogSensor| { &mut m.adc_pin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "threshold",
                |m: &AnalogSensor| { &m.threshold },
                |m: &mut AnalogSensor| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "threshold_accuracy",
                |m: &AnalogSensor| { &m.threshold_accuracy },
                |m: &mut AnalogSensor| { &mut m.threshold_accuracy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "vmin",
                |m: &AnalogSensor| { &m.vmin },
                |m: &mut AnalogSensor| { &mut m.vmin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "vmax",
                |m: &AnalogSensor| { &m.vmax },
                |m: &mut AnalogSensor| { &mut m.vmax },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "precision_factor",
                |m: &AnalogSensor| { &m.precision_factor },
                |m: &mut AnalogSensor| { &mut m.precision_factor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "auto_cal",
                |m: &AnalogSensor| { &m.auto_cal },
                |m: &mut AnalogSensor| { &mut m.auto_cal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnalogSensor>(
                "AnalogSensor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnalogSensor {
        static instance: ::protobuf::rt::LazyV2<AnalogSensor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnalogSensor::new)
    }
}

impl ::protobuf::Clear for AnalogSensor {
    fn clear(&mut self) {
        self.enabled = false;
        self.adc_pin = 0;
        self.threshold = 0.;
        self.threshold_accuracy = 0;
        self.vmin = 0.;
        self.vmax = 0.;
        self.precision_factor = 0;
        self.auto_cal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalogSensor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalogSensor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sensors {
    // message fields
    pub twin: ::protobuf::SingularPtrField<Temp>,
    pub twout: ::protobuf::SingularPtrField<Temp>,
    pub tamb: ::protobuf::SingularPtrField<Temp>,
    pub wait_for_conversion: bool,
    pub temp_resolution: u32,
    pub precision_factor: u32,
    pub ph: ::protobuf::SingularPtrField<AnalogSensor>,
    pub ch: ::protobuf::SingularPtrField<AnalogSensor>,
    pub wp: ::protobuf::SingularPtrField<AnalogSensor>,
    pub adc_mode: u32,
    pub adc_datarate: u32,
    pub adc_gain: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sensors {
    fn default() -> &'a Sensors {
        <Sensors as ::protobuf::Message>::default_instance()
    }
}

impl Sensors {
    pub fn new() -> Sensors {
        ::std::default::Default::default()
    }

    // .domopool.Temp twin = 1;


    pub fn get_twin(&self) -> &Temp {
        self.twin.as_ref().unwrap_or_else(|| <Temp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_twin(&mut self) {
        self.twin.clear();
    }

    pub fn has_twin(&self) -> bool {
        self.twin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twin(&mut self, v: Temp) {
        self.twin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_twin(&mut self) -> &mut Temp {
        if self.twin.is_none() {
            self.twin.set_default();
        }
        self.twin.as_mut().unwrap()
    }

    // Take field
    pub fn take_twin(&mut self) -> Temp {
        self.twin.take().unwrap_or_else(|| Temp::new())
    }

    // .domopool.Temp twout = 2;


    pub fn get_twout(&self) -> &Temp {
        self.twout.as_ref().unwrap_or_else(|| <Temp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_twout(&mut self) {
        self.twout.clear();
    }

    pub fn has_twout(&self) -> bool {
        self.twout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twout(&mut self, v: Temp) {
        self.twout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_twout(&mut self) -> &mut Temp {
        if self.twout.is_none() {
            self.twout.set_default();
        }
        self.twout.as_mut().unwrap()
    }

    // Take field
    pub fn take_twout(&mut self) -> Temp {
        self.twout.take().unwrap_or_else(|| Temp::new())
    }

    // .domopool.Temp tamb = 3;


    pub fn get_tamb(&self) -> &Temp {
        self.tamb.as_ref().unwrap_or_else(|| <Temp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tamb(&mut self) {
        self.tamb.clear();
    }

    pub fn has_tamb(&self) -> bool {
        self.tamb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tamb(&mut self, v: Temp) {
        self.tamb = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tamb(&mut self) -> &mut Temp {
        if self.tamb.is_none() {
            self.tamb.set_default();
        }
        self.tamb.as_mut().unwrap()
    }

    // Take field
    pub fn take_tamb(&mut self) -> Temp {
        self.tamb.take().unwrap_or_else(|| Temp::new())
    }

    // bool wait_for_conversion = 4;


    pub fn get_wait_for_conversion(&self) -> bool {
        self.wait_for_conversion
    }
    pub fn clear_wait_for_conversion(&mut self) {
        self.wait_for_conversion = false;
    }

    // Param is passed by value, moved
    pub fn set_wait_for_conversion(&mut self, v: bool) {
        self.wait_for_conversion = v;
    }

    // uint32 temp_resolution = 5;


    pub fn get_temp_resolution(&self) -> u32 {
        self.temp_resolution
    }
    pub fn clear_temp_resolution(&mut self) {
        self.temp_resolution = 0;
    }

    // Param is passed by value, moved
    pub fn set_temp_resolution(&mut self, v: u32) {
        self.temp_resolution = v;
    }

    // uint32 precision_factor = 6;


    pub fn get_precision_factor(&self) -> u32 {
        self.precision_factor
    }
    pub fn clear_precision_factor(&mut self) {
        self.precision_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_precision_factor(&mut self, v: u32) {
        self.precision_factor = v;
    }

    // .domopool.AnalogSensor ph = 7;


    pub fn get_ph(&self) -> &AnalogSensor {
        self.ph.as_ref().unwrap_or_else(|| <AnalogSensor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ph(&mut self) {
        self.ph.clear();
    }

    pub fn has_ph(&self) -> bool {
        self.ph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ph(&mut self, v: AnalogSensor) {
        self.ph = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ph(&mut self) -> &mut AnalogSensor {
        if self.ph.is_none() {
            self.ph.set_default();
        }
        self.ph.as_mut().unwrap()
    }

    // Take field
    pub fn take_ph(&mut self) -> AnalogSensor {
        self.ph.take().unwrap_or_else(|| AnalogSensor::new())
    }

    // .domopool.AnalogSensor ch = 8;


    pub fn get_ch(&self) -> &AnalogSensor {
        self.ch.as_ref().unwrap_or_else(|| <AnalogSensor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ch(&mut self) {
        self.ch.clear();
    }

    pub fn has_ch(&self) -> bool {
        self.ch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ch(&mut self, v: AnalogSensor) {
        self.ch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ch(&mut self) -> &mut AnalogSensor {
        if self.ch.is_none() {
            self.ch.set_default();
        }
        self.ch.as_mut().unwrap()
    }

    // Take field
    pub fn take_ch(&mut self) -> AnalogSensor {
        self.ch.take().unwrap_or_else(|| AnalogSensor::new())
    }

    // .domopool.AnalogSensor wp = 9;


    pub fn get_wp(&self) -> &AnalogSensor {
        self.wp.as_ref().unwrap_or_else(|| <AnalogSensor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_wp(&mut self) {
        self.wp.clear();
    }

    pub fn has_wp(&self) -> bool {
        self.wp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wp(&mut self, v: AnalogSensor) {
        self.wp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wp(&mut self) -> &mut AnalogSensor {
        if self.wp.is_none() {
            self.wp.set_default();
        }
        self.wp.as_mut().unwrap()
    }

    // Take field
    pub fn take_wp(&mut self) -> AnalogSensor {
        self.wp.take().unwrap_or_else(|| AnalogSensor::new())
    }

    // uint32 adc_mode = 10;


    pub fn get_adc_mode(&self) -> u32 {
        self.adc_mode
    }
    pub fn clear_adc_mode(&mut self) {
        self.adc_mode = 0;
    }

    // Param is passed by value, moved
    pub fn set_adc_mode(&mut self, v: u32) {
        self.adc_mode = v;
    }

    // uint32 adc_datarate = 11;


    pub fn get_adc_datarate(&self) -> u32 {
        self.adc_datarate
    }
    pub fn clear_adc_datarate(&mut self) {
        self.adc_datarate = 0;
    }

    // Param is passed by value, moved
    pub fn set_adc_datarate(&mut self, v: u32) {
        self.adc_datarate = v;
    }

    // uint32 adc_gain = 12;


    pub fn get_adc_gain(&self) -> u32 {
        self.adc_gain
    }
    pub fn clear_adc_gain(&mut self) {
        self.adc_gain = 0;
    }

    // Param is passed by value, moved
    pub fn set_adc_gain(&mut self, v: u32) {
        self.adc_gain = v;
    }
}

impl ::protobuf::Message for Sensors {
    fn is_initialized(&self) -> bool {
        for v in &self.twin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.twout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tamb {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ph {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.twin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.twout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tamb)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wait_for_conversion = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.temp_resolution = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.precision_factor = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ph)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ch)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wp)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.adc_mode = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.adc_datarate = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.adc_gain = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.twin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.twout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tamb.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.wait_for_conversion != false {
            my_size += 2;
        }
        if self.temp_resolution != 0 {
            my_size += ::protobuf::rt::value_size(5, self.temp_resolution, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.precision_factor != 0 {
            my_size += ::protobuf::rt::value_size(6, self.precision_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.wp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.adc_mode != 0 {
            my_size += ::protobuf::rt::value_size(10, self.adc_mode, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.adc_datarate != 0 {
            my_size += ::protobuf::rt::value_size(11, self.adc_datarate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.adc_gain != 0 {
            my_size += ::protobuf::rt::value_size(12, self.adc_gain, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.twin.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.twout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tamb.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.wait_for_conversion != false {
            os.write_bool(4, self.wait_for_conversion)?;
        }
        if self.temp_resolution != 0 {
            os.write_uint32(5, self.temp_resolution)?;
        }
        if self.precision_factor != 0 {
            os.write_uint32(6, self.precision_factor)?;
        }
        if let Some(ref v) = self.ph.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ch.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.wp.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.adc_mode != 0 {
            os.write_uint32(10, self.adc_mode)?;
        }
        if self.adc_datarate != 0 {
            os.write_uint32(11, self.adc_datarate)?;
        }
        if self.adc_gain != 0 {
            os.write_uint32(12, self.adc_gain)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sensors {
        Sensors::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Temp>>(
                "twin",
                |m: &Sensors| { &m.twin },
                |m: &mut Sensors| { &mut m.twin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Temp>>(
                "twout",
                |m: &Sensors| { &m.twout },
                |m: &mut Sensors| { &mut m.twout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Temp>>(
                "tamb",
                |m: &Sensors| { &m.tamb },
                |m: &mut Sensors| { &mut m.tamb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wait_for_conversion",
                |m: &Sensors| { &m.wait_for_conversion },
                |m: &mut Sensors| { &mut m.wait_for_conversion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "temp_resolution",
                |m: &Sensors| { &m.temp_resolution },
                |m: &mut Sensors| { &mut m.temp_resolution },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "precision_factor",
                |m: &Sensors| { &m.precision_factor },
                |m: &mut Sensors| { &mut m.precision_factor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogSensor>>(
                "ph",
                |m: &Sensors| { &m.ph },
                |m: &mut Sensors| { &mut m.ph },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogSensor>>(
                "ch",
                |m: &Sensors| { &m.ch },
                |m: &mut Sensors| { &mut m.ch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnalogSensor>>(
                "wp",
                |m: &Sensors| { &m.wp },
                |m: &mut Sensors| { &mut m.wp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "adc_mode",
                |m: &Sensors| { &m.adc_mode },
                |m: &mut Sensors| { &mut m.adc_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "adc_datarate",
                |m: &Sensors| { &m.adc_datarate },
                |m: &mut Sensors| { &mut m.adc_datarate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "adc_gain",
                |m: &Sensors| { &m.adc_gain },
                |m: &mut Sensors| { &mut m.adc_gain },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Sensors>(
                "Sensors",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Sensors {
        static instance: ::protobuf::rt::LazyV2<Sensors> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Sensors::new)
    }
}

impl ::protobuf::Clear for Sensors {
    fn clear(&mut self) {
        self.twin.clear();
        self.twout.clear();
        self.tamb.clear();
        self.wait_for_conversion = false;
        self.temp_resolution = 0;
        self.precision_factor = 0;
        self.ph.clear();
        self.ch.clear();
        self.wp.clear();
        self.adc_mode = 0;
        self.adc_datarate = 0;
        self.adc_gain = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sensors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sensors {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Global {
    // message fields
    pub lcd_backlight_duration: u32,
    pub ack_duration: u32,
    pub ack_tone: f64,
    pub serial_out: bool,
    pub display_startup: bool,
    pub force_light: bool,
    pub wdt_duration: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Global {
    fn default() -> &'a Global {
        <Global as ::protobuf::Message>::default_instance()
    }
}

impl Global {
    pub fn new() -> Global {
        ::std::default::Default::default()
    }

    // uint32 lcd_backlight_duration = 1;


    pub fn get_lcd_backlight_duration(&self) -> u32 {
        self.lcd_backlight_duration
    }
    pub fn clear_lcd_backlight_duration(&mut self) {
        self.lcd_backlight_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_lcd_backlight_duration(&mut self, v: u32) {
        self.lcd_backlight_duration = v;
    }

    // uint32 ack_duration = 2;


    pub fn get_ack_duration(&self) -> u32 {
        self.ack_duration
    }
    pub fn clear_ack_duration(&mut self) {
        self.ack_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_ack_duration(&mut self, v: u32) {
        self.ack_duration = v;
    }

    // double ack_tone = 3;


    pub fn get_ack_tone(&self) -> f64 {
        self.ack_tone
    }
    pub fn clear_ack_tone(&mut self) {
        self.ack_tone = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ack_tone(&mut self, v: f64) {
        self.ack_tone = v;
    }

    // bool serial_out = 4;


    pub fn get_serial_out(&self) -> bool {
        self.serial_out
    }
    pub fn clear_serial_out(&mut self) {
        self.serial_out = false;
    }

    // Param is passed by value, moved
    pub fn set_serial_out(&mut self, v: bool) {
        self.serial_out = v;
    }

    // bool display_startup = 5;


    pub fn get_display_startup(&self) -> bool {
        self.display_startup
    }
    pub fn clear_display_startup(&mut self) {
        self.display_startup = false;
    }

    // Param is passed by value, moved
    pub fn set_display_startup(&mut self, v: bool) {
        self.display_startup = v;
    }

    // bool force_light = 6;


    pub fn get_force_light(&self) -> bool {
        self.force_light
    }
    pub fn clear_force_light(&mut self) {
        self.force_light = false;
    }

    // Param is passed by value, moved
    pub fn set_force_light(&mut self, v: bool) {
        self.force_light = v;
    }

    // uint32 wdt_duration = 7;


    pub fn get_wdt_duration(&self) -> u32 {
        self.wdt_duration
    }
    pub fn clear_wdt_duration(&mut self) {
        self.wdt_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_wdt_duration(&mut self, v: u32) {
        self.wdt_duration = v;
    }
}

impl ::protobuf::Message for Global {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lcd_backlight_duration = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_duration = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.ack_tone = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serial_out = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.display_startup = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_light = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wdt_duration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lcd_backlight_duration != 0 {
            my_size += ::protobuf::rt::value_size(1, self.lcd_backlight_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ack_duration != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ack_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ack_tone != 0. {
            my_size += 9;
        }
        if self.serial_out != false {
            my_size += 2;
        }
        if self.display_startup != false {
            my_size += 2;
        }
        if self.force_light != false {
            my_size += 2;
        }
        if self.wdt_duration != 0 {
            my_size += ::protobuf::rt::value_size(7, self.wdt_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.lcd_backlight_duration != 0 {
            os.write_uint32(1, self.lcd_backlight_duration)?;
        }
        if self.ack_duration != 0 {
            os.write_uint32(2, self.ack_duration)?;
        }
        if self.ack_tone != 0. {
            os.write_double(3, self.ack_tone)?;
        }
        if self.serial_out != false {
            os.write_bool(4, self.serial_out)?;
        }
        if self.display_startup != false {
            os.write_bool(5, self.display_startup)?;
        }
        if self.force_light != false {
            os.write_bool(6, self.force_light)?;
        }
        if self.wdt_duration != 0 {
            os.write_uint32(7, self.wdt_duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Global {
        Global::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lcd_backlight_duration",
                |m: &Global| { &m.lcd_backlight_duration },
                |m: &mut Global| { &mut m.lcd_backlight_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_duration",
                |m: &Global| { &m.ack_duration },
                |m: &mut Global| { &mut m.ack_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "ack_tone",
                |m: &Global| { &m.ack_tone },
                |m: &mut Global| { &mut m.ack_tone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "serial_out",
                |m: &Global| { &m.serial_out },
                |m: &mut Global| { &mut m.serial_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "display_startup",
                |m: &Global| { &m.display_startup },
                |m: &mut Global| { &mut m.display_startup },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_light",
                |m: &Global| { &m.force_light },
                |m: &mut Global| { &mut m.force_light },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "wdt_duration",
                |m: &Global| { &m.wdt_duration },
                |m: &mut Global| { &mut m.wdt_duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Global>(
                "Global",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Global {
        static instance: ::protobuf::rt::LazyV2<Global> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Global::new)
    }
}

impl ::protobuf::Clear for Global {
    fn clear(&mut self) {
        self.lcd_backlight_duration = 0;
        self.ack_duration = 0;
        self.ack_tone = 0.;
        self.serial_out = false;
        self.display_startup = false;
        self.force_light = false;
        self.wdt_duration = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Global {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Global {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pump {
    // message fields
    pub force_filter: bool,
    pub force_ph: bool,
    pub force_ch: bool,
    pub automatic: bool,
    pub force_check: bool,
    pub force_duration: u32,
    pub force_start_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pump {
    fn default() -> &'a Pump {
        <Pump as ::protobuf::Message>::default_instance()
    }
}

impl Pump {
    pub fn new() -> Pump {
        ::std::default::Default::default()
    }

    // bool force_filter = 1;


    pub fn get_force_filter(&self) -> bool {
        self.force_filter
    }
    pub fn clear_force_filter(&mut self) {
        self.force_filter = false;
    }

    // Param is passed by value, moved
    pub fn set_force_filter(&mut self, v: bool) {
        self.force_filter = v;
    }

    // bool force_ph = 2;


    pub fn get_force_ph(&self) -> bool {
        self.force_ph
    }
    pub fn clear_force_ph(&mut self) {
        self.force_ph = false;
    }

    // Param is passed by value, moved
    pub fn set_force_ph(&mut self, v: bool) {
        self.force_ph = v;
    }

    // bool force_ch = 3;


    pub fn get_force_ch(&self) -> bool {
        self.force_ch
    }
    pub fn clear_force_ch(&mut self) {
        self.force_ch = false;
    }

    // Param is passed by value, moved
    pub fn set_force_ch(&mut self, v: bool) {
        self.force_ch = v;
    }

    // bool automatic = 4;


    pub fn get_automatic(&self) -> bool {
        self.automatic
    }
    pub fn clear_automatic(&mut self) {
        self.automatic = false;
    }

    // Param is passed by value, moved
    pub fn set_automatic(&mut self, v: bool) {
        self.automatic = v;
    }

    // bool force_check = 5;


    pub fn get_force_check(&self) -> bool {
        self.force_check
    }
    pub fn clear_force_check(&mut self) {
        self.force_check = false;
    }

    // Param is passed by value, moved
    pub fn set_force_check(&mut self, v: bool) {
        self.force_check = v;
    }

    // uint32 force_duration = 6;


    pub fn get_force_duration(&self) -> u32 {
        self.force_duration
    }
    pub fn clear_force_duration(&mut self) {
        self.force_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_force_duration(&mut self, v: u32) {
        self.force_duration = v;
    }

    // uint32 force_start_time = 7;


    pub fn get_force_start_time(&self) -> u32 {
        self.force_start_time
    }
    pub fn clear_force_start_time(&mut self) {
        self.force_start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_force_start_time(&mut self, v: u32) {
        self.force_start_time = v;
    }
}

impl ::protobuf::Message for Pump {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_filter = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_ph = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_ch = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automatic = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_check = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.force_duration = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.force_start_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.force_filter != false {
            my_size += 2;
        }
        if self.force_ph != false {
            my_size += 2;
        }
        if self.force_ch != false {
            my_size += 2;
        }
        if self.automatic != false {
            my_size += 2;
        }
        if self.force_check != false {
            my_size += 2;
        }
        if self.force_duration != 0 {
            my_size += ::protobuf::rt::value_size(6, self.force_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.force_start_time != 0 {
            my_size += ::protobuf::rt::value_size(7, self.force_start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.force_filter != false {
            os.write_bool(1, self.force_filter)?;
        }
        if self.force_ph != false {
            os.write_bool(2, self.force_ph)?;
        }
        if self.force_ch != false {
            os.write_bool(3, self.force_ch)?;
        }
        if self.automatic != false {
            os.write_bool(4, self.automatic)?;
        }
        if self.force_check != false {
            os.write_bool(5, self.force_check)?;
        }
        if self.force_duration != 0 {
            os.write_uint32(6, self.force_duration)?;
        }
        if self.force_start_time != 0 {
            os.write_uint32(7, self.force_start_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pump {
        Pump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_filter",
                |m: &Pump| { &m.force_filter },
                |m: &mut Pump| { &mut m.force_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_ph",
                |m: &Pump| { &m.force_ph },
                |m: &mut Pump| { &mut m.force_ph },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_ch",
                |m: &Pump| { &m.force_ch },
                |m: &mut Pump| { &mut m.force_ch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "automatic",
                |m: &Pump| { &m.automatic },
                |m: &mut Pump| { &mut m.automatic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_check",
                |m: &Pump| { &m.force_check },
                |m: &mut Pump| { &mut m.force_check },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "force_duration",
                |m: &Pump| { &m.force_duration },
                |m: &mut Pump| { &mut m.force_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "force_start_time",
                |m: &Pump| { &m.force_start_time },
                |m: &mut Pump| { &mut m.force_start_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pump>(
                "Pump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pump {
        static instance: ::protobuf::rt::LazyV2<Pump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pump::new)
    }
}

impl ::protobuf::Clear for Pump {
    fn clear(&mut self) {
        self.force_filter = false;
        self.force_ph = false;
        self.force_ch = false;
        self.automatic = false;
        self.force_check = false;
        self.force_duration = 0;
        self.force_start_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ads115Alarms {
    // message fields
    pub not_ready: bool,
    pub not_started: bool,
    pub not_connected: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ads115Alarms {
    fn default() -> &'a Ads115Alarms {
        <Ads115Alarms as ::protobuf::Message>::default_instance()
    }
}

impl Ads115Alarms {
    pub fn new() -> Ads115Alarms {
        ::std::default::Default::default()
    }

    // bool not_ready = 1;


    pub fn get_not_ready(&self) -> bool {
        self.not_ready
    }
    pub fn clear_not_ready(&mut self) {
        self.not_ready = false;
    }

    // Param is passed by value, moved
    pub fn set_not_ready(&mut self, v: bool) {
        self.not_ready = v;
    }

    // bool not_started = 2;


    pub fn get_not_started(&self) -> bool {
        self.not_started
    }
    pub fn clear_not_started(&mut self) {
        self.not_started = false;
    }

    // Param is passed by value, moved
    pub fn set_not_started(&mut self, v: bool) {
        self.not_started = v;
    }

    // bool not_connected = 3;


    pub fn get_not_connected(&self) -> bool {
        self.not_connected
    }
    pub fn clear_not_connected(&mut self) {
        self.not_connected = false;
    }

    // Param is passed by value, moved
    pub fn set_not_connected(&mut self, v: bool) {
        self.not_connected = v;
    }
}

impl ::protobuf::Message for Ads115Alarms {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_ready = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_started = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_connected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.not_ready != false {
            my_size += 2;
        }
        if self.not_started != false {
            my_size += 2;
        }
        if self.not_connected != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.not_ready != false {
            os.write_bool(1, self.not_ready)?;
        }
        if self.not_started != false {
            os.write_bool(2, self.not_started)?;
        }
        if self.not_connected != false {
            os.write_bool(3, self.not_connected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ads115Alarms {
        Ads115Alarms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_ready",
                |m: &Ads115Alarms| { &m.not_ready },
                |m: &mut Ads115Alarms| { &mut m.not_ready },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_started",
                |m: &Ads115Alarms| { &m.not_started },
                |m: &mut Ads115Alarms| { &mut m.not_started },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_connected",
                |m: &Ads115Alarms| { &m.not_connected },
                |m: &mut Ads115Alarms| { &mut m.not_connected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ads115Alarms>(
                "Ads115Alarms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ads115Alarms {
        static instance: ::protobuf::rt::LazyV2<Ads115Alarms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ads115Alarms::new)
    }
}

impl ::protobuf::Clear for Ads115Alarms {
    fn clear(&mut self) {
        self.not_ready = false;
        self.not_started = false;
        self.not_connected = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ads115Alarms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ads115Alarms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MqttAlarms {
    // message fields
    pub metrics: bool,
    pub states: bool,
    pub alarms: bool,
    pub temps: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MqttAlarms {
    fn default() -> &'a MqttAlarms {
        <MqttAlarms as ::protobuf::Message>::default_instance()
    }
}

impl MqttAlarms {
    pub fn new() -> MqttAlarms {
        ::std::default::Default::default()
    }

    // bool metrics = 1;


    pub fn get_metrics(&self) -> bool {
        self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics = false;
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: bool) {
        self.metrics = v;
    }

    // bool states = 2;


    pub fn get_states(&self) -> bool {
        self.states
    }
    pub fn clear_states(&mut self) {
        self.states = false;
    }

    // Param is passed by value, moved
    pub fn set_states(&mut self, v: bool) {
        self.states = v;
    }

    // bool alarms = 3;


    pub fn get_alarms(&self) -> bool {
        self.alarms
    }
    pub fn clear_alarms(&mut self) {
        self.alarms = false;
    }

    // Param is passed by value, moved
    pub fn set_alarms(&mut self, v: bool) {
        self.alarms = v;
    }

    // bool temps = 4;


    pub fn get_temps(&self) -> bool {
        self.temps
    }
    pub fn clear_temps(&mut self) {
        self.temps = false;
    }

    // Param is passed by value, moved
    pub fn set_temps(&mut self, v: bool) {
        self.temps = v;
    }
}

impl ::protobuf::Message for MqttAlarms {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.metrics = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.states = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.alarms = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.temps = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.metrics != false {
            my_size += 2;
        }
        if self.states != false {
            my_size += 2;
        }
        if self.alarms != false {
            my_size += 2;
        }
        if self.temps != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.metrics != false {
            os.write_bool(1, self.metrics)?;
        }
        if self.states != false {
            os.write_bool(2, self.states)?;
        }
        if self.alarms != false {
            os.write_bool(3, self.alarms)?;
        }
        if self.temps != false {
            os.write_bool(4, self.temps)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MqttAlarms {
        MqttAlarms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "metrics",
                |m: &MqttAlarms| { &m.metrics },
                |m: &mut MqttAlarms| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "states",
                |m: &MqttAlarms| { &m.states },
                |m: &mut MqttAlarms| { &mut m.states },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "alarms",
                |m: &MqttAlarms| { &m.alarms },
                |m: &mut MqttAlarms| { &mut m.alarms },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "temps",
                |m: &MqttAlarms| { &m.temps },
                |m: &mut MqttAlarms| { &mut m.temps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MqttAlarms>(
                "MqttAlarms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MqttAlarms {
        static instance: ::protobuf::rt::LazyV2<MqttAlarms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MqttAlarms::new)
    }
}

impl ::protobuf::Clear for MqttAlarms {
    fn clear(&mut self) {
        self.metrics = false;
        self.states = false;
        self.alarms = false;
        self.temps = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MqttAlarms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MqttAlarms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Alarms {
    // message fields
    pub filter: bool,
    pub ph: bool,
    pub ch: bool,
    pub rtc: bool,
    pub wp_high: bool,
    pub wp_low: bool,
    pub wp_broken: bool,
    pub ads1115: ::protobuf::SingularPtrField<Ads115Alarms>,
    pub tw_frost: bool,
    pub tw_high: bool,
    pub tamb_frost: bool,
    pub mqtt: ::protobuf::SingularPtrField<MqttAlarms>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Alarms {
    fn default() -> &'a Alarms {
        <Alarms as ::protobuf::Message>::default_instance()
    }
}

impl Alarms {
    pub fn new() -> Alarms {
        ::std::default::Default::default()
    }

    // bool filter = 1;


    pub fn get_filter(&self) -> bool {
        self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter = false;
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: bool) {
        self.filter = v;
    }

    // bool ph = 2;


    pub fn get_ph(&self) -> bool {
        self.ph
    }
    pub fn clear_ph(&mut self) {
        self.ph = false;
    }

    // Param is passed by value, moved
    pub fn set_ph(&mut self, v: bool) {
        self.ph = v;
    }

    // bool ch = 3;


    pub fn get_ch(&self) -> bool {
        self.ch
    }
    pub fn clear_ch(&mut self) {
        self.ch = false;
    }

    // Param is passed by value, moved
    pub fn set_ch(&mut self, v: bool) {
        self.ch = v;
    }

    // bool rtc = 5;


    pub fn get_rtc(&self) -> bool {
        self.rtc
    }
    pub fn clear_rtc(&mut self) {
        self.rtc = false;
    }

    // Param is passed by value, moved
    pub fn set_rtc(&mut self, v: bool) {
        self.rtc = v;
    }

    // bool wp_high = 6;


    pub fn get_wp_high(&self) -> bool {
        self.wp_high
    }
    pub fn clear_wp_high(&mut self) {
        self.wp_high = false;
    }

    // Param is passed by value, moved
    pub fn set_wp_high(&mut self, v: bool) {
        self.wp_high = v;
    }

    // bool wp_low = 7;


    pub fn get_wp_low(&self) -> bool {
        self.wp_low
    }
    pub fn clear_wp_low(&mut self) {
        self.wp_low = false;
    }

    // Param is passed by value, moved
    pub fn set_wp_low(&mut self, v: bool) {
        self.wp_low = v;
    }

    // bool wp_broken = 8;


    pub fn get_wp_broken(&self) -> bool {
        self.wp_broken
    }
    pub fn clear_wp_broken(&mut self) {
        self.wp_broken = false;
    }

    // Param is passed by value, moved
    pub fn set_wp_broken(&mut self, v: bool) {
        self.wp_broken = v;
    }

    // .domopool.Ads115Alarms ads1115 = 9;


    pub fn get_ads1115(&self) -> &Ads115Alarms {
        self.ads1115.as_ref().unwrap_or_else(|| <Ads115Alarms as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ads1115(&mut self) {
        self.ads1115.clear();
    }

    pub fn has_ads1115(&self) -> bool {
        self.ads1115.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ads1115(&mut self, v: Ads115Alarms) {
        self.ads1115 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ads1115(&mut self) -> &mut Ads115Alarms {
        if self.ads1115.is_none() {
            self.ads1115.set_default();
        }
        self.ads1115.as_mut().unwrap()
    }

    // Take field
    pub fn take_ads1115(&mut self) -> Ads115Alarms {
        self.ads1115.take().unwrap_or_else(|| Ads115Alarms::new())
    }

    // bool tw_frost = 10;


    pub fn get_tw_frost(&self) -> bool {
        self.tw_frost
    }
    pub fn clear_tw_frost(&mut self) {
        self.tw_frost = false;
    }

    // Param is passed by value, moved
    pub fn set_tw_frost(&mut self, v: bool) {
        self.tw_frost = v;
    }

    // bool tw_high = 11;


    pub fn get_tw_high(&self) -> bool {
        self.tw_high
    }
    pub fn clear_tw_high(&mut self) {
        self.tw_high = false;
    }

    // Param is passed by value, moved
    pub fn set_tw_high(&mut self, v: bool) {
        self.tw_high = v;
    }

    // bool tamb_frost = 12;


    pub fn get_tamb_frost(&self) -> bool {
        self.tamb_frost
    }
    pub fn clear_tamb_frost(&mut self) {
        self.tamb_frost = false;
    }

    // Param is passed by value, moved
    pub fn set_tamb_frost(&mut self, v: bool) {
        self.tamb_frost = v;
    }

    // .domopool.MqttAlarms mqtt = 13;


    pub fn get_mqtt(&self) -> &MqttAlarms {
        self.mqtt.as_ref().unwrap_or_else(|| <MqttAlarms as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mqtt(&mut self) {
        self.mqtt.clear();
    }

    pub fn has_mqtt(&self) -> bool {
        self.mqtt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: MqttAlarms) {
        self.mqtt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mqtt(&mut self) -> &mut MqttAlarms {
        if self.mqtt.is_none() {
            self.mqtt.set_default();
        }
        self.mqtt.as_mut().unwrap()
    }

    // Take field
    pub fn take_mqtt(&mut self) -> MqttAlarms {
        self.mqtt.take().unwrap_or_else(|| MqttAlarms::new())
    }
}

impl ::protobuf::Message for Alarms {
    fn is_initialized(&self) -> bool {
        for v in &self.ads1115 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mqtt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filter = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ph = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ch = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rtc = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wp_high = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wp_low = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.wp_broken = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ads1115)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tw_frost = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tw_high = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tamb_frost = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mqtt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.filter != false {
            my_size += 2;
        }
        if self.ph != false {
            my_size += 2;
        }
        if self.ch != false {
            my_size += 2;
        }
        if self.rtc != false {
            my_size += 2;
        }
        if self.wp_high != false {
            my_size += 2;
        }
        if self.wp_low != false {
            my_size += 2;
        }
        if self.wp_broken != false {
            my_size += 2;
        }
        if let Some(ref v) = self.ads1115.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.tw_frost != false {
            my_size += 2;
        }
        if self.tw_high != false {
            my_size += 2;
        }
        if self.tamb_frost != false {
            my_size += 2;
        }
        if let Some(ref v) = self.mqtt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.filter != false {
            os.write_bool(1, self.filter)?;
        }
        if self.ph != false {
            os.write_bool(2, self.ph)?;
        }
        if self.ch != false {
            os.write_bool(3, self.ch)?;
        }
        if self.rtc != false {
            os.write_bool(5, self.rtc)?;
        }
        if self.wp_high != false {
            os.write_bool(6, self.wp_high)?;
        }
        if self.wp_low != false {
            os.write_bool(7, self.wp_low)?;
        }
        if self.wp_broken != false {
            os.write_bool(8, self.wp_broken)?;
        }
        if let Some(ref v) = self.ads1115.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.tw_frost != false {
            os.write_bool(10, self.tw_frost)?;
        }
        if self.tw_high != false {
            os.write_bool(11, self.tw_high)?;
        }
        if self.tamb_frost != false {
            os.write_bool(12, self.tamb_frost)?;
        }
        if let Some(ref v) = self.mqtt.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Alarms {
        Alarms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "filter",
                |m: &Alarms| { &m.filter },
                |m: &mut Alarms| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ph",
                |m: &Alarms| { &m.ph },
                |m: &mut Alarms| { &mut m.ph },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ch",
                |m: &Alarms| { &m.ch },
                |m: &mut Alarms| { &mut m.ch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rtc",
                |m: &Alarms| { &m.rtc },
                |m: &mut Alarms| { &mut m.rtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wp_high",
                |m: &Alarms| { &m.wp_high },
                |m: &mut Alarms| { &mut m.wp_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wp_low",
                |m: &Alarms| { &m.wp_low },
                |m: &mut Alarms| { &mut m.wp_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "wp_broken",
                |m: &Alarms| { &m.wp_broken },
                |m: &mut Alarms| { &mut m.wp_broken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ads115Alarms>>(
                "ads1115",
                |m: &Alarms| { &m.ads1115 },
                |m: &mut Alarms| { &mut m.ads1115 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tw_frost",
                |m: &Alarms| { &m.tw_frost },
                |m: &mut Alarms| { &mut m.tw_frost },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tw_high",
                |m: &Alarms| { &m.tw_high },
                |m: &mut Alarms| { &mut m.tw_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tamb_frost",
                |m: &Alarms| { &m.tamb_frost },
                |m: &mut Alarms| { &mut m.tamb_frost },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MqttAlarms>>(
                "mqtt",
                |m: &Alarms| { &m.mqtt },
                |m: &mut Alarms| { &mut m.mqtt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Alarms>(
                "Alarms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Alarms {
        static instance: ::protobuf::rt::LazyV2<Alarms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Alarms::new)
    }
}

impl ::protobuf::Clear for Alarms {
    fn clear(&mut self) {
        self.filter = false;
        self.ph = false;
        self.ch = false;
        self.rtc = false;
        self.wp_high = false;
        self.wp_low = false;
        self.wp_broken = false;
        self.ads1115.clear();
        self.tw_frost = false;
        self.tw_high = false;
        self.tamb_frost = false;
        self.mqtt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Alarms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Alarms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tests {
    // message fields
    pub enabled: bool,
    pub twater: f32,
    pub tamb: f32,
    pub ph: f32,
    pub pressure: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tests {
    fn default() -> &'a Tests {
        <Tests as ::protobuf::Message>::default_instance()
    }
}

impl Tests {
    pub fn new() -> Tests {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // float twater = 2;


    pub fn get_twater(&self) -> f32 {
        self.twater
    }
    pub fn clear_twater(&mut self) {
        self.twater = 0.;
    }

    // Param is passed by value, moved
    pub fn set_twater(&mut self, v: f32) {
        self.twater = v;
    }

    // float tamb = 3;


    pub fn get_tamb(&self) -> f32 {
        self.tamb
    }
    pub fn clear_tamb(&mut self) {
        self.tamb = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tamb(&mut self, v: f32) {
        self.tamb = v;
    }

    // float ph = 4;


    pub fn get_ph(&self) -> f32 {
        self.ph
    }
    pub fn clear_ph(&mut self) {
        self.ph = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ph(&mut self, v: f32) {
        self.ph = v;
    }

    // float pressure = 5;


    pub fn get_pressure(&self) -> f32 {
        self.pressure
    }
    pub fn clear_pressure(&mut self) {
        self.pressure = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pressure(&mut self, v: f32) {
        self.pressure = v;
    }
}

impl ::protobuf::Message for Tests {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.twater = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tamb = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ph = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pressure = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.twater != 0. {
            my_size += 5;
        }
        if self.tamb != 0. {
            my_size += 5;
        }
        if self.ph != 0. {
            my_size += 5;
        }
        if self.pressure != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.twater != 0. {
            os.write_float(2, self.twater)?;
        }
        if self.tamb != 0. {
            os.write_float(3, self.tamb)?;
        }
        if self.ph != 0. {
            os.write_float(4, self.ph)?;
        }
        if self.pressure != 0. {
            os.write_float(5, self.pressure)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tests {
        Tests::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &Tests| { &m.enabled },
                |m: &mut Tests| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "twater",
                |m: &Tests| { &m.twater },
                |m: &mut Tests| { &mut m.twater },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tamb",
                |m: &Tests| { &m.tamb },
                |m: &mut Tests| { &mut m.tamb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ph",
                |m: &Tests| { &m.ph },
                |m: &mut Tests| { &mut m.ph },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pressure",
                |m: &Tests| { &m.pressure },
                |m: &mut Tests| { &mut m.pressure },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tests>(
                "Tests",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tests {
        static instance: ::protobuf::rt::LazyV2<Tests> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tests::new)
    }
}

impl ::protobuf::Clear for Tests {
    fn clear(&mut self) {
        self.enabled = false;
        self.twater = 0.;
        self.tamb = 0.;
        self.ph = 0.;
        self.pressure = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tests {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Metrics {
    // message fields
    pub tamb: f32,
    pub twater: f32,
    pub saved_twater: f32,
    pub ph: f32,
    pub ch: f32,
    pub wp: f32,
    pub wp_volt: f32,
    pub over_15_duration: u32,
    pub hour: u32,
    pub time: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metrics {
    fn default() -> &'a Metrics {
        <Metrics as ::protobuf::Message>::default_instance()
    }
}

impl Metrics {
    pub fn new() -> Metrics {
        ::std::default::Default::default()
    }

    // float tamb = 1;


    pub fn get_tamb(&self) -> f32 {
        self.tamb
    }
    pub fn clear_tamb(&mut self) {
        self.tamb = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tamb(&mut self, v: f32) {
        self.tamb = v;
    }

    // float twater = 2;


    pub fn get_twater(&self) -> f32 {
        self.twater
    }
    pub fn clear_twater(&mut self) {
        self.twater = 0.;
    }

    // Param is passed by value, moved
    pub fn set_twater(&mut self, v: f32) {
        self.twater = v;
    }

    // float saved_twater = 3;


    pub fn get_saved_twater(&self) -> f32 {
        self.saved_twater
    }
    pub fn clear_saved_twater(&mut self) {
        self.saved_twater = 0.;
    }

    // Param is passed by value, moved
    pub fn set_saved_twater(&mut self, v: f32) {
        self.saved_twater = v;
    }

    // float ph = 4;


    pub fn get_ph(&self) -> f32 {
        self.ph
    }
    pub fn clear_ph(&mut self) {
        self.ph = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ph(&mut self, v: f32) {
        self.ph = v;
    }

    // float ch = 5;


    pub fn get_ch(&self) -> f32 {
        self.ch
    }
    pub fn clear_ch(&mut self) {
        self.ch = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ch(&mut self, v: f32) {
        self.ch = v;
    }

    // float wp = 6;


    pub fn get_wp(&self) -> f32 {
        self.wp
    }
    pub fn clear_wp(&mut self) {
        self.wp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wp(&mut self, v: f32) {
        self.wp = v;
    }

    // float wp_volt = 7;


    pub fn get_wp_volt(&self) -> f32 {
        self.wp_volt
    }
    pub fn clear_wp_volt(&mut self) {
        self.wp_volt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wp_volt(&mut self, v: f32) {
        self.wp_volt = v;
    }

    // uint32 over_15_duration = 8;


    pub fn get_over_15_duration(&self) -> u32 {
        self.over_15_duration
    }
    pub fn clear_over_15_duration(&mut self) {
        self.over_15_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_over_15_duration(&mut self, v: u32) {
        self.over_15_duration = v;
    }

    // uint32 hour = 9;


    pub fn get_hour(&self) -> u32 {
        self.hour
    }
    pub fn clear_hour(&mut self) {
        self.hour = 0;
    }

    // Param is passed by value, moved
    pub fn set_hour(&mut self, v: u32) {
        self.hour = v;
    }

    // string time = 10;


    pub fn get_time(&self) -> &str {
        &self.time
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::std::string::String) {
        self.time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::std::string::String {
        &mut self.time
    }

    // Take field
    pub fn take_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.time, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Metrics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tamb = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.twater = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.saved_twater = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ph = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ch = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wp_volt = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.over_15_duration = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hour = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tamb != 0. {
            my_size += 5;
        }
        if self.twater != 0. {
            my_size += 5;
        }
        if self.saved_twater != 0. {
            my_size += 5;
        }
        if self.ph != 0. {
            my_size += 5;
        }
        if self.ch != 0. {
            my_size += 5;
        }
        if self.wp != 0. {
            my_size += 5;
        }
        if self.wp_volt != 0. {
            my_size += 5;
        }
        if self.over_15_duration != 0 {
            my_size += ::protobuf::rt::value_size(8, self.over_15_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hour != 0 {
            my_size += ::protobuf::rt::value_size(9, self.hour, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.time.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tamb != 0. {
            os.write_float(1, self.tamb)?;
        }
        if self.twater != 0. {
            os.write_float(2, self.twater)?;
        }
        if self.saved_twater != 0. {
            os.write_float(3, self.saved_twater)?;
        }
        if self.ph != 0. {
            os.write_float(4, self.ph)?;
        }
        if self.ch != 0. {
            os.write_float(5, self.ch)?;
        }
        if self.wp != 0. {
            os.write_float(6, self.wp)?;
        }
        if self.wp_volt != 0. {
            os.write_float(7, self.wp_volt)?;
        }
        if self.over_15_duration != 0 {
            os.write_uint32(8, self.over_15_duration)?;
        }
        if self.hour != 0 {
            os.write_uint32(9, self.hour)?;
        }
        if !self.time.is_empty() {
            os.write_string(10, &self.time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metrics {
        Metrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tamb",
                |m: &Metrics| { &m.tamb },
                |m: &mut Metrics| { &mut m.tamb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "twater",
                |m: &Metrics| { &m.twater },
                |m: &mut Metrics| { &mut m.twater },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "saved_twater",
                |m: &Metrics| { &m.saved_twater },
                |m: &mut Metrics| { &mut m.saved_twater },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ph",
                |m: &Metrics| { &m.ph },
                |m: &mut Metrics| { &mut m.ph },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ch",
                |m: &Metrics| { &m.ch },
                |m: &mut Metrics| { &mut m.ch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wp",
                |m: &Metrics| { &m.wp },
                |m: &mut Metrics| { &mut m.wp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wp_volt",
                |m: &Metrics| { &m.wp_volt },
                |m: &mut Metrics| { &mut m.wp_volt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "over_15_duration",
                |m: &Metrics| { &m.over_15_duration },
                |m: &mut Metrics| { &mut m.over_15_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hour",
                |m: &Metrics| { &m.hour },
                |m: &mut Metrics| { &mut m.hour },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "time",
                |m: &Metrics| { &m.time },
                |m: &mut Metrics| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Metrics>(
                "Metrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Metrics {
        static instance: ::protobuf::rt::LazyV2<Metrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Metrics::new)
    }
}

impl ::protobuf::Clear for Metrics {
    fn clear(&mut self) {
        self.tamb = 0.;
        self.twater = 0.;
        self.saved_twater = 0.;
        self.ph = 0.;
        self.ch = 0.;
        self.wp = 0.;
        self.wp_volt = 0.;
        self.over_15_duration = 0;
        self.hour = 0;
        self.time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct States {
    // message fields
    pub startup: bool,
    pub filter_on: bool,
    pub ph_on: bool,
    pub ch_on: bool,
    pub automatic: bool,
    pub net_active: bool,
    pub ntp: bool,
    pub rtc: bool,
    pub light_on: bool,
    pub mqtt_connected: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a States {
    fn default() -> &'a States {
        <States as ::protobuf::Message>::default_instance()
    }
}

impl States {
    pub fn new() -> States {
        ::std::default::Default::default()
    }

    // bool startup = 1;


    pub fn get_startup(&self) -> bool {
        self.startup
    }
    pub fn clear_startup(&mut self) {
        self.startup = false;
    }

    // Param is passed by value, moved
    pub fn set_startup(&mut self, v: bool) {
        self.startup = v;
    }

    // bool filter_on = 2;


    pub fn get_filter_on(&self) -> bool {
        self.filter_on
    }
    pub fn clear_filter_on(&mut self) {
        self.filter_on = false;
    }

    // Param is passed by value, moved
    pub fn set_filter_on(&mut self, v: bool) {
        self.filter_on = v;
    }

    // bool ph_on = 3;


    pub fn get_ph_on(&self) -> bool {
        self.ph_on
    }
    pub fn clear_ph_on(&mut self) {
        self.ph_on = false;
    }

    // Param is passed by value, moved
    pub fn set_ph_on(&mut self, v: bool) {
        self.ph_on = v;
    }

    // bool ch_on = 4;


    pub fn get_ch_on(&self) -> bool {
        self.ch_on
    }
    pub fn clear_ch_on(&mut self) {
        self.ch_on = false;
    }

    // Param is passed by value, moved
    pub fn set_ch_on(&mut self, v: bool) {
        self.ch_on = v;
    }

    // bool automatic = 5;


    pub fn get_automatic(&self) -> bool {
        self.automatic
    }
    pub fn clear_automatic(&mut self) {
        self.automatic = false;
    }

    // Param is passed by value, moved
    pub fn set_automatic(&mut self, v: bool) {
        self.automatic = v;
    }

    // bool net_active = 6;


    pub fn get_net_active(&self) -> bool {
        self.net_active
    }
    pub fn clear_net_active(&mut self) {
        self.net_active = false;
    }

    // Param is passed by value, moved
    pub fn set_net_active(&mut self, v: bool) {
        self.net_active = v;
    }

    // bool ntp = 7;


    pub fn get_ntp(&self) -> bool {
        self.ntp
    }
    pub fn clear_ntp(&mut self) {
        self.ntp = false;
    }

    // Param is passed by value, moved
    pub fn set_ntp(&mut self, v: bool) {
        self.ntp = v;
    }

    // bool rtc = 8;


    pub fn get_rtc(&self) -> bool {
        self.rtc
    }
    pub fn clear_rtc(&mut self) {
        self.rtc = false;
    }

    // Param is passed by value, moved
    pub fn set_rtc(&mut self, v: bool) {
        self.rtc = v;
    }

    // bool light_on = 9;


    pub fn get_light_on(&self) -> bool {
        self.light_on
    }
    pub fn clear_light_on(&mut self) {
        self.light_on = false;
    }

    // Param is passed by value, moved
    pub fn set_light_on(&mut self, v: bool) {
        self.light_on = v;
    }

    // bool mqtt_connected = 10;


    pub fn get_mqtt_connected(&self) -> bool {
        self.mqtt_connected
    }
    pub fn clear_mqtt_connected(&mut self) {
        self.mqtt_connected = false;
    }

    // Param is passed by value, moved
    pub fn set_mqtt_connected(&mut self, v: bool) {
        self.mqtt_connected = v;
    }
}

impl ::protobuf::Message for States {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.startup = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filter_on = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ph_on = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ch_on = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automatic = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.net_active = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ntp = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rtc = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.light_on = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mqtt_connected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.startup != false {
            my_size += 2;
        }
        if self.filter_on != false {
            my_size += 2;
        }
        if self.ph_on != false {
            my_size += 2;
        }
        if self.ch_on != false {
            my_size += 2;
        }
        if self.automatic != false {
            my_size += 2;
        }
        if self.net_active != false {
            my_size += 2;
        }
        if self.ntp != false {
            my_size += 2;
        }
        if self.rtc != false {
            my_size += 2;
        }
        if self.light_on != false {
            my_size += 2;
        }
        if self.mqtt_connected != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.startup != false {
            os.write_bool(1, self.startup)?;
        }
        if self.filter_on != false {
            os.write_bool(2, self.filter_on)?;
        }
        if self.ph_on != false {
            os.write_bool(3, self.ph_on)?;
        }
        if self.ch_on != false {
            os.write_bool(4, self.ch_on)?;
        }
        if self.automatic != false {
            os.write_bool(5, self.automatic)?;
        }
        if self.net_active != false {
            os.write_bool(6, self.net_active)?;
        }
        if self.ntp != false {
            os.write_bool(7, self.ntp)?;
        }
        if self.rtc != false {
            os.write_bool(8, self.rtc)?;
        }
        if self.light_on != false {
            os.write_bool(9, self.light_on)?;
        }
        if self.mqtt_connected != false {
            os.write_bool(10, self.mqtt_connected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> States {
        States::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "startup",
                |m: &States| { &m.startup },
                |m: &mut States| { &mut m.startup },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "filter_on",
                |m: &States| { &m.filter_on },
                |m: &mut States| { &mut m.filter_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ph_on",
                |m: &States| { &m.ph_on },
                |m: &mut States| { &mut m.ph_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ch_on",
                |m: &States| { &m.ch_on },
                |m: &mut States| { &mut m.ch_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "automatic",
                |m: &States| { &m.automatic },
                |m: &mut States| { &mut m.automatic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "net_active",
                |m: &States| { &m.net_active },
                |m: &mut States| { &mut m.net_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ntp",
                |m: &States| { &m.ntp },
                |m: &mut States| { &mut m.ntp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rtc",
                |m: &States| { &m.rtc },
                |m: &mut States| { &mut m.rtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "light_on",
                |m: &States| { &m.light_on },
                |m: &mut States| { &mut m.light_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mqtt_connected",
                |m: &States| { &m.mqtt_connected },
                |m: &mut States| { &mut m.mqtt_connected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<States>(
                "States",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static States {
        static instance: ::protobuf::rt::LazyV2<States> = ::protobuf::rt::LazyV2::INIT;
        instance.get(States::new)
    }
}

impl ::protobuf::Clear for States {
    fn clear(&mut self) {
        self.startup = false;
        self.filter_on = false;
        self.ph_on = false;
        self.ch_on = false;
        self.automatic = false;
        self.net_active = false;
        self.ntp = false;
        self.rtc = false;
        self.light_on = false;
        self.mqtt_connected = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for States {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for States {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Versions {
    // message fields
    pub domopool: ::std::string::String,
    pub platformio: u32,
    pub esp_idf: ::std::string::String,
    pub xtensa: ::std::string::String,
    pub tft_espi: ::std::string::String,
    pub dallastemp: ::std::string::String,
    pub ads1115: ::std::string::String,
    pub nanopb: ::std::string::String,
    pub mqtt: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Versions {
    fn default() -> &'a Versions {
        <Versions as ::protobuf::Message>::default_instance()
    }
}

impl Versions {
    pub fn new() -> Versions {
        ::std::default::Default::default()
    }

    // string domopool = 1;


    pub fn get_domopool(&self) -> &str {
        &self.domopool
    }
    pub fn clear_domopool(&mut self) {
        self.domopool.clear();
    }

    // Param is passed by value, moved
    pub fn set_domopool(&mut self, v: ::std::string::String) {
        self.domopool = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domopool(&mut self) -> &mut ::std::string::String {
        &mut self.domopool
    }

    // Take field
    pub fn take_domopool(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domopool, ::std::string::String::new())
    }

    // uint32 platformio = 2;


    pub fn get_platformio(&self) -> u32 {
        self.platformio
    }
    pub fn clear_platformio(&mut self) {
        self.platformio = 0;
    }

    // Param is passed by value, moved
    pub fn set_platformio(&mut self, v: u32) {
        self.platformio = v;
    }

    // string esp_idf = 3;


    pub fn get_esp_idf(&self) -> &str {
        &self.esp_idf
    }
    pub fn clear_esp_idf(&mut self) {
        self.esp_idf.clear();
    }

    // Param is passed by value, moved
    pub fn set_esp_idf(&mut self, v: ::std::string::String) {
        self.esp_idf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esp_idf(&mut self) -> &mut ::std::string::String {
        &mut self.esp_idf
    }

    // Take field
    pub fn take_esp_idf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.esp_idf, ::std::string::String::new())
    }

    // string xtensa = 4;


    pub fn get_xtensa(&self) -> &str {
        &self.xtensa
    }
    pub fn clear_xtensa(&mut self) {
        self.xtensa.clear();
    }

    // Param is passed by value, moved
    pub fn set_xtensa(&mut self, v: ::std::string::String) {
        self.xtensa = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xtensa(&mut self) -> &mut ::std::string::String {
        &mut self.xtensa
    }

    // Take field
    pub fn take_xtensa(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.xtensa, ::std::string::String::new())
    }

    // string tft_espi = 6;


    pub fn get_tft_espi(&self) -> &str {
        &self.tft_espi
    }
    pub fn clear_tft_espi(&mut self) {
        self.tft_espi.clear();
    }

    // Param is passed by value, moved
    pub fn set_tft_espi(&mut self, v: ::std::string::String) {
        self.tft_espi = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tft_espi(&mut self) -> &mut ::std::string::String {
        &mut self.tft_espi
    }

    // Take field
    pub fn take_tft_espi(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tft_espi, ::std::string::String::new())
    }

    // string dallastemp = 7;


    pub fn get_dallastemp(&self) -> &str {
        &self.dallastemp
    }
    pub fn clear_dallastemp(&mut self) {
        self.dallastemp.clear();
    }

    // Param is passed by value, moved
    pub fn set_dallastemp(&mut self, v: ::std::string::String) {
        self.dallastemp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dallastemp(&mut self) -> &mut ::std::string::String {
        &mut self.dallastemp
    }

    // Take field
    pub fn take_dallastemp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dallastemp, ::std::string::String::new())
    }

    // string ads1115 = 8;


    pub fn get_ads1115(&self) -> &str {
        &self.ads1115
    }
    pub fn clear_ads1115(&mut self) {
        self.ads1115.clear();
    }

    // Param is passed by value, moved
    pub fn set_ads1115(&mut self, v: ::std::string::String) {
        self.ads1115 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ads1115(&mut self) -> &mut ::std::string::String {
        &mut self.ads1115
    }

    // Take field
    pub fn take_ads1115(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ads1115, ::std::string::String::new())
    }

    // string nanopb = 9;


    pub fn get_nanopb(&self) -> &str {
        &self.nanopb
    }
    pub fn clear_nanopb(&mut self) {
        self.nanopb.clear();
    }

    // Param is passed by value, moved
    pub fn set_nanopb(&mut self, v: ::std::string::String) {
        self.nanopb = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nanopb(&mut self) -> &mut ::std::string::String {
        &mut self.nanopb
    }

    // Take field
    pub fn take_nanopb(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nanopb, ::std::string::String::new())
    }

    // string mqtt = 10;


    pub fn get_mqtt(&self) -> &str {
        &self.mqtt
    }
    pub fn clear_mqtt(&mut self) {
        self.mqtt.clear();
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: ::std::string::String) {
        self.mqtt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mqtt(&mut self) -> &mut ::std::string::String {
        &mut self.mqtt
    }

    // Take field
    pub fn take_mqtt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mqtt, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Versions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domopool)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.platformio = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.esp_idf)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.xtensa)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tft_espi)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dallastemp)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ads1115)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nanopb)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mqtt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.domopool.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domopool);
        }
        if self.platformio != 0 {
            my_size += ::protobuf::rt::value_size(2, self.platformio, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.esp_idf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.esp_idf);
        }
        if !self.xtensa.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.xtensa);
        }
        if !self.tft_espi.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.tft_espi);
        }
        if !self.dallastemp.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.dallastemp);
        }
        if !self.ads1115.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.ads1115);
        }
        if !self.nanopb.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.nanopb);
        }
        if !self.mqtt.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.mqtt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.domopool.is_empty() {
            os.write_string(1, &self.domopool)?;
        }
        if self.platformio != 0 {
            os.write_uint32(2, self.platformio)?;
        }
        if !self.esp_idf.is_empty() {
            os.write_string(3, &self.esp_idf)?;
        }
        if !self.xtensa.is_empty() {
            os.write_string(4, &self.xtensa)?;
        }
        if !self.tft_espi.is_empty() {
            os.write_string(6, &self.tft_espi)?;
        }
        if !self.dallastemp.is_empty() {
            os.write_string(7, &self.dallastemp)?;
        }
        if !self.ads1115.is_empty() {
            os.write_string(8, &self.ads1115)?;
        }
        if !self.nanopb.is_empty() {
            os.write_string(9, &self.nanopb)?;
        }
        if !self.mqtt.is_empty() {
            os.write_string(10, &self.mqtt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Versions {
        Versions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domopool",
                |m: &Versions| { &m.domopool },
                |m: &mut Versions| { &mut m.domopool },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "platformio",
                |m: &Versions| { &m.platformio },
                |m: &mut Versions| { &mut m.platformio },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "esp_idf",
                |m: &Versions| { &m.esp_idf },
                |m: &mut Versions| { &mut m.esp_idf },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xtensa",
                |m: &Versions| { &m.xtensa },
                |m: &mut Versions| { &mut m.xtensa },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tft_espi",
                |m: &Versions| { &m.tft_espi },
                |m: &mut Versions| { &mut m.tft_espi },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dallastemp",
                |m: &Versions| { &m.dallastemp },
                |m: &mut Versions| { &mut m.dallastemp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ads1115",
                |m: &Versions| { &m.ads1115 },
                |m: &mut Versions| { &mut m.ads1115 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nanopb",
                |m: &Versions| { &m.nanopb },
                |m: &mut Versions| { &mut m.nanopb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mqtt",
                |m: &Versions| { &m.mqtt },
                |m: &mut Versions| { &mut m.mqtt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Versions>(
                "Versions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Versions {
        static instance: ::protobuf::rt::LazyV2<Versions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Versions::new)
    }
}

impl ::protobuf::Clear for Versions {
    fn clear(&mut self) {
        self.domopool.clear();
        self.platformio = 0;
        self.esp_idf.clear();
        self.xtensa.clear();
        self.tft_espi.clear();
        self.dallastemp.clear();
        self.ads1115.clear();
        self.nanopb.clear();
        self.mqtt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Versions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Versions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Infos {
    // message fields
    pub compile: ::std::string::String,
    pub board_name: ::std::string::String,
    pub versions: ::protobuf::SingularPtrField<Versions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Infos {
    fn default() -> &'a Infos {
        <Infos as ::protobuf::Message>::default_instance()
    }
}

impl Infos {
    pub fn new() -> Infos {
        ::std::default::Default::default()
    }

    // string compile = 1;


    pub fn get_compile(&self) -> &str {
        &self.compile
    }
    pub fn clear_compile(&mut self) {
        self.compile.clear();
    }

    // Param is passed by value, moved
    pub fn set_compile(&mut self, v: ::std::string::String) {
        self.compile = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compile(&mut self) -> &mut ::std::string::String {
        &mut self.compile
    }

    // Take field
    pub fn take_compile(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compile, ::std::string::String::new())
    }

    // string board_name = 2;


    pub fn get_board_name(&self) -> &str {
        &self.board_name
    }
    pub fn clear_board_name(&mut self) {
        self.board_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_board_name(&mut self, v: ::std::string::String) {
        self.board_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_board_name(&mut self) -> &mut ::std::string::String {
        &mut self.board_name
    }

    // Take field
    pub fn take_board_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.board_name, ::std::string::String::new())
    }

    // .domopool.Versions versions = 3;


    pub fn get_versions(&self) -> &Versions {
        self.versions.as_ref().unwrap_or_else(|| <Versions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    pub fn has_versions(&self) -> bool {
        self.versions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: Versions) {
        self.versions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_versions(&mut self) -> &mut Versions {
        if self.versions.is_none() {
            self.versions.set_default();
        }
        self.versions.as_mut().unwrap()
    }

    // Take field
    pub fn take_versions(&mut self) -> Versions {
        self.versions.take().unwrap_or_else(|| Versions::new())
    }
}

impl ::protobuf::Message for Infos {
    fn is_initialized(&self) -> bool {
        for v in &self.versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compile)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.board_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.versions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.compile.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.compile);
        }
        if !self.board_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.board_name);
        }
        if let Some(ref v) = self.versions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.compile.is_empty() {
            os.write_string(1, &self.compile)?;
        }
        if !self.board_name.is_empty() {
            os.write_string(2, &self.board_name)?;
        }
        if let Some(ref v) = self.versions.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Infos {
        Infos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compile",
                |m: &Infos| { &m.compile },
                |m: &mut Infos| { &mut m.compile },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "board_name",
                |m: &Infos| { &m.board_name },
                |m: &mut Infos| { &mut m.board_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Versions>>(
                "versions",
                |m: &Infos| { &m.versions },
                |m: &mut Infos| { &mut m.versions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Infos>(
                "Infos",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Infos {
        static instance: ::protobuf::rt::LazyV2<Infos> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Infos::new)
    }
}

impl ::protobuf::Clear for Infos {
    fn clear(&mut self) {
        self.compile.clear();
        self.board_name.clear();
        self.versions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Infos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Infos {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config {
    // message fields
    pub network: ::protobuf::SingularPtrField<Network>,
    pub sensors: ::protobuf::SingularPtrField<Sensors>,
    pub global: ::protobuf::SingularPtrField<Global>,
    pub pump: ::protobuf::SingularPtrField<Pump>,
    pub metrics: ::protobuf::SingularPtrField<Metrics>,
    pub states: ::protobuf::SingularPtrField<States>,
    pub alarms: ::protobuf::SingularPtrField<Alarms>,
    pub tests: ::protobuf::SingularPtrField<Tests>,
    pub infos: ::protobuf::SingularPtrField<Infos>,
    pub limits: ::protobuf::SingularPtrField<Limits>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // .domopool.Network network = 1;


    pub fn get_network(&self) -> &Network {
        self.network.as_ref().unwrap_or_else(|| <Network as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: Network) {
        self.network = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut Network {
        if self.network.is_none() {
            self.network.set_default();
        }
        self.network.as_mut().unwrap()
    }

    // Take field
    pub fn take_network(&mut self) -> Network {
        self.network.take().unwrap_or_else(|| Network::new())
    }

    // .domopool.Sensors sensors = 2;


    pub fn get_sensors(&self) -> &Sensors {
        self.sensors.as_ref().unwrap_or_else(|| <Sensors as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sensors(&mut self) {
        self.sensors.clear();
    }

    pub fn has_sensors(&self) -> bool {
        self.sensors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sensors(&mut self, v: Sensors) {
        self.sensors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sensors(&mut self) -> &mut Sensors {
        if self.sensors.is_none() {
            self.sensors.set_default();
        }
        self.sensors.as_mut().unwrap()
    }

    // Take field
    pub fn take_sensors(&mut self) -> Sensors {
        self.sensors.take().unwrap_or_else(|| Sensors::new())
    }

    // .domopool.Global global = 3;


    pub fn get_global(&self) -> &Global {
        self.global.as_ref().unwrap_or_else(|| <Global as ::protobuf::Message>::default_instance())
    }
    pub fn clear_global(&mut self) {
        self.global.clear();
    }

    pub fn has_global(&self) -> bool {
        self.global.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: Global) {
        self.global = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global(&mut self) -> &mut Global {
        if self.global.is_none() {
            self.global.set_default();
        }
        self.global.as_mut().unwrap()
    }

    // Take field
    pub fn take_global(&mut self) -> Global {
        self.global.take().unwrap_or_else(|| Global::new())
    }

    // .domopool.Pump pump = 5;


    pub fn get_pump(&self) -> &Pump {
        self.pump.as_ref().unwrap_or_else(|| <Pump as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump(&mut self) {
        self.pump.clear();
    }

    pub fn has_pump(&self) -> bool {
        self.pump.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump(&mut self, v: Pump) {
        self.pump = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump(&mut self) -> &mut Pump {
        if self.pump.is_none() {
            self.pump.set_default();
        }
        self.pump.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump(&mut self) -> Pump {
        self.pump.take().unwrap_or_else(|| Pump::new())
    }

    // .domopool.Metrics metrics = 6;


    pub fn get_metrics(&self) -> &Metrics {
        self.metrics.as_ref().unwrap_or_else(|| <Metrics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    pub fn has_metrics(&self) -> bool {
        self.metrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: Metrics) {
        self.metrics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut Metrics {
        if self.metrics.is_none() {
            self.metrics.set_default();
        }
        self.metrics.as_mut().unwrap()
    }

    // Take field
    pub fn take_metrics(&mut self) -> Metrics {
        self.metrics.take().unwrap_or_else(|| Metrics::new())
    }

    // .domopool.States states = 7;


    pub fn get_states(&self) -> &States {
        self.states.as_ref().unwrap_or_else(|| <States as ::protobuf::Message>::default_instance())
    }
    pub fn clear_states(&mut self) {
        self.states.clear();
    }

    pub fn has_states(&self) -> bool {
        self.states.is_some()
    }

    // Param is passed by value, moved
    pub fn set_states(&mut self, v: States) {
        self.states = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_states(&mut self) -> &mut States {
        if self.states.is_none() {
            self.states.set_default();
        }
        self.states.as_mut().unwrap()
    }

    // Take field
    pub fn take_states(&mut self) -> States {
        self.states.take().unwrap_or_else(|| States::new())
    }

    // .domopool.Alarms alarms = 8;


    pub fn get_alarms(&self) -> &Alarms {
        self.alarms.as_ref().unwrap_or_else(|| <Alarms as ::protobuf::Message>::default_instance())
    }
    pub fn clear_alarms(&mut self) {
        self.alarms.clear();
    }

    pub fn has_alarms(&self) -> bool {
        self.alarms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alarms(&mut self, v: Alarms) {
        self.alarms = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alarms(&mut self) -> &mut Alarms {
        if self.alarms.is_none() {
            self.alarms.set_default();
        }
        self.alarms.as_mut().unwrap()
    }

    // Take field
    pub fn take_alarms(&mut self) -> Alarms {
        self.alarms.take().unwrap_or_else(|| Alarms::new())
    }

    // .domopool.Tests tests = 9;


    pub fn get_tests(&self) -> &Tests {
        self.tests.as_ref().unwrap_or_else(|| <Tests as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tests(&mut self) {
        self.tests.clear();
    }

    pub fn has_tests(&self) -> bool {
        self.tests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tests(&mut self, v: Tests) {
        self.tests = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tests(&mut self) -> &mut Tests {
        if self.tests.is_none() {
            self.tests.set_default();
        }
        self.tests.as_mut().unwrap()
    }

    // Take field
    pub fn take_tests(&mut self) -> Tests {
        self.tests.take().unwrap_or_else(|| Tests::new())
    }

    // .domopool.Infos infos = 10;


    pub fn get_infos(&self) -> &Infos {
        self.infos.as_ref().unwrap_or_else(|| <Infos as ::protobuf::Message>::default_instance())
    }
    pub fn clear_infos(&mut self) {
        self.infos.clear();
    }

    pub fn has_infos(&self) -> bool {
        self.infos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infos(&mut self, v: Infos) {
        self.infos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_infos(&mut self) -> &mut Infos {
        if self.infos.is_none() {
            self.infos.set_default();
        }
        self.infos.as_mut().unwrap()
    }

    // Take field
    pub fn take_infos(&mut self) -> Infos {
        self.infos.take().unwrap_or_else(|| Infos::new())
    }

    // .domopool.Limits limits = 11;


    pub fn get_limits(&self) -> &Limits {
        self.limits.as_ref().unwrap_or_else(|| <Limits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    pub fn has_limits(&self) -> bool {
        self.limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: Limits) {
        self.limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limits(&mut self) -> &mut Limits {
        if self.limits.is_none() {
            self.limits.set_default();
        }
        self.limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_limits(&mut self) -> Limits {
        self.limits.take().unwrap_or_else(|| Limits::new())
    }
}

impl ::protobuf::Message for Config {
    fn is_initialized(&self) -> bool {
        for v in &self.network {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sensors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.global {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.states {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alarms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.infos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sensors)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metrics)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.states)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.alarms)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tests)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.infos)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.network.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sensors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.global.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.states.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.alarms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tests.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.infos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.network.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sensors.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.global.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.states.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.alarms.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tests.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.infos.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.limits.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config {
        Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Network>>(
                "network",
                |m: &Config| { &m.network },
                |m: &mut Config| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sensors>>(
                "sensors",
                |m: &Config| { &m.sensors },
                |m: &mut Config| { &mut m.sensors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Global>>(
                "global",
                |m: &Config| { &m.global },
                |m: &mut Config| { &mut m.global },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pump>>(
                "pump",
                |m: &Config| { &m.pump },
                |m: &mut Config| { &mut m.pump },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Metrics>>(
                "metrics",
                |m: &Config| { &m.metrics },
                |m: &mut Config| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<States>>(
                "states",
                |m: &Config| { &m.states },
                |m: &mut Config| { &mut m.states },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Alarms>>(
                "alarms",
                |m: &Config| { &m.alarms },
                |m: &mut Config| { &mut m.alarms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tests>>(
                "tests",
                |m: &Config| { &m.tests },
                |m: &mut Config| { &mut m.tests },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Infos>>(
                "infos",
                |m: &Config| { &m.infos },
                |m: &mut Config| { &mut m.infos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Limits>>(
                "limits",
                |m: &Config| { &m.limits },
                |m: &mut Config| { &mut m.limits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config>(
                "Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config {
        static instance: ::protobuf::rt::LazyV2<Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config::new)
    }
}

impl ::protobuf::Clear for Config {
    fn clear(&mut self) {
        self.network.clear();
        self.sensors.clear();
        self.global.clear();
        self.pump.clear();
        self.metrics.clear();
        self.states.clear();
        self.alarms.clear();
        self.tests.clear();
        self.infos.clear();
        self.limits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relay {
    // message fields
    pub state: Relay_states,
    pub relay: Relay_names,
    pub duration: u32,
    pub start_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relay {
    fn default() -> &'a Relay {
        <Relay as ::protobuf::Message>::default_instance()
    }
}

impl Relay {
    pub fn new() -> Relay {
        ::std::default::Default::default()
    }

    // .domopool.Relay_states state = 1;


    pub fn get_state(&self) -> Relay_states {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Relay_states::auto;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Relay_states) {
        self.state = v;
    }

    // .domopool.Relay_names relay = 2;


    pub fn get_relay(&self) -> Relay_names {
        self.relay
    }
    pub fn clear_relay(&mut self) {
        self.relay = Relay_names::filter;
    }

    // Param is passed by value, moved
    pub fn set_relay(&mut self, v: Relay_names) {
        self.relay = v;
    }

    // uint32 duration = 3;


    pub fn get_duration(&self) -> u32 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = v;
    }

    // uint32 start_time = 4;


    pub fn get_start_time(&self) -> u32 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = v;
    }
}

impl ::protobuf::Message for Relay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.relay, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != Relay_states::auto {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        if self.relay != Relay_names::filter {
            my_size += ::protobuf::rt::enum_size(2, self.relay);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(3, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != Relay_states::auto {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if self.relay != Relay_names::filter {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.relay))?;
        }
        if self.duration != 0 {
            os.write_uint32(3, self.duration)?;
        }
        if self.start_time != 0 {
            os.write_uint32(4, self.start_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relay {
        Relay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Relay_states>>(
                "state",
                |m: &Relay| { &m.state },
                |m: &mut Relay| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Relay_names>>(
                "relay",
                |m: &Relay| { &m.relay },
                |m: &mut Relay| { &mut m.relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duration",
                |m: &Relay| { &m.duration },
                |m: &mut Relay| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_time",
                |m: &Relay| { &m.start_time },
                |m: &mut Relay| { &mut m.start_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Relay>(
                "Relay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Relay {
        static instance: ::protobuf::rt::LazyV2<Relay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Relay::new)
    }
}

impl ::protobuf::Clear for Relay {
    fn clear(&mut self) {
        self.state = Relay_states::auto;
        self.relay = Relay_names::filter;
        self.duration = 0;
        self.start_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Relay_states {
    auto = 0,
    start = 1,
    stop = 2,
}

impl ::protobuf::ProtobufEnum for Relay_states {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Relay_states> {
        match value {
            0 => ::std::option::Option::Some(Relay_states::auto),
            1 => ::std::option::Option::Some(Relay_states::start),
            2 => ::std::option::Option::Some(Relay_states::stop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Relay_states] = &[
            Relay_states::auto,
            Relay_states::start,
            Relay_states::stop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Relay_states>("Relay_states", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Relay_states {
}

impl ::std::default::Default for Relay_states {
    fn default() -> Self {
        Relay_states::auto
    }
}

impl ::protobuf::reflect::ProtobufValue for Relay_states {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Relay_names {
    filter = 0,
    ch = 1,
    ph = 2,
    light = 3,
}

impl ::protobuf::ProtobufEnum for Relay_names {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Relay_names> {
        match value {
            0 => ::std::option::Option::Some(Relay_names::filter),
            1 => ::std::option::Option::Some(Relay_names::ch),
            2 => ::std::option::Option::Some(Relay_names::ph),
            3 => ::std::option::Option::Some(Relay_names::light),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Relay_names] = &[
            Relay_names::filter,
            Relay_names::ch,
            Relay_names::ph,
            Relay_names::light,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Relay_names>("Relay_names", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Relay_names {
}

impl ::std::default::Default for Relay_names {
    fn default() -> Self {
        Relay_names::filter
    }
}

impl ::protobuf::reflect::ProtobufValue for Relay_names {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0edomopool.proto\x12\x08domopool\"V\n\x03NTP\x12\x1b\n\tday_light\
    \x18\x01\x20\x01(\rR\x08dayLight\x12\x16\n\x06server\x18\x02\x20\x01(\tR\
    \x06server\x12\x1a\n\x08timezone\x18\x03\x20\x01(\rR\x08timezone\"8\n\
    \x04Mqtt\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\x16\n\
    \x06server\x18\x02\x20\x01(\tR\x06server\"\xd7\x01\n\x07Network\x12\x12\
    \n\x04dhcp\x18\x01\x20\x01(\x08R\x04dhcp\x12\x0e\n\x02ip\x18\x02\x20\x01\
    (\tR\x02ip\x12\x18\n\x07netmask\x18\x03\x20\x01(\tR\x07netmask\x12\x18\n\
    \x07gateway\x18\x04\x20\x01(\tR\x07gateway\x12\x10\n\x03dns\x18\x05\x20\
    \x01(\tR\x03dns\x12\x1d\n\nallow_post\x18\x06\x20\x01(\x08R\tallowPost\
    \x12\"\n\x04mqtt\x18\x07\x20\x01(\x0b2\x0e.domopool.MqttR\x04mqtt\x12\
    \x1f\n\x03ntp\x18\x08\x20\x01(\x0b2\r.domopool.NTPR\x03ntp\"H\n\x04Temp\
    \x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\x12\n\x04init\
    \x18\x02\x20\x01(\x08R\x04init\x12\x12\n\x04addr\x18\x08\x20\x03(\rR\x04\
    addr\"\xfa\x02\n\x06Limits\x12\x15\n\x06wp_min\x18\x01\x20\x01(\x02R\x05\
    wpMin\x12\x15\n\x06wp_max\x18\x02\x20\x01(\x02R\x05wpMax\x12\x15\n\x06ph\
    _min\x18\x03\x20\x01(\x02R\x05phMin\x12\x15\n\x06ph_max\x18\x04\x20\x01(\
    \x02R\x05phMax\x12\x15\n\x06ch_min\x18\x05\x20\x01(\x02R\x05chMin\x12\
    \x15\n\x06ch_max\x18\x06\x20\x01(\x02R\x05chMax\x12$\n\x0ewait_before_ch\
    \x18\x07\x20\x01(\rR\x0cwaitBeforeCh\x12*\n\x11ch_temp_threshold\x18\x08\
    \x20\x01(\x02R\x0fchTempThreshold\x12+\n\x12ch_temp_wait_reset\x18\t\x20\
    \x01(\x02R\x0fchTempWaitReset\x12\x1e\n\x0bwp_0_derive\x18\n\x20\x01(\
    \x02R\twp0Derive\x12\x15\n\x06tw_min\x18\x0b\x20\x01(\x02R\x05twMin\x12\
    \x15\n\x06tw_max\x18\x0c\x20\x01(\x02R\x05twMax\x12\x19\n\x08tamb_min\
    \x18\r\x20\x01(\x02R\x07tambMin\"\xfc\x01\n\x0cAnalogSensor\x12\x18\n\
    \x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\x17\n\x07adc_pin\x18\
    \x03\x20\x01(\rR\x06adcPin\x12\x1c\n\tthreshold\x18\x02\x20\x01(\x02R\tt\
    hreshold\x12-\n\x12threshold_accuracy\x18\x04\x20\x01(\rR\x11thresholdAc\
    curacy\x12\x12\n\x04vmin\x18\x05\x20\x01(\x02R\x04vmin\x12\x12\n\x04vmax\
    \x18\x06\x20\x01(\x02R\x04vmax\x12)\n\x10precision_factor\x18\x07\x20\
    \x01(\rR\x0fprecisionFactor\x12\x19\n\x08auto_cal\x18\x08\x20\x01(\x08R\
    \x07autoCal\"\xcc\x03\n\x07Sensors\x12\"\n\x04twin\x18\x01\x20\x01(\x0b2\
    \x0e.domopool.TempR\x04twin\x12$\n\x05twout\x18\x02\x20\x01(\x0b2\x0e.do\
    mopool.TempR\x05twout\x12\"\n\x04tamb\x18\x03\x20\x01(\x0b2\x0e.domopool\
    .TempR\x04tamb\x12.\n\x13wait_for_conversion\x18\x04\x20\x01(\x08R\x11wa\
    itForConversion\x12'\n\x0ftemp_resolution\x18\x05\x20\x01(\rR\x0etempRes\
    olution\x12)\n\x10precision_factor\x18\x06\x20\x01(\rR\x0fprecisionFacto\
    r\x12&\n\x02ph\x18\x07\x20\x01(\x0b2\x16.domopool.AnalogSensorR\x02ph\
    \x12&\n\x02ch\x18\x08\x20\x01(\x0b2\x16.domopool.AnalogSensorR\x02ch\x12\
    &\n\x02wp\x18\t\x20\x01(\x0b2\x16.domopool.AnalogSensorR\x02wp\x12\x19\n\
    \x08adc_mode\x18\n\x20\x01(\rR\x07adcMode\x12!\n\x0cadc_datarate\x18\x0b\
    \x20\x01(\rR\x0badcDatarate\x12\x19\n\x08adc_gain\x18\x0c\x20\x01(\rR\
    \x07adcGain\"\x88\x02\n\x06Global\x124\n\x16lcd_backlight_duration\x18\
    \x01\x20\x01(\rR\x14lcdBacklightDuration\x12!\n\x0cack_duration\x18\x02\
    \x20\x01(\rR\x0backDuration\x12\x19\n\x08ack_tone\x18\x03\x20\x01(\x01R\
    \x07ackTone\x12\x1d\n\nserial_out\x18\x04\x20\x01(\x08R\tserialOut\x12'\
    \n\x0fdisplay_startup\x18\x05\x20\x01(\x08R\x0edisplayStartup\x12\x1f\n\
    \x0bforce_light\x18\x06\x20\x01(\x08R\nforceLight\x12!\n\x0cwdt_duration\
    \x18\x07\x20\x01(\rR\x0bwdtDuration\"\xef\x01\n\x04Pump\x12!\n\x0cforce_\
    filter\x18\x01\x20\x01(\x08R\x0bforceFilter\x12\x19\n\x08force_ph\x18\
    \x02\x20\x01(\x08R\x07forcePh\x12\x19\n\x08force_ch\x18\x03\x20\x01(\x08\
    R\x07forceCh\x12\x1c\n\tautomatic\x18\x04\x20\x01(\x08R\tautomatic\x12\
    \x1f\n\x0bforce_check\x18\x05\x20\x01(\x08R\nforceCheck\x12%\n\x0eforce_\
    duration\x18\x06\x20\x01(\rR\rforceDuration\x12(\n\x10force_start_time\
    \x18\x07\x20\x01(\rR\x0eforceStartTime\"q\n\x0cAds115Alarms\x12\x1b\n\tn\
    ot_ready\x18\x01\x20\x01(\x08R\x08notReady\x12\x1f\n\x0bnot_started\x18\
    \x02\x20\x01(\x08R\nnotStarted\x12#\n\rnot_connected\x18\x03\x20\x01(\
    \x08R\x0cnotConnected\"l\n\nMqttAlarms\x12\x18\n\x07metrics\x18\x01\x20\
    \x01(\x08R\x07metrics\x12\x16\n\x06states\x18\x02\x20\x01(\x08R\x06state\
    s\x12\x16\n\x06alarms\x18\x03\x20\x01(\x08R\x06alarms\x12\x14\n\x05temps\
    \x18\x04\x20\x01(\x08R\x05temps\"\xce\x02\n\x06Alarms\x12\x16\n\x06filte\
    r\x18\x01\x20\x01(\x08R\x06filter\x12\x0e\n\x02ph\x18\x02\x20\x01(\x08R\
    \x02ph\x12\x0e\n\x02ch\x18\x03\x20\x01(\x08R\x02ch\x12\x10\n\x03rtc\x18\
    \x05\x20\x01(\x08R\x03rtc\x12\x17\n\x07wp_high\x18\x06\x20\x01(\x08R\x06\
    wpHigh\x12\x15\n\x06wp_low\x18\x07\x20\x01(\x08R\x05wpLow\x12\x1b\n\twp_\
    broken\x18\x08\x20\x01(\x08R\x08wpBroken\x120\n\x07ads1115\x18\t\x20\x01\
    (\x0b2\x16.domopool.Ads115AlarmsR\x07ads1115\x12\x19\n\x08tw_frost\x18\n\
    \x20\x01(\x08R\x07twFrost\x12\x17\n\x07tw_high\x18\x0b\x20\x01(\x08R\x06\
    twHigh\x12\x1d\n\ntamb_frost\x18\x0c\x20\x01(\x08R\ttambFrost\x12(\n\x04\
    mqtt\x18\r\x20\x01(\x0b2\x14.domopool.MqttAlarmsR\x04mqtt\"y\n\x05Tests\
    \x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\x16\n\x06twat\
    er\x18\x02\x20\x01(\x02R\x06twater\x12\x12\n\x04tamb\x18\x03\x20\x01(\
    \x02R\x04tamb\x12\x0e\n\x02ph\x18\x04\x20\x01(\x02R\x02ph\x12\x1a\n\x08p\
    ressure\x18\x05\x20\x01(\x02R\x08pressure\"\xf3\x01\n\x07Metrics\x12\x12\
    \n\x04tamb\x18\x01\x20\x01(\x02R\x04tamb\x12\x16\n\x06twater\x18\x02\x20\
    \x01(\x02R\x06twater\x12!\n\x0csaved_twater\x18\x03\x20\x01(\x02R\x0bsav\
    edTwater\x12\x0e\n\x02ph\x18\x04\x20\x01(\x02R\x02ph\x12\x0e\n\x02ch\x18\
    \x05\x20\x01(\x02R\x02ch\x12\x0e\n\x02wp\x18\x06\x20\x01(\x02R\x02wp\x12\
    \x17\n\x07wp_volt\x18\x07\x20\x01(\x02R\x06wpVolt\x12(\n\x10over_15_dura\
    tion\x18\x08\x20\x01(\rR\x0eover15Duration\x12\x12\n\x04hour\x18\t\x20\
    \x01(\rR\x04hour\x12\x12\n\x04time\x18\n\x20\x01(\tR\x04time\"\x8c\x02\n\
    \x06States\x12\x18\n\x07startup\x18\x01\x20\x01(\x08R\x07startup\x12\x1b\
    \n\tfilter_on\x18\x02\x20\x01(\x08R\x08filterOn\x12\x13\n\x05ph_on\x18\
    \x03\x20\x01(\x08R\x04phOn\x12\x13\n\x05ch_on\x18\x04\x20\x01(\x08R\x04c\
    hOn\x12\x1c\n\tautomatic\x18\x05\x20\x01(\x08R\tautomatic\x12\x1d\n\nnet\
    _active\x18\x06\x20\x01(\x08R\tnetActive\x12\x10\n\x03ntp\x18\x07\x20\
    \x01(\x08R\x03ntp\x12\x10\n\x03rtc\x18\x08\x20\x01(\x08R\x03rtc\x12\x19\
    \n\x08light_on\x18\t\x20\x01(\x08R\x07lightOn\x12%\n\x0emqtt_connected\
    \x18\n\x20\x01(\x08R\rmqttConnected\"\xf8\x01\n\x08Versions\x12\x1a\n\
    \x08domopool\x18\x01\x20\x01(\tR\x08domopool\x12\x1e\n\nplatformio\x18\
    \x02\x20\x01(\rR\nplatformio\x12\x17\n\x07esp_idf\x18\x03\x20\x01(\tR\
    \x06espIdf\x12\x16\n\x06xtensa\x18\x04\x20\x01(\tR\x06xtensa\x12\x19\n\
    \x08tft_espi\x18\x06\x20\x01(\tR\x07tftEspi\x12\x1e\n\ndallastemp\x18\
    \x07\x20\x01(\tR\ndallastemp\x12\x18\n\x07ads1115\x18\x08\x20\x01(\tR\
    \x07ads1115\x12\x16\n\x06nanopb\x18\t\x20\x01(\tR\x06nanopb\x12\x12\n\
    \x04mqtt\x18\n\x20\x01(\tR\x04mqtt\"p\n\x05Infos\x12\x18\n\x07compile\
    \x18\x01\x20\x01(\tR\x07compile\x12\x1d\n\nboard_name\x18\x02\x20\x01(\t\
    R\tboardName\x12.\n\x08versions\x18\x03\x20\x01(\x0b2\x12.domopool.Versi\
    onsR\x08versions\"\xa9\x03\n\x06Config\x12+\n\x07network\x18\x01\x20\x01\
    (\x0b2\x11.domopool.NetworkR\x07network\x12+\n\x07sensors\x18\x02\x20\
    \x01(\x0b2\x11.domopool.SensorsR\x07sensors\x12(\n\x06global\x18\x03\x20\
    \x01(\x0b2\x10.domopool.GlobalR\x06global\x12\"\n\x04pump\x18\x05\x20\
    \x01(\x0b2\x0e.domopool.PumpR\x04pump\x12+\n\x07metrics\x18\x06\x20\x01(\
    \x0b2\x11.domopool.MetricsR\x07metrics\x12(\n\x06states\x18\x07\x20\x01(\
    \x0b2\x10.domopool.StatesR\x06states\x12(\n\x06alarms\x18\x08\x20\x01(\
    \x0b2\x10.domopool.AlarmsR\x06alarms\x12%\n\x05tests\x18\t\x20\x01(\x0b2\
    \x0f.domopool.TestsR\x05tests\x12%\n\x05infos\x18\n\x20\x01(\x0b2\x0f.do\
    mopool.InfosR\x05infos\x12(\n\x06limits\x18\x0b\x20\x01(\x0b2\x10.domopo\
    ol.LimitsR\x06limits\"\x9d\x01\n\x05Relay\x12,\n\x05state\x18\x01\x20\
    \x01(\x0e2\x16.domopool.Relay_statesR\x05state\x12+\n\x05relay\x18\x02\
    \x20\x01(\x0e2\x15.domopool.Relay_namesR\x05relay\x12\x1a\n\x08duration\
    \x18\x03\x20\x01(\rR\x08duration\x12\x1d\n\nstart_time\x18\x04\x20\x01(\
    \rR\tstartTime*-\n\x0cRelay_states\x12\x08\n\x04auto\x10\0\x12\t\n\x05st\
    art\x10\x01\x12\x08\n\x04stop\x10\x02*4\n\x0bRelay_names\x12\n\n\x06filt\
    er\x10\0\x12\x06\n\x02ch\x10\x01\x12\x06\n\x02ph\x10\x02\x12\t\n\x05ligh\
    t\x10\x03B4Z2github.com/golgoth31/domopool-proto;domopool_protoJ\xccC\n\
    \x07\x12\x05\0\0\xd3\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x02\0\x11\n\x08\n\x01\x08\x12\x03\x04\0I\n\t\n\x02\x08\x0b\
    \x12\x03\x04\0I\n\n\n\x02\x04\0\x12\x04\x06\0\n\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\x06\x08\x0b\n7\n\x04\x04\0\x02\0\x12\x03\x07\x02\x17\"*\x203600\
    \x20if\x20daylight\x20is\x20observed\x20or\x200\x20if\x20not\n\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03\x07\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x07\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x07\x15\x16\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\x08\x02\x14\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\x08\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x08\t\x0f\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x08\x12\x13\n*\n\x04\x04\0\x02\x02\x12\
    \x03\t\x02\x16\"\x1d\x20UTC\x20offset\x20in\x20s:\x20UTC+1=3600\n\n\x0c\
    \n\x05\x04\0\x02\x02\x05\x12\x03\t\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03\t\t\x11\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\t\x14\x15\n\n\n\
    \x02\x04\x01\x12\x04\x0c\0\x0f\x01\n\n\n\x03\x04\x01\x01\x12\x03\x0c\x08\
    \x0c\n\x0b\n\x04\x04\x01\x02\0\x12\x03\r\x02\x13\n\x0c\n\x05\x04\x01\x02\
    \0\x05\x12\x03\r\x02\x06\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\r\x07\x0e\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\r\x11\x12\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03\x0e\x02\x14\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0e\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0e\t\x0f\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03\x0e\x12\x13\n\n\n\x02\x04\x02\x12\x04\x11\0\x1a\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03\x11\x08\x0f\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03\x12\x02\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x12\x02\x06\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x12\x07\x0b\n\x0c\n\x05\x04\x02\x02\
    \0\x03\x12\x03\x12\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x13\x02\
    \x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x13\x02\x08\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03\x13\t\x0b\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03\x13\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x14\x02\x15\n\x0c\n\
    \x05\x04\x02\x02\x02\x05\x12\x03\x14\x02\x08\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03\x14\t\x10\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x14\x13\
    \x14\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\x15\x02\x15\n\x0c\n\x05\x04\x02\
    \x02\x03\x05\x12\x03\x15\x02\x08\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03\
    \x15\t\x10\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x15\x13\x14\n\x0b\n\
    \x04\x04\x02\x02\x04\x12\x03\x16\x02\x11\n\x0c\n\x05\x04\x02\x02\x04\x05\
    \x12\x03\x16\x02\x08\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x16\t\x0c\n\
    \x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x16\x0f\x10\n\x0b\n\x04\x04\x02\
    \x02\x05\x12\x03\x17\x02\x16\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03\x17\
    \x02\x06\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03\x17\x07\x11\n\x0c\n\x05\
    \x04\x02\x02\x05\x03\x12\x03\x17\x14\x15\n\x0b\n\x04\x04\x02\x02\x06\x12\
    \x03\x18\x02\x10\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03\x18\x02\x06\n\
    \x0c\n\x05\x04\x02\x02\x06\x01\x12\x03\x18\x07\x0b\n\x0c\n\x05\x04\x02\
    \x02\x06\x03\x12\x03\x18\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x07\x12\x03\x19\
    \x02\x0e\n\x0c\n\x05\x04\x02\x02\x07\x06\x12\x03\x19\x02\x05\n\x0c\n\x05\
    \x04\x02\x02\x07\x01\x12\x03\x19\x06\t\n\x0c\n\x05\x04\x02\x02\x07\x03\
    \x12\x03\x19\x0c\r\n\n\n\x02\x04\x03\x12\x04\x1c\0\x20\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03\x1c\x08\x0c\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1d\x02\
    \x13\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x1d\x02\x06\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03\x1d\x07\x0e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\
    \x1d\x11\x12\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x1e\x02\x10\n\x0c\n\x05\
    \x04\x03\x02\x01\x05\x12\x03\x1e\x02\x06\n\x0c\n\x05\x04\x03\x02\x01\x01\
    \x12\x03\x1e\x07\x0b\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1e\x0e\x0f\
    \n\x0b\n\x04\x04\x03\x02\x02\x12\x03\x1f\x02\x1b\n\x0c\n\x05\x04\x03\x02\
    \x02\x04\x12\x03\x1f\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03\x1f\
    \x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03\x1f\x12\x16\n\x0c\n\x05\
    \x04\x03\x02\x02\x03\x12\x03\x1f\x19\x1a\n\n\n\x02\x04\x04\x12\x04\"\03\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03\"\x08\x0e\n\x0b\n\x04\x04\x04\x02\0\
    \x12\x03#\x02\x13\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03#\x02\x07\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03#\x08\x0e\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03#\x11\x12\n\x0b\n\x04\x04\x04\x02\x01\x12\x03$\x02\x13\n\x0c\n\
    \x05\x04\x04\x02\x01\x05\x12\x03$\x02\x07\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x03$\x08\x0e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03$\x11\x12\n\
    \x0b\n\x04\x04\x04\x02\x02\x12\x03%\x02\x13\n\x0c\n\x05\x04\x04\x02\x02\
    \x05\x12\x03%\x02\x07\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03%\x08\x0e\n\
    \x0c\n\x05\x04\x04\x02\x02\x03\x12\x03%\x11\x12\n\x0b\n\x04\x04\x04\x02\
    \x03\x12\x03&\x02\x13\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03&\x02\x07\n\
    \x0c\n\x05\x04\x04\x02\x03\x01\x12\x03&\x08\x0e\n\x0c\n\x05\x04\x04\x02\
    \x03\x03\x12\x03&\x11\x12\n\x0b\n\x04\x04\x04\x02\x04\x12\x03'\x02\x13\n\
    \x0c\n\x05\x04\x04\x02\x04\x05\x12\x03'\x02\x07\n\x0c\n\x05\x04\x04\x02\
    \x04\x01\x12\x03'\x08\x0e\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03'\x11\
    \x12\n\x0b\n\x04\x04\x04\x02\x05\x12\x03(\x02\x13\n\x0c\n\x05\x04\x04\
    \x02\x05\x05\x12\x03(\x02\x07\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03(\
    \x08\x0e\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03(\x11\x12\nJ\n\x04\x04\
    \x04\x02\x06\x12\x03*\x02\x1c\x1a=\x20number\x20of\x20hour\x20to\x20wait\
    \x20when\x20temp\x20is\x20above\x2015\x20to\x20activate\x20ch\n\n\x0c\n\
    \x05\x04\x04\x02\x06\x05\x12\x03*\x02\x08\n\x0c\n\x05\x04\x04\x02\x06\
    \x01\x12\x03*\t\x17\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03*\x1a\x1b\n,\
    \n\x04\x04\x04\x02\x07\x12\x03,\x02\x1e\x1a\x1f\x20temp\x20threshold\x20\
    to\x20activate\x20ch\n\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\x03,\x02\x07\
    \n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03,\x08\x19\n\x0c\n\x05\x04\x04\
    \x02\x07\x03\x12\x03,\x1c\x1d\n3\n\x04\x04\x04\x02\x08\x12\x03.\x02\x1f\
    \x1a&\x20temp\x20threshold\x20to\x20reset\x20ch\x20wait\x20time\n\n\x0c\
    \n\x05\x04\x04\x02\x08\x05\x12\x03.\x02\x07\n\x0c\n\x05\x04\x04\x02\x08\
    \x01\x12\x03.\x08\x1a\n\x0c\n\x05\x04\x04\x02\x08\x03\x12\x03.\x1d\x1e\n\
    \x0b\n\x04\x04\x04\x02\t\x12\x03/\x02\x19\n\x0c\n\x05\x04\x04\x02\t\x05\
    \x12\x03/\x02\x07\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03/\x08\x13\n\x0c\n\
    \x05\x04\x04\x02\t\x03\x12\x03/\x16\x18\n\x0b\n\x04\x04\x04\x02\n\x12\
    \x030\x02\x14\n\x0c\n\x05\x04\x04\x02\n\x05\x12\x030\x02\x07\n\x0c\n\x05\
    \x04\x04\x02\n\x01\x12\x030\x08\x0e\n\x0c\n\x05\x04\x04\x02\n\x03\x12\
    \x030\x11\x13\n\x0b\n\x04\x04\x04\x02\x0b\x12\x031\x02\x14\n\x0c\n\x05\
    \x04\x04\x02\x0b\x05\x12\x031\x02\x07\n\x0c\n\x05\x04\x04\x02\x0b\x01\
    \x12\x031\x08\x0e\n\x0c\n\x05\x04\x04\x02\x0b\x03\x12\x031\x11\x13\n\x0b\
    \n\x04\x04\x04\x02\x0c\x12\x032\x02\x16\n\x0c\n\x05\x04\x04\x02\x0c\x05\
    \x12\x032\x02\x07\n\x0c\n\x05\x04\x04\x02\x0c\x01\x12\x032\x08\x10\n\x0c\
    \n\x05\x04\x04\x02\x0c\x03\x12\x032\x13\x15\n\n\n\x02\x04\x05\x12\x045\0\
    >\x01\n\n\n\x03\x04\x05\x01\x12\x035\x08\x14\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x036\x02\x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x036\x02\x06\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x036\x07\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x036\x11\x12\n\x0b\n\x04\x04\x05\x02\x01\x12\x037\x02\x15\n\x0c\n\
    \x05\x04\x05\x02\x01\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x037\t\x10\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x037\x13\x14\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x038\x02\x16\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x038\x02\x07\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x038\x08\x11\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x038\x14\x15\n\x0b\n\x04\x04\x05\x02\
    \x03\x12\x039\x02\x20\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x039\x02\x08\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x039\t\x1b\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x039\x1e\x1f\n\x0b\n\x04\x04\x05\x02\x04\x12\x03:\x02\x11\n\
    \x0c\n\x05\x04\x05\x02\x04\x05\x12\x03:\x02\x07\n\x0c\n\x05\x04\x05\x02\
    \x04\x01\x12\x03:\x08\x0c\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03:\x0f\
    \x10\n\x0b\n\x04\x04\x05\x02\x05\x12\x03;\x02\x11\n\x0c\n\x05\x04\x05\
    \x02\x05\x05\x12\x03;\x02\x07\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03;\
    \x08\x0c\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03;\x0f\x10\n\x0b\n\x04\
    \x04\x05\x02\x06\x12\x03<\x02\x1e\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\
    \x03<\x02\x08\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03<\t\x19\n\x0c\n\x05\
    \x04\x05\x02\x06\x03\x12\x03<\x1c\x1d\n\x0b\n\x04\x04\x05\x02\x07\x12\
    \x03=\x02\x14\n\x0c\n\x05\x04\x05\x02\x07\x05\x12\x03=\x02\x06\n\x0c\n\
    \x05\x04\x05\x02\x07\x01\x12\x03=\x07\x0f\n\x0c\n\x05\x04\x05\x02\x07\
    \x03\x12\x03=\x12\x13\n\n\n\x02\x04\x06\x12\x04@\0M\x01\n\n\n\x03\x04\
    \x06\x01\x12\x03@\x08\x0f\n\x0b\n\x04\x04\x06\x02\0\x12\x03A\x02\x10\n\
    \x0c\n\x05\x04\x06\x02\0\x06\x12\x03A\x02\x06\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03A\x07\x0b\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03A\x0e\x0f\n\
    \x0b\n\x04\x04\x06\x02\x01\x12\x03B\x02\x11\n\x0c\n\x05\x04\x06\x02\x01\
    \x06\x12\x03B\x02\x06\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03B\x07\x0c\n\
    \x0c\n\x05\x04\x06\x02\x01\x03\x12\x03B\x0f\x10\n\x0b\n\x04\x04\x06\x02\
    \x02\x12\x03C\x02\x10\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03C\x02\x06\n\
    \x0c\n\x05\x04\x06\x02\x02\x01\x12\x03C\x07\x0b\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03C\x0e\x0f\n\x0b\n\x04\x04\x06\x02\x03\x12\x03D\x02\x1f\n\
    \x0c\n\x05\x04\x06\x02\x03\x05\x12\x03D\x02\x06\n\x0c\n\x05\x04\x06\x02\
    \x03\x01\x12\x03D\x07\x1a\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03D\x1d\
    \x1e\n\x0b\n\x04\x04\x06\x02\x04\x12\x03E\x02\x1d\n\x0c\n\x05\x04\x06\
    \x02\x04\x05\x12\x03E\x02\x08\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03E\t\
    \x18\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03E\x1b\x1c\n\x0b\n\x04\x04\
    \x06\x02\x05\x12\x03F\x02\x1e\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03F\
    \x02\x08\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03F\t\x19\n\x0c\n\x05\x04\
    \x06\x02\x05\x03\x12\x03F\x1c\x1d\n\x0b\n\x04\x04\x06\x02\x06\x12\x03G\
    \x02\x16\n\x0c\n\x05\x04\x06\x02\x06\x06\x12\x03G\x02\x0e\n\x0c\n\x05\
    \x04\x06\x02\x06\x01\x12\x03G\x0f\x11\n\x0c\n\x05\x04\x06\x02\x06\x03\
    \x12\x03G\x14\x15\n\x0b\n\x04\x04\x06\x02\x07\x12\x03H\x02\x16\n\x0c\n\
    \x05\x04\x06\x02\x07\x06\x12\x03H\x02\x0e\n\x0c\n\x05\x04\x06\x02\x07\
    \x01\x12\x03H\x0f\x11\n\x0c\n\x05\x04\x06\x02\x07\x03\x12\x03H\x14\x15\n\
    \x0b\n\x04\x04\x06\x02\x08\x12\x03I\x02\x16\n\x0c\n\x05\x04\x06\x02\x08\
    \x06\x12\x03I\x02\x0e\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03I\x0f\x11\n\
    \x0c\n\x05\x04\x06\x02\x08\x03\x12\x03I\x14\x15\n\x0b\n\x04\x04\x06\x02\
    \t\x12\x03J\x02\x17\n\x0c\n\x05\x04\x06\x02\t\x05\x12\x03J\x02\x08\n\x0c\
    \n\x05\x04\x06\x02\t\x01\x12\x03J\t\x11\n\x0c\n\x05\x04\x06\x02\t\x03\
    \x12\x03J\x14\x16\n\x0b\n\x04\x04\x06\x02\n\x12\x03K\x02\x1b\n\x0c\n\x05\
    \x04\x06\x02\n\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\x06\x02\n\x01\x12\
    \x03K\t\x15\n\x0c\n\x05\x04\x06\x02\n\x03\x12\x03K\x18\x1a\n\x0b\n\x04\
    \x04\x06\x02\x0b\x12\x03L\x02\x17\n\x0c\n\x05\x04\x06\x02\x0b\x05\x12\
    \x03L\x02\x08\n\x0c\n\x05\x04\x06\x02\x0b\x01\x12\x03L\t\x11\n\x0c\n\x05\
    \x04\x06\x02\x0b\x03\x12\x03L\x14\x16\n\n\n\x02\x04\x07\x12\x04O\0W\x01\
    \n\n\n\x03\x04\x07\x01\x12\x03O\x08\x0e\n\x0b\n\x04\x04\x07\x02\0\x12\
    \x03P\x02$\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03P\x02\x08\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03P\t\x1f\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03P\
    \"#\n\x0b\n\x04\x04\x07\x02\x01\x12\x03Q\x02\x1a\n\x0c\n\x05\x04\x07\x02\
    \x01\x05\x12\x03Q\x02\x08\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03Q\t\x15\
    \n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03Q\x18\x19\n\x0b\n\x04\x04\x07\
    \x02\x02\x12\x03R\x02\x16\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03R\x02\
    \x08\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03R\t\x11\n\x0c\n\x05\x04\x07\
    \x02\x02\x03\x12\x03R\x14\x15\n\x0b\n\x04\x04\x07\x02\x03\x12\x03S\x02\
    \x16\n\x0c\n\x05\x04\x07\x02\x03\x05\x12\x03S\x02\x06\n\x0c\n\x05\x04\
    \x07\x02\x03\x01\x12\x03S\x07\x11\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\
    \x03S\x14\x15\n\x0b\n\x04\x04\x07\x02\x04\x12\x03T\x02\x1b\n\x0c\n\x05\
    \x04\x07\x02\x04\x05\x12\x03T\x02\x06\n\x0c\n\x05\x04\x07\x02\x04\x01\
    \x12\x03T\x07\x16\n\x0c\n\x05\x04\x07\x02\x04\x03\x12\x03T\x19\x1a\n\x0b\
    \n\x04\x04\x07\x02\x05\x12\x03U\x02\x17\n\x0c\n\x05\x04\x07\x02\x05\x05\
    \x12\x03U\x02\x06\n\x0c\n\x05\x04\x07\x02\x05\x01\x12\x03U\x07\x12\n\x0c\
    \n\x05\x04\x07\x02\x05\x03\x12\x03U\x15\x16\n\x0b\n\x04\x04\x07\x02\x06\
    \x12\x03V\x02\x1a\n\x0c\n\x05\x04\x07\x02\x06\x05\x12\x03V\x02\x08\n\x0c\
    \n\x05\x04\x07\x02\x06\x01\x12\x03V\t\x15\n\x0c\n\x05\x04\x07\x02\x06\
    \x03\x12\x03V\x18\x19\n\n\n\x02\x04\x08\x12\x04Y\0a\x01\n\n\n\x03\x04\
    \x08\x01\x12\x03Y\x08\x0c\n\x0b\n\x04\x04\x08\x02\0\x12\x03Z\x02\x18\n\
    \x0c\n\x05\x04\x08\x02\0\x05\x12\x03Z\x02\x06\n\x0c\n\x05\x04\x08\x02\0\
    \x01\x12\x03Z\x07\x13\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03Z\x16\x17\n\
    \x0b\n\x04\x04\x08\x02\x01\x12\x03[\x02\x14\n\x0c\n\x05\x04\x08\x02\x01\
    \x05\x12\x03[\x02\x06\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03[\x07\x0f\n\
    \x0c\n\x05\x04\x08\x02\x01\x03\x12\x03[\x12\x13\n\x0b\n\x04\x04\x08\x02\
    \x02\x12\x03\\\x02\x14\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03\\\x02\x06\
    \n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03\\\x07\x0f\n\x0c\n\x05\x04\x08\
    \x02\x02\x03\x12\x03\\\x12\x13\n\x0b\n\x04\x04\x08\x02\x03\x12\x03]\x02\
    \x15\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03]\x02\x06\n\x0c\n\x05\x04\
    \x08\x02\x03\x01\x12\x03]\x07\x10\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\
    \x03]\x13\x14\n\x0b\n\x04\x04\x08\x02\x04\x12\x03^\x02\x17\n\x0c\n\x05\
    \x04\x08\x02\x04\x05\x12\x03^\x02\x06\n\x0c\n\x05\x04\x08\x02\x04\x01\
    \x12\x03^\x07\x12\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03^\x15\x16\n\x0b\
    \n\x04\x04\x08\x02\x05\x12\x03_\x02\x1c\n\x0c\n\x05\x04\x08\x02\x05\x05\
    \x12\x03_\x02\x08\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\x03_\t\x17\n\x0c\n\
    \x05\x04\x08\x02\x05\x03\x12\x03_\x1a\x1b\n\x0b\n\x04\x04\x08\x02\x06\
    \x12\x03`\x02\x1e\n\x0c\n\x05\x04\x08\x02\x06\x05\x12\x03`\x02\x08\n\x0c\
    \n\x05\x04\x08\x02\x06\x01\x12\x03`\t\x19\n\x0c\n\x05\x04\x08\x02\x06\
    \x03\x12\x03`\x1c\x1d\n\n\n\x02\x04\t\x12\x04c\0g\x01\n\n\n\x03\x04\t\
    \x01\x12\x03c\x08\x14\n\x0b\n\x04\x04\t\x02\0\x12\x03d\x02\x15\n\x0c\n\
    \x05\x04\t\x02\0\x05\x12\x03d\x02\x06\n\x0c\n\x05\x04\t\x02\0\x01\x12\
    \x03d\x07\x10\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03d\x13\x14\n\x0b\n\x04\
    \x04\t\x02\x01\x12\x03e\x02\x17\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03e\
    \x02\x06\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03e\x07\x12\n\x0c\n\x05\x04\
    \t\x02\x01\x03\x12\x03e\x15\x16\n\x0b\n\x04\x04\t\x02\x02\x12\x03f\x02\
    \x19\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03f\x02\x06\n\x0c\n\x05\x04\t\
    \x02\x02\x01\x12\x03f\x07\x14\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03f\x17\
    \x18\n\n\n\x02\x04\n\x12\x04i\0n\x01\n\n\n\x03\x04\n\x01\x12\x03i\x08\
    \x12\n\x0b\n\x04\x04\n\x02\0\x12\x03j\x02\x13\n\x0c\n\x05\x04\n\x02\0\
    \x05\x12\x03j\x02\x06\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03j\x07\x0e\n\x0c\
    \n\x05\x04\n\x02\0\x03\x12\x03j\x11\x12\n\x0b\n\x04\x04\n\x02\x01\x12\
    \x03k\x02\x12\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03k\x02\x06\n\x0c\n\x05\
    \x04\n\x02\x01\x01\x12\x03k\x07\r\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03k\
    \x10\x11\n\x0b\n\x04\x04\n\x02\x02\x12\x03l\x02\x12\n\x0c\n\x05\x04\n\
    \x02\x02\x05\x12\x03l\x02\x06\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03l\x07\
    \r\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03l\x10\x11\n\x0b\n\x04\x04\n\x02\
    \x03\x12\x03m\x02\x11\n\x0c\n\x05\x04\n\x02\x03\x05\x12\x03m\x02\x06\n\
    \x0c\n\x05\x04\n\x02\x03\x01\x12\x03m\x07\x0c\n\x0c\n\x05\x04\n\x02\x03\
    \x03\x12\x03m\x0f\x10\n\n\n\x02\x04\x0b\x12\x04p\0}\x01\n\n\n\x03\x04\
    \x0b\x01\x12\x03p\x08\x0e\n\x0b\n\x04\x04\x0b\x02\0\x12\x03q\x02\x12\n\
    \x0c\n\x05\x04\x0b\x02\0\x05\x12\x03q\x02\x06\n\x0c\n\x05\x04\x0b\x02\0\
    \x01\x12\x03q\x07\r\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03q\x10\x11\n\x0b\
    \n\x04\x04\x0b\x02\x01\x12\x03r\x02\x0e\n\x0c\n\x05\x04\x0b\x02\x01\x05\
    \x12\x03r\x02\x06\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03r\x07\t\n\x0c\n\
    \x05\x04\x0b\x02\x01\x03\x12\x03r\x0c\r\n\x0b\n\x04\x04\x0b\x02\x02\x12\
    \x03s\x02\x0e\n\x0c\n\x05\x04\x0b\x02\x02\x05\x12\x03s\x02\x06\n\x0c\n\
    \x05\x04\x0b\x02\x02\x01\x12\x03s\x07\t\n\x0c\n\x05\x04\x0b\x02\x02\x03\
    \x12\x03s\x0c\r\n\x0b\n\x04\x04\x0b\x02\x03\x12\x03t\x02\x0f\n\x0c\n\x05\
    \x04\x0b\x02\x03\x05\x12\x03t\x02\x06\n\x0c\n\x05\x04\x0b\x02\x03\x01\
    \x12\x03t\x07\n\n\x0c\n\x05\x04\x0b\x02\x03\x03\x12\x03t\r\x0e\n\x0b\n\
    \x04\x04\x0b\x02\x04\x12\x03u\x02\x13\n\x0c\n\x05\x04\x0b\x02\x04\x05\
    \x12\x03u\x02\x06\n\x0c\n\x05\x04\x0b\x02\x04\x01\x12\x03u\x07\x0e\n\x0c\
    \n\x05\x04\x0b\x02\x04\x03\x12\x03u\x11\x12\n\x0b\n\x04\x04\x0b\x02\x05\
    \x12\x03v\x02\x12\n\x0c\n\x05\x04\x0b\x02\x05\x05\x12\x03v\x02\x06\n\x0c\
    \n\x05\x04\x0b\x02\x05\x01\x12\x03v\x07\r\n\x0c\n\x05\x04\x0b\x02\x05\
    \x03\x12\x03v\x10\x11\n\x0b\n\x04\x04\x0b\x02\x06\x12\x03w\x02\x15\n\x0c\
    \n\x05\x04\x0b\x02\x06\x05\x12\x03w\x02\x06\n\x0c\n\x05\x04\x0b\x02\x06\
    \x01\x12\x03w\x07\x10\n\x0c\n\x05\x04\x0b\x02\x06\x03\x12\x03w\x13\x14\n\
    \x0b\n\x04\x04\x0b\x02\x07\x12\x03x\x02\x1b\n\x0c\n\x05\x04\x0b\x02\x07\
    \x06\x12\x03x\x02\x0e\n\x0c\n\x05\x04\x0b\x02\x07\x01\x12\x03x\x0f\x16\n\
    \x0c\n\x05\x04\x0b\x02\x07\x03\x12\x03x\x19\x1a\n\x0b\n\x04\x04\x0b\x02\
    \x08\x12\x03y\x02\x15\n\x0c\n\x05\x04\x0b\x02\x08\x05\x12\x03y\x02\x06\n\
    \x0c\n\x05\x04\x0b\x02\x08\x01\x12\x03y\x07\x0f\n\x0c\n\x05\x04\x0b\x02\
    \x08\x03\x12\x03y\x12\x14\n\x0b\n\x04\x04\x0b\x02\t\x12\x03z\x02\x14\n\
    \x0c\n\x05\x04\x0b\x02\t\x05\x12\x03z\x02\x06\n\x0c\n\x05\x04\x0b\x02\t\
    \x01\x12\x03z\x07\x0e\n\x0c\n\x05\x04\x0b\x02\t\x03\x12\x03z\x11\x13\n\
    \x0b\n\x04\x04\x0b\x02\n\x12\x03{\x02\x17\n\x0c\n\x05\x04\x0b\x02\n\x05\
    \x12\x03{\x02\x06\n\x0c\n\x05\x04\x0b\x02\n\x01\x12\x03{\x07\x11\n\x0c\n\
    \x05\x04\x0b\x02\n\x03\x12\x03{\x14\x16\n\x0b\n\x04\x04\x0b\x02\x0b\x12\
    \x03|\x02\x17\n\x0c\n\x05\x04\x0b\x02\x0b\x06\x12\x03|\x02\x0c\n\x0c\n\
    \x05\x04\x0b\x02\x0b\x01\x12\x03|\r\x11\n\x0c\n\x05\x04\x0b\x02\x0b\x03\
    \x12\x03|\x14\x16\n\x0b\n\x02\x04\x0c\x12\x05\x7f\0\x85\x01\x01\n\n\n\
    \x03\x04\x0c\x01\x12\x03\x7f\x08\r\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x80\
    \x01\x02\x13\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x80\x01\x02\x06\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\x80\x01\x07\x0e\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\x80\x01\x11\x12\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x81\x01\
    \x02\x13\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x81\x01\x02\x07\n\r\n\x05\
    \x04\x0c\x02\x01\x01\x12\x04\x81\x01\x08\x0e\n\r\n\x05\x04\x0c\x02\x01\
    \x03\x12\x04\x81\x01\x11\x12\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\x82\x01\
    \x02\x11\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x82\x01\x02\x07\n\r\n\x05\
    \x04\x0c\x02\x02\x01\x12\x04\x82\x01\x08\x0c\n\r\n\x05\x04\x0c\x02\x02\
    \x03\x12\x04\x82\x01\x0f\x10\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\x83\x01\
    \x02\x0f\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\x83\x01\x02\x07\n\r\n\x05\
    \x04\x0c\x02\x03\x01\x12\x04\x83\x01\x08\n\n\r\n\x05\x04\x0c\x02\x03\x03\
    \x12\x04\x83\x01\r\x0e\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\x84\x01\x02\
    \x15\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\x84\x01\x02\x07\n\r\n\x05\x04\
    \x0c\x02\x04\x01\x12\x04\x84\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x04\x03\
    \x12\x04\x84\x01\x13\x14\n\x0c\n\x02\x04\r\x12\x06\x87\x01\0\x93\x01\x01\
    \n\x0b\n\x03\x04\r\x01\x12\x04\x87\x01\x08\x0f\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\x88\x01\x02\x11\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x88\x01\x02\
    \x07\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x88\x01\x08\x0c\n\r\n\x05\x04\r\
    \x02\0\x03\x12\x04\x88\x01\x0f\x10\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x89\
    \x01\x02\x13\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x89\x01\x02\x07\n\r\n\
    \x05\x04\r\x02\x01\x01\x12\x04\x89\x01\x08\x0e\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x89\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x8a\x01\
    \x02\x19\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\x8a\x01\x02\x07\n\r\n\x05\
    \x04\r\x02\x02\x01\x12\x04\x8a\x01\x08\x14\n\r\n\x05\x04\r\x02\x02\x03\
    \x12\x04\x8a\x01\x17\x18\n\x0c\n\x04\x04\r\x02\x03\x12\x04\x8b\x01\x02\
    \x0f\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\x8b\x01\x02\x07\n\r\n\x05\x04\r\
    \x02\x03\x01\x12\x04\x8b\x01\x08\n\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\
    \x8b\x01\r\x0e\n\x0c\n\x04\x04\r\x02\x04\x12\x04\x8c\x01\x02\x0f\n\r\n\
    \x05\x04\r\x02\x04\x05\x12\x04\x8c\x01\x02\x07\n\r\n\x05\x04\r\x02\x04\
    \x01\x12\x04\x8c\x01\x08\n\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\x8c\x01\r\
    \x0e\n\x0c\n\x04\x04\r\x02\x05\x12\x04\x8d\x01\x02\x0f\n\r\n\x05\x04\r\
    \x02\x05\x05\x12\x04\x8d\x01\x02\x07\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\
    \x8d\x01\x08\n\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\x8d\x01\r\x0e\n\x0c\n\
    \x04\x04\r\x02\x06\x12\x04\x8e\x01\x02\x14\n\r\n\x05\x04\r\x02\x06\x05\
    \x12\x04\x8e\x01\x02\x07\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\x8e\x01\x08\
    \x0f\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\x8e\x01\x12\x13\n\x0c\n\x04\x04\
    \r\x02\x07\x12\x04\x8f\x01\x02\x1e\n\r\n\x05\x04\r\x02\x07\x05\x12\x04\
    \x8f\x01\x02\x08\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\x8f\x01\t\x19\n\r\n\
    \x05\x04\r\x02\x07\x03\x12\x04\x8f\x01\x1c\x1d\n\x0c\n\x04\x04\r\x02\x08\
    \x12\x04\x90\x01\x02\x12\n\r\n\x05\x04\r\x02\x08\x05\x12\x04\x90\x01\x02\
    \x08\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\x90\x01\t\r\n\r\n\x05\x04\r\x02\
    \x08\x03\x12\x04\x90\x01\x10\x11\n!\n\x04\x04\r\x02\t\x12\x04\x92\x01\
    \x02\x13\x1a\x13\x20uint32\x20time\x20=\x2010;\n\n\r\n\x05\x04\r\x02\t\
    \x05\x12\x04\x92\x01\x02\x08\n\r\n\x05\x04\r\x02\t\x01\x12\x04\x92\x01\t\
    \r\n\r\n\x05\x04\r\x02\t\x03\x12\x04\x92\x01\x10\x12\n\x0c\n\x02\x04\x0e\
    \x12\x06\x95\x01\0\xa0\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x95\x01\
    \x08\x0e\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x96\x01\x02\x13\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\x96\x01\x02\x06\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x96\x01\x07\x0e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x96\x01\x11\x12\
    \n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x97\x01\x02\x15\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\x97\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\x97\x01\x07\x10\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x97\x01\x13\
    \x14\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x98\x01\x02\x11\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\x98\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\x98\x01\x07\x0c\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x98\x01\
    \x0f\x10\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\x99\x01\x02\x11\n\r\n\x05\
    \x04\x0e\x02\x03\x05\x12\x04\x99\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x03\
    \x01\x12\x04\x99\x01\x07\x0c\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x99\
    \x01\x0f\x10\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\x9a\x01\x02\x15\n\r\n\
    \x05\x04\x0e\x02\x04\x05\x12\x04\x9a\x01\x02\x06\n\r\n\x05\x04\x0e\x02\
    \x04\x01\x12\x04\x9a\x01\x07\x10\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\
    \x9a\x01\x13\x14\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\x9b\x01\x02\x16\n\r\
    \n\x05\x04\x0e\x02\x05\x05\x12\x04\x9b\x01\x02\x06\n\r\n\x05\x04\x0e\x02\
    \x05\x01\x12\x04\x9b\x01\x07\x11\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\
    \x9b\x01\x14\x15\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\x9c\x01\x02\x0f\n\r\
    \n\x05\x04\x0e\x02\x06\x05\x12\x04\x9c\x01\x02\x06\n\r\n\x05\x04\x0e\x02\
    \x06\x01\x12\x04\x9c\x01\x07\n\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\x9c\
    \x01\r\x0e\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\x9d\x01\x02\x0f\n\r\n\x05\
    \x04\x0e\x02\x07\x05\x12\x04\x9d\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x07\
    \x01\x12\x04\x9d\x01\x07\n\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\x9d\x01\
    \r\x0e\n\x0c\n\x04\x04\x0e\x02\x08\x12\x04\x9e\x01\x02\x14\n\r\n\x05\x04\
    \x0e\x02\x08\x05\x12\x04\x9e\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x08\x01\
    \x12\x04\x9e\x01\x07\x0f\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\x9e\x01\
    \x12\x13\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x9f\x01\x02\x1b\n\r\n\x05\x04\
    \x0e\x02\t\x05\x12\x04\x9f\x01\x02\x06\n\r\n\x05\x04\x0e\x02\t\x01\x12\
    \x04\x9f\x01\x07\x15\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\x9f\x01\x18\x1a\
    \n\x0c\n\x02\x04\x0f\x12\x06\xa2\x01\0\xac\x01\x01\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\xa2\x01\x08\x10\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xa3\x01\
    \x02\x16\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xa3\x01\x02\x08\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\xa3\x01\t\x11\n\r\n\x05\x04\x0f\x02\0\x03\x12\
    \x04\xa3\x01\x14\x15\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xa4\x01\x02\x18\
    \n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\xa4\x01\t\x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\
    \xa4\x01\x16\x17\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xa5\x01\x02\x15\n\r\
    \n\x05\x04\x0f\x02\x02\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x02\x01\x12\x04\xa5\x01\t\x10\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xa5\
    \x01\x13\x14\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xa6\x01\x02\x14\n\r\n\
    \x05\x04\x0f\x02\x03\x05\x12\x04\xa6\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x03\x01\x12\x04\xa6\x01\t\x0f\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xa6\
    \x01\x12\x13\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\xa7\x01\x02\x16\n\r\n\
    \x05\x04\x0f\x02\x04\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x04\x01\x12\x04\xa7\x01\t\x11\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xa7\
    \x01\x14\x15\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xa8\x01\x02\x18\n\r\n\
    \x05\x04\x0f\x02\x05\x05\x12\x04\xa8\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x05\x01\x12\x04\xa8\x01\t\x13\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xa8\
    \x01\x16\x17\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xa9\x01\x02\x15\n\r\n\
    \x05\x04\x0f\x02\x06\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x06\x01\x12\x04\xa9\x01\t\x10\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\xa9\
    \x01\x13\x14\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\xaa\x01\x02\x14\n\r\n\
    \x05\x04\x0f\x02\x07\x05\x12\x04\xaa\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x07\x01\x12\x04\xaa\x01\t\x0f\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xaa\
    \x01\x12\x13\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\xab\x01\x02\x13\n\r\n\
    \x05\x04\x0f\x02\x08\x05\x12\x04\xab\x01\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x08\x01\x12\x04\xab\x01\t\r\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\xab\
    \x01\x10\x12\n\x0c\n\x02\x04\x10\x12\x06\xae\x01\0\xb2\x01\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\xae\x01\x08\r\n\x0c\n\x04\x04\x10\x02\0\x12\x04\
    \xaf\x01\x02\x15\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xaf\x01\x02\x08\n\r\
    \n\x05\x04\x10\x02\0\x01\x12\x04\xaf\x01\t\x10\n\r\n\x05\x04\x10\x02\0\
    \x03\x12\x04\xaf\x01\x13\x14\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xb0\x01\
    \x02\x18\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xb0\x01\x02\x08\n\r\n\x05\
    \x04\x10\x02\x01\x01\x12\x04\xb0\x01\t\x13\n\r\n\x05\x04\x10\x02\x01\x03\
    \x12\x04\xb0\x01\x16\x17\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xb1\x01\x02\
    \x18\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xb1\x01\x02\n\n\r\n\x05\x04\
    \x10\x02\x02\x01\x12\x04\xb1\x01\x0b\x13\n\r\n\x05\x04\x10\x02\x02\x03\
    \x12\x04\xb1\x01\x16\x17\n\x0c\n\x02\x04\x11\x12\x06\xb4\x01\0\xbf\x01\
    \x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb4\x01\x08\x0e\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\xb5\x01\x02\x16\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xb5\
    \x01\x02\t\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb5\x01\n\x11\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xb5\x01\x14\x15\n\x0c\n\x04\x04\x11\x02\x01\
    \x12\x04\xb6\x01\x02\x16\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xb6\x01\
    \x02\t\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xb6\x01\n\x11\n\r\n\x05\x04\
    \x11\x02\x01\x03\x12\x04\xb6\x01\x14\x15\n\x0c\n\x04\x04\x11\x02\x02\x12\
    \x04\xb7\x01\x02\x14\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xb7\x01\x02\
    \x08\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xb7\x01\t\x0f\n\r\n\x05\x04\
    \x11\x02\x02\x03\x12\x04\xb7\x01\x12\x13\n\x0c\n\x04\x04\x11\x02\x03\x12\
    \x04\xb8\x01\x02\x10\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\xb8\x01\x02\
    \x06\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xb8\x01\x07\x0b\n\r\n\x05\x04\
    \x11\x02\x03\x03\x12\x04\xb8\x01\x0e\x0f\n\x0c\n\x04\x04\x11\x02\x04\x12\
    \x04\xb9\x01\x02\x16\n\r\n\x05\x04\x11\x02\x04\x06\x12\x04\xb9\x01\x02\t\
    \n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xb9\x01\n\x11\n\r\n\x05\x04\x11\
    \x02\x04\x03\x12\x04\xb9\x01\x14\x15\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\
    \xba\x01\x02\x14\n\r\n\x05\x04\x11\x02\x05\x06\x12\x04\xba\x01\x02\x08\n\
    \r\n\x05\x04\x11\x02\x05\x01\x12\x04\xba\x01\t\x0f\n\r\n\x05\x04\x11\x02\
    \x05\x03\x12\x04\xba\x01\x12\x13\n\x0c\n\x04\x04\x11\x02\x06\x12\x04\xbb\
    \x01\x02\x14\n\r\n\x05\x04\x11\x02\x06\x06\x12\x04\xbb\x01\x02\x08\n\r\n\
    \x05\x04\x11\x02\x06\x01\x12\x04\xbb\x01\t\x0f\n\r\n\x05\x04\x11\x02\x06\
    \x03\x12\x04\xbb\x01\x12\x13\n\x0c\n\x04\x04\x11\x02\x07\x12\x04\xbc\x01\
    \x02\x12\n\r\n\x05\x04\x11\x02\x07\x06\x12\x04\xbc\x01\x02\x07\n\r\n\x05\
    \x04\x11\x02\x07\x01\x12\x04\xbc\x01\x08\r\n\r\n\x05\x04\x11\x02\x07\x03\
    \x12\x04\xbc\x01\x10\x11\n\x0c\n\x04\x04\x11\x02\x08\x12\x04\xbd\x01\x02\
    \x13\n\r\n\x05\x04\x11\x02\x08\x06\x12\x04\xbd\x01\x02\x07\n\r\n\x05\x04\
    \x11\x02\x08\x01\x12\x04\xbd\x01\x08\r\n\r\n\x05\x04\x11\x02\x08\x03\x12\
    \x04\xbd\x01\x10\x12\n\x0c\n\x04\x04\x11\x02\t\x12\x04\xbe\x01\x02\x15\n\
    \r\n\x05\x04\x11\x02\t\x06\x12\x04\xbe\x01\x02\x08\n\r\n\x05\x04\x11\x02\
    \t\x01\x12\x04\xbe\x01\t\x0f\n\r\n\x05\x04\x11\x02\t\x03\x12\x04\xbe\x01\
    \x12\x14\n\x0c\n\x02\x05\0\x12\x06\xc1\x01\0\xc5\x01\x01\n\x0b\n\x03\x05\
    \0\x01\x12\x04\xc1\x01\x05\x11\n\x0c\n\x04\x05\0\x02\0\x12\x04\xc2\x01\
    \x02\x0b\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xc2\x01\x02\x06\n\r\n\x05\x05\
    \0\x02\0\x02\x12\x04\xc2\x01\t\n\n\x0c\n\x04\x05\0\x02\x01\x12\x04\xc3\
    \x01\x02\x0c\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xc3\x01\x02\x07\n\r\n\
    \x05\x05\0\x02\x01\x02\x12\x04\xc3\x01\n\x0b\n\x0c\n\x04\x05\0\x02\x02\
    \x12\x04\xc4\x01\x02\x0b\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xc4\x01\x02\
    \x06\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xc4\x01\t\n\n\x0c\n\x02\x05\x01\
    \x12\x06\xc7\x01\0\xcc\x01\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xc7\x01\
    \x05\x10\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xc8\x01\x02\r\n\r\n\x05\x05\
    \x01\x02\0\x01\x12\x04\xc8\x01\x02\x08\n\r\n\x05\x05\x01\x02\0\x02\x12\
    \x04\xc8\x01\x0b\x0c\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\xc9\x01\x02\t\n\
    \r\n\x05\x05\x01\x02\x01\x01\x12\x04\xc9\x01\x02\x04\n\r\n\x05\x05\x01\
    \x02\x01\x02\x12\x04\xc9\x01\x07\x08\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\
    \xca\x01\x02\t\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xca\x01\x02\x04\n\r\
    \n\x05\x05\x01\x02\x02\x02\x12\x04\xca\x01\x07\x08\n\x0c\n\x04\x05\x01\
    \x02\x03\x12\x04\xcb\x01\x02\x0c\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\
    \xcb\x01\x02\x07\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\xcb\x01\n\x0b\n\
    \x0c\n\x02\x04\x12\x12\x06\xce\x01\0\xd3\x01\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xce\x01\x08\r\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xcf\x01\x02\x19\
    \n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xcf\x01\x02\x0e\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\xcf\x01\x0f\x14\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \xcf\x01\x17\x18\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xd0\x01\x02\x18\n\r\
    \n\x05\x04\x12\x02\x01\x06\x12\x04\xd0\x01\x02\r\n\r\n\x05\x04\x12\x02\
    \x01\x01\x12\x04\xd0\x01\x0e\x13\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xd0\x01\x16\x17\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xd1\x01\x02\x16\n\r\
    \n\x05\x04\x12\x02\x02\x05\x12\x04\xd1\x01\x02\x08\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xd1\x01\t\x11\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xd1\
    \x01\x14\x15\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xd2\x01\x02\x18\n\r\n\
    \x05\x04\x12\x02\x03\x05\x12\x04\xd2\x01\x02\x08\n\r\n\x05\x04\x12\x02\
    \x03\x01\x12\x04\xd2\x01\t\x13\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xd2\
    \x01\x16\x17b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
